{"version":3,"sources":["../../../../src/mss/MssFragmentMoofProcessor.js"],"names":["MssFragmentMoofProcessor","config","instance","type","logger","dashMetrics","playbackController","errorHandler","errHandler","eventBus","ISOBoxer","debug","setup","getLogger","processTfrf","request","tfrf","tfdt","streamProcessor","representationController","getRepresentationController","representation","getCurrentRepresentation","manifest","adaptation","period","mpd","Period_asArray","index","AdaptationSet_asArray","timescale","SegmentTemplate","getType","timeShiftBufferDepth","error","DashJSError","MssErrors","MSS_NO_TFRF_CODE","MSS_NO_TFRF_MESSAGE","segments","SegmentTimeline","S","entries","entry","segmentTime","range","segment","t","availabilityStartTime","length","tManifest","parseFloat","fragment_absolute_time","start","end","baseMediaDecodeTime","duration","updateDVR","mediaType","getStreamInfo","manifestInfo","d","fragment_duration","lastSegment","push","trigger","Events","MANIFEST_VALIDITY_CHANGED","sender","newDuration","Math","round","splice","updateRepresentation","dvrInfos","getCurrentDVRInfo","addDVRInfo","getTime","getBoxOffset","parent","offset","i","boxes","size","convertFragment","e","isoFile","parseBuffer","response","tfhd","fetch","track_ID","mediaInfo","traf","createFullBox","version","flags","floor","startTime","trun","tfxd","_parent","indexOf","sepiff","usertype","undefined","saio","entry_count","saiz","sample_count","default_sample_info_size","sample_info_size","NumberOfEntries","moof","getLength","data_offset","trafPosInMoof","sencPosInTraf","write","updateSegmentList","Error","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"MssFragmentMoofProcessor.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport DashJSError from '../streaming/vo/DashJSError';\r\nimport MssErrors from './errors/MssErrors';\r\n\r\nimport Events from '../streaming/MediaPlayerEvents';\r\n\r\n/**\r\n * @module MssFragmentMoofProcessor\r\n * @ignore\r\n * @param {Object} config object\r\n */\r\nfunction MssFragmentMoofProcessor(config) {\r\n\r\n    config = config || {};\r\n    let instance,\r\n        type,\r\n        logger;\r\n    const dashMetrics = config.dashMetrics;\r\n    const playbackController = config.playbackController;\r\n    const errorHandler = config.errHandler;\r\n    const eventBus = config.eventBus;\r\n    const ISOBoxer = config.ISOBoxer;\r\n    const debug = config.debug;\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        type = '';\r\n    }\r\n\r\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\r\n        const representationController = streamProcessor.getRepresentationController();\r\n        const representation = representationController.getCurrentRepresentation();\r\n\r\n        const manifest = representation.adaptation.period.mpd.manifest;\r\n        const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\r\n        const timescale = adaptation.SegmentTemplate.timescale;\r\n\r\n        type = streamProcessor.getType();\r\n\r\n        // Process tfrf only for live streams or start-over static streams (timeShiftBufferDepth > 0)\r\n        if (manifest.type !== 'dynamic' && !manifest.timeShiftBufferDepth) {\r\n            return;\r\n        }\r\n\r\n        if (!tfrf) {\r\n            errorHandler.error(new DashJSError(MssErrors.MSS_NO_TFRF_CODE, MssErrors.MSS_NO_TFRF_MESSAGE));\r\n            return;\r\n        }\r\n\r\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\r\n        const segments = adaptation.SegmentTemplate.SegmentTimeline.S;\r\n        const entries = tfrf.entry;\r\n        let entry,\r\n            segmentTime,\r\n            range;\r\n        let segment = null;\r\n        let t = 0;\r\n        let availabilityStartTime = null;\r\n\r\n        if (entries.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)\r\n        entry = entries[0];\r\n\r\n        // In case of start-over streams, check if we have reached end of original manifest duration (set in timeShiftBufferDepth)\r\n        // => then do not update anymore timeline\r\n        if (manifest.type === 'static') {\r\n            // Get first segment time\r\n            segmentTime = segments[0].tManifest ? parseFloat(segments[0].tManifest) : segments[0].t;\r\n            if (entry.fragment_absolute_time > (segmentTime + (manifest.timeShiftBufferDepth * timescale))) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // logger.debug('entry - t = ', (entry.fragment_absolute_time / timescale));\r\n\r\n        // Get last segment time\r\n        segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;\r\n        // logger.debug('Last segment - t = ', (segmentTime / timescale));\r\n\r\n        // Check if we have to append new segment to timeline\r\n        if (entry.fragment_absolute_time <= segmentTime) {\r\n            // Update DVR window range => set range end to end time of current segment\r\n            range = {\r\n                start: segments[0].t / timescale,\r\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\r\n            };\r\n\r\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\r\n            return;\r\n        }\r\n\r\n        // logger.debug('Add new segment - t = ', (entry.fragment_absolute_time / timescale));\r\n        segment = {};\r\n        segment.t = entry.fragment_absolute_time;\r\n        segment.d = entry.fragment_duration;\r\n        // If timestamps starts at 0 relative to 1st segment (dynamic to static) then update segment time\r\n        if (segments[0].tManifest) {\r\n            segment.t -= parseFloat(segments[0].tManifest) - segments[0].t;\r\n            segment.tManifest = entry.fragment_absolute_time;\r\n        }\r\n\r\n        // Patch previous segment duration\r\n        let lastSegment = segments[segments.length - 1];\r\n        if (lastSegment.t + lastSegment.d !== segment.t) {\r\n            logger.debug('Patch segment duration - t = ', lastSegment.t + ', d = ' + lastSegment.d + ' => ' + (segment.t - lastSegment.t));\r\n            lastSegment.d = segment.t - lastSegment.t;\r\n        }\r\n\r\n        segments.push(segment);\r\n\r\n        // In case of static start-over streams, update content duration\r\n        if (manifest.type === 'static') {\r\n            if (type === 'video') {\r\n                segment = segments[segments.length - 1];\r\n                var end = (segment.t + segment.d) / timescale;\r\n                if (end > representation.adaptation.period.duration) {\r\n                    eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { sender: this, newDuration: end });\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        // In case of live streams, update segment timeline according to DVR window\r\n        else if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\r\n            // Get timestamp of the last segment\r\n            segment = segments[segments.length - 1];\r\n            t = segment.t;\r\n\r\n            // Determine the segments' availability start time\r\n            availabilityStartTime = Math.round((t - (manifest.timeShiftBufferDepth * timescale)) / timescale);\r\n\r\n            // Remove segments prior to availability start time\r\n            segment = segments[0];\r\n            while (Math.round(segment.t / timescale) < availabilityStartTime) {\r\n                // logger.debug('Remove segment  - t = ' + (segment.t / timescale));\r\n                segments.splice(0, 1);\r\n                segment = segments[0];\r\n            }\r\n\r\n            // Update DVR window range => set range end to end time of current segment\r\n            range = {\r\n                start: segments[0].t / timescale,\r\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\r\n            };\r\n\r\n            updateDVR(type, range, streamProcessor.getStreamInfo().manifestInfo);\r\n        }\r\n\r\n        representationController.updateRepresentation(representation, true);\r\n    }\r\n\r\n    function updateDVR(type, range, manifestInfo) {\r\n        const dvrInfos = dashMetrics.getCurrentDVRInfo(type);\r\n        if (!dvrInfos || (range.end > dvrInfos.range.end)) {\r\n            logger.debug('Update DVR range: [' + range.start + ' - ' + range.end + ']');\r\n            dashMetrics.addDVRInfo(type, playbackController.getTime(), manifestInfo, range);\r\n        }\r\n    }\r\n\r\n    // This function returns the offset of the 1st byte of a child box within a container box\r\n    function getBoxOffset(parent, type) {\r\n        let offset = 8;\r\n        let i = 0;\r\n\r\n        for (i = 0; i < parent.boxes.length; i++) {\r\n            if (parent.boxes[i].type === type) {\r\n                return offset;\r\n            }\r\n            offset += parent.boxes[i].size;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    function convertFragment(e, streamProcessor) {\r\n        let i;\r\n\r\n        // e.request contains request description object\r\n        // e.response contains fragment bytes\r\n        const isoFile = ISOBoxer.parseBuffer(e.response);\r\n        // Update track_Id in tfhd box\r\n        const tfhd = isoFile.fetch('tfhd');\r\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\r\n\r\n        // Add tfdt box\r\n        let tfdt = isoFile.fetch('tfdt');\r\n        const traf = isoFile.fetch('traf');\r\n        if (tfdt === null) {\r\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\r\n            tfdt.version = 1;\r\n            tfdt.flags = 0;\r\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\r\n        }\r\n\r\n        const trun = isoFile.fetch('trun');\r\n\r\n        // Process tfxd boxes\r\n        // This box provide absolute timestamp but we take the segment start time for tfdt\r\n        let tfxd = isoFile.fetch('tfxd');\r\n        if (tfxd) {\r\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\r\n            tfxd = null;\r\n        }\r\n        let tfrf = isoFile.fetch('tfrf');\r\n        processTfrf(e.request, tfrf, tfdt, streamProcessor);\r\n        if (tfrf) {\r\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\r\n            tfrf = null;\r\n        }\r\n\r\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\r\n        // => convert sepiff box it into a senc box\r\n        // => create saio and saiz boxes (if not already present)\r\n        const sepiff = isoFile.fetch('sepiff');\r\n        if (sepiff !== null) {\r\n            sepiff.type = 'senc';\r\n            sepiff.usertype = undefined;\r\n\r\n            let saio = isoFile.fetch('saio');\r\n            if (saio === null) {\r\n                // Create Sample Auxiliary Information Offsets Box box (saio)\r\n                saio = ISOBoxer.createFullBox('saio', traf);\r\n                saio.version = 0;\r\n                saio.flags = 0;\r\n                saio.entry_count = 1;\r\n                saio.offset = [0];\r\n\r\n                const saiz = ISOBoxer.createFullBox('saiz', traf);\r\n                saiz.version = 0;\r\n                saiz.flags = 0;\r\n                saiz.sample_count = sepiff.sample_count;\r\n                saiz.default_sample_info_size = 0;\r\n                saiz.sample_info_size = [];\r\n\r\n                if (sepiff.flags & 0x02) {\r\n                    // Sub-sample encryption => set sample_info_size for each sample\r\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\r\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\r\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\r\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\r\n                    }\r\n                } else {\r\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\r\n                    saiz.default_sample_info_size = 8;\r\n                }\r\n            }\r\n        }\r\n\r\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\r\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\r\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\r\n\r\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\r\n        const moof = isoFile.fetch('moof');\r\n        let length = moof.getLength();\r\n        trun.data_offset = length + 8;\r\n\r\n        // Update saio box offset field according to new senc box offset\r\n        let saio = isoFile.fetch('saio');\r\n        if (saio !== null) {\r\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\r\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\r\n            // Set offset from begin fragment to the first IV field in senc box\r\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\r\n        }\r\n\r\n        // Write transformed/processed fragment into request reponse data\r\n        e.response = isoFile.write();\r\n    }\r\n\r\n    function updateSegmentList(e, streamProcessor) {\r\n        // e.request contains request description object\r\n        // e.response contains fragment bytes\r\n        if (!e.response) {\r\n            throw new Error('e.response parameter is missing');\r\n        }\r\n\r\n        const isoFile = ISOBoxer.parseBuffer(e.response);\r\n        // Update track_Id in tfhd box\r\n        const tfhd = isoFile.fetch('tfhd');\r\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\r\n\r\n        // Add tfdt box\r\n        let tfdt = isoFile.fetch('tfdt');\r\n        let traf = isoFile.fetch('traf');\r\n        if (tfdt === null) {\r\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\r\n            tfdt.version = 1;\r\n            tfdt.flags = 0;\r\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\r\n        }\r\n\r\n        let tfrf = isoFile.fetch('tfrf');\r\n        processTfrf(e.request, tfrf, tfdt, streamProcessor);\r\n        if (tfrf) {\r\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\r\n            tfrf = null;\r\n        }\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    instance = {\r\n        convertFragment: convertFragment,\r\n        updateSegmentList: updateSegmentList,\r\n        getType: getType\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\r\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\r\n"]}