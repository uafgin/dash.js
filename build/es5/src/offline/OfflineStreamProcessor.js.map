{"version":3,"sources":["../../../../src/offline/OfflineStreamProcessor.js"],"names":["OfflineStreamProcessor","config","context","eventBus","events","errors","debug","constants","settings","dashConstants","manifestId","id","type","streamInfo","errHandler","mediaPlayerModel","abrController","playbackController","adapter","dashMetrics","baseURLController","timelineConverter","bitrate","offlineStoreController","completedCb","callbacks","completed","progressCb","progression","instance","logger","mediaInfo","indexHandler","representationController","fragmentModel","updating","downloadedSegments","isInitialized","isStopped","setup","resetInitialSettings","getLogger","create","requestModifier","getInstance","urlUtils","fragmentLoader","on","STREAM_COMPLETED","onStreamCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","initialize","_mediaInfo","updateRepresentation","isInitRequest","request","e","sender","isInit","suffix","index","fragmentName","representationId","storeFragment","response","then","setRepresentationCurrentState","downloaded","error","serviceLocation","executeRequest","download","info","stop","getRepresentationController","getRepresentationId","getCurrentRepresentation","removeExecutedRequestsBeforeTime","time","getInitRequest","getMediaInfo","getNextRequest","getNextSegmentRequest","start","Error","getRepresentationCurrentState","state","setCurrentIndex","catch","isNaN","updateProgression","url","voRepresentations","getVoRepresentations","quality","findIndex","representation","VIDEO","AUDIO","TEXT","FRAGMENTED_TEXT","updateData","isUpdating","getType","getAvailableSegmentsNumber","availableSegmentsNumber","reset","off","__dashjs_factory_name","factory","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineStreamProcessor.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport DashHandler from '../dash/DashHandler';\r\nimport RepresentationController from '../dash/controllers/RepresentationController';\r\nimport FragmentModel from '../streaming/models/FragmentModel';\r\nimport FragmentLoader from '../streaming/FragmentLoader';\r\nimport URLUtils from '../streaming/utils/URLUtils';\r\nimport RequestModifier from '../streaming/utils/RequestModifier';\r\n\r\n\r\nfunction OfflineStreamProcessor(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = config.eventBus;\r\n    const events = config.events;\r\n    const errors = config.errors;\r\n    const debug = config.debug;\r\n    const constants = config.constants;\r\n    const settings = config.settings;\r\n    const dashConstants = config.dashConstants;\r\n    const manifestId = config.id;\r\n    const type = config.type;\r\n    const streamInfo = config.streamInfo;\r\n    const errHandler = config.errHandler;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const adapter = config.adapter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const baseURLController = config.baseURLController;\r\n    const timelineConverter = config.timelineConverter;\r\n    const bitrate = config.bitrate;\r\n    const offlineStoreController = config.offlineStoreController;\r\n    const completedCb = config.callbacks && config.callbacks.completed;\r\n    const progressCb = config.callbacks && config.callbacks.progression;\r\n\r\n    let instance,\r\n        logger,\r\n        mediaInfo,\r\n        indexHandler,\r\n        representationController,\r\n        fragmentModel,\r\n        updating,\r\n        downloadedSegments,\r\n        isInitialized,\r\n        isStopped;\r\n\r\n    function setup() {\r\n        resetInitialSettings();\r\n        logger = debug.getLogger(instance);\r\n\r\n        indexHandler = DashHandler(context).create({\r\n            streamInfo: streamInfo,\r\n            type: type,\r\n            timelineConverter: timelineConverter,\r\n            dashMetrics: dashMetrics,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            baseURLController: baseURLController,\r\n            errHandler: errHandler,\r\n            settings: settings,\r\n            // boxParser: boxParser,\r\n            eventBus: eventBus,\r\n            events: events,\r\n            debug: debug,\r\n            requestModifier: RequestModifier(context).getInstance(),\r\n            dashConstants: dashConstants,\r\n            constants: constants,\r\n            urlUtils: URLUtils(context).getInstance()\r\n        });\r\n\r\n        representationController = RepresentationController(context).create({\r\n            streamInfo: streamInfo,\r\n            type: type,\r\n            abrController: abrController,\r\n            dashMetrics: dashMetrics,\r\n            playbackController: playbackController,\r\n            timelineConverter: timelineConverter,\r\n            dashConstants: dashConstants,\r\n            events: events,\r\n            eventBus: eventBus,\r\n            errors: errors\r\n        });\r\n\r\n        fragmentModel = FragmentModel(context).create({\r\n            streamInfo: streamInfo,\r\n            dashMetrics: dashMetrics,\r\n            fragmentLoader: FragmentLoader(context).create({\r\n                dashMetrics: dashMetrics,\r\n                mediaPlayerModel: mediaPlayerModel,\r\n                errHandler: errHandler,\r\n                requestModifier: RequestModifier(context).getInstance(),\r\n                settings: settings,\r\n                eventBus: eventBus,\r\n                events: events,\r\n                errors: errors,\r\n                constants: constants,\r\n                dashConstants: dashConstants,\r\n                urlUtils: URLUtils(context).getInstance()\r\n            }),\r\n            debug: debug,\r\n            eventBus: eventBus,\r\n            events: events\r\n        });\r\n\r\n        eventBus.on(events.STREAM_COMPLETED, onStreamCompleted, instance);\r\n        eventBus.on(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance);\r\n    }\r\n\r\n    function initialize(_mediaInfo) {\r\n        mediaInfo = _mediaInfo;\r\n        indexHandler.initialize(false);\r\n        updateRepresentation(mediaInfo);\r\n    }\r\n\r\n    function isInitRequest(request) {\r\n        return request.type === 'InitializationSegment';\r\n    }\r\n\r\n    function onFragmentLoadingCompleted(e) {\r\n        if (e.sender !== fragmentModel) {\r\n            return;\r\n        }\r\n\r\n        if (e.request !== null) {\r\n            let isInit = isInitRequest(e.request);\r\n            let suffix = isInit ? 'init' : e.request.index;\r\n            let fragmentName = e.request.representationId + '_' + suffix;\r\n            offlineStoreController.storeFragment(manifestId, fragmentName, e.response)\r\n            .then(() => {\r\n                if (!isInit) {\r\n                    // store current index and downloadedSegments number\r\n                    offlineStoreController.setRepresentationCurrentState(manifestId, e.request.representationId, {\r\n                        index: e.request.index,\r\n                        downloaded: downloadedSegments\r\n                    } );\r\n                }\r\n            });\r\n        }\r\n\r\n        if (e.error && e.request.serviceLocation && !isStopped) {\r\n            fragmentModel.executeRequest(e.request);\r\n        } else {\r\n            downloadedSegments++;\r\n            download();\r\n        }\r\n    }\r\n\r\n    function onStreamCompleted(e) {\r\n        if (e.fragmentModel !== fragmentModel) {\r\n            return;\r\n        }\r\n        logger.info(`[${manifestId}] Stream is complete`);\r\n        stop();\r\n        completedCb();\r\n    }\r\n\r\n    function getRepresentationController () {\r\n        return representationController;\r\n    }\r\n\r\n    function getRepresentationId() {\r\n        return representationController.getCurrentRepresentation().id;\r\n    }\r\n\r\n    /**\r\n     * Stops download of fragments\r\n     * @memberof OfflineStreamProcessor#\r\n     */\r\n    function stop() {\r\n        if (isStopped) {\r\n            return;\r\n        }\r\n        isStopped = true;\r\n    }\r\n\r\n\r\n    function removeExecutedRequestsBeforeTime(time) {\r\n        if (fragmentModel) {\r\n            fragmentModel.removeExecutedRequestsBeforeTime(time);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Execute init request for the represenation\r\n     * @memberof OfflineStreamProcessor#\r\n    */\r\n    function getInitRequest() {\r\n        if (!representationController.getCurrentRepresentation()) {\r\n            return null;\r\n        }\r\n\r\n        return indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation());\r\n    }\r\n\r\n    /**\r\n     * Get next request\r\n     * @memberof OfflineStreamProcessor#\r\n    */\r\n    function getNextRequest() {\r\n        return indexHandler.getNextSegmentRequest(getMediaInfo(), representationController.getCurrentRepresentation());\r\n    }\r\n\r\n    /**\r\n     * Start download\r\n     * @memberof OfflineStreamProcessor#\r\n    */\r\n    function start() {\r\n        if (representationController) {\r\n            if (!representationController.getCurrentRepresentation()) {\r\n                throw new Error('Start denied to OfflineStreamProcessor');\r\n            }\r\n            isStopped = false;\r\n\r\n            offlineStoreController.getRepresentationCurrentState(manifestId, representationController.getCurrentRepresentation().id)\r\n            .then((state) => {\r\n                if (state) {\r\n                    indexHandler.setCurrentIndex(state.index);\r\n                    downloadedSegments = state.downloaded;\r\n                }\r\n                download();\r\n            }).catch(() => {\r\n                // start from beginining\r\n                download();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Performs download of fragment according to type\r\n     * @memberof OfflineStreamProcessor#\r\n    */\r\n    function download() {\r\n        if (isStopped) {\r\n            return;\r\n        }\r\n\r\n        if (isNaN(representationController.getCurrentRepresentation())) {\r\n            let request = null;\r\n            if (!isInitialized) {\r\n                request = getInitRequest();\r\n                isInitialized = true;\r\n            } else {\r\n                request = getNextRequest();\r\n\r\n                // update progression : done here because availableSegmentsNumber is done in getNextRequest from dash handler\r\n                updateProgression();\r\n            }\r\n\r\n            if (request) {\r\n                logger.info(`[${manifestId}] download request : ${request.url}`);\r\n                fragmentModel.executeRequest(request);\r\n            } else {\r\n                logger.info(`[${manifestId}] no request to be downloaded`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update representation\r\n     * @param {Object} mediaInfo - mediaInfo\r\n     * @memberof OfflineStreamProcessor#\r\n     */\r\n    function updateRepresentation(mediaInfo) {\r\n        updating = true;\r\n\r\n        let voRepresentations = adapter.getVoRepresentations(mediaInfo);\r\n\r\n        // get representation VO according to id.\r\n        let quality = voRepresentations.findIndex((representation) => {\r\n            return representation.id === bitrate.id;\r\n        });\r\n\r\n        if (type !== constants.VIDEO && type !== constants.AUDIO  && type !== constants.TEXT && type !== constants.FRAGMENTED_TEXT) {\r\n            updating = false;\r\n            return;\r\n        }\r\n\r\n        representationController.updateData(null, voRepresentations, type, quality);\r\n    }\r\n\r\n    function isUpdating() {\r\n        return updating;\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function getMediaInfo() {\r\n        return mediaInfo;\r\n    }\r\n\r\n    function getAvailableSegmentsNumber() {\r\n        return representationController.getCurrentRepresentation().availableSegmentsNumber + 1; // do not forget init segment\r\n    }\r\n\r\n    function updateProgression () {\r\n        if (progressCb) {\r\n            progressCb(instance, downloadedSegments, getAvailableSegmentsNumber());\r\n        }\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        isInitialized = false;\r\n        downloadedSegments = 0;\r\n        updating = false;\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     * @memberof OfflineStreamProcessor#\r\n    */\r\n    function reset() {\r\n        resetInitialSettings();\r\n        indexHandler.reset();\r\n\r\n        eventBus.off(events.STREAM_COMPLETED, onStreamCompleted, instance);\r\n        eventBus.off(events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, instance);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getMediaInfo: getMediaInfo,\r\n        getRepresentationController: getRepresentationController,\r\n        removeExecutedRequestsBeforeTime: removeExecutedRequestsBeforeTime,\r\n        getType: getType,\r\n        getRepresentationId: getRepresentationId,\r\n        isUpdating: isUpdating,\r\n        start: start,\r\n        stop: stop,\r\n        getAvailableSegmentsNumber: getAvailableSegmentsNumber,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\nOfflineStreamProcessor.__dashjs_factory_name = 'OfflineStreamProcessor';\r\nconst factory = dashjs.FactoryMaker.getClassFactory(OfflineStreamProcessor); /* jshint ignore:line */\r\nexport default factory;\r\n"]}