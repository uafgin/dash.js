{"version":3,"sources":["../../../../../src/offline/controllers/OfflineController.js"],"names":["OfflineController","config","context","errHandler","events","errors","settings","eventBus","debug","manifestLoader","manifestModel","mediaPlayerModel","abrController","playbackController","dashMetrics","timelineConverter","adapter","manifestUpdater","baseURLController","schemeLoaderFactory","constants","dashConstants","urlUtils","instance","downloads","logger","offlineStoreController","offlineUrlUtils","setup","getLogger","create","getInstance","registerUrlRegex","getRegex","registerLoader","OfflineConstants","OFFLINE_SCHEME","IndexDBOfflineLoader","getDownloadFromId","id","download","find","item","getId","createDownloadFromId","push","createDownloadFromStorage","offline","manifestId","status","OFFLINE_STATUS_STARTED","OFFLINE_STATUS_STOPPED","setInitialState","url","progress","originalUrl","originalURL","removeDownloadFromId","Promise","resolve","reject","waitForStatusChanged","isDownloading","downloadStopped","off","OFFLINE_RECORD_STOPPED","deleteDownloadById","then","catch","err","on","deleteDownload","index","indexOf","splice","generateManifestId","timestamp","Date","getTime","loadRecordsFromStorage","getAllManifests","items","manifests","forEach","e","error","getAllRecords","records","record","OfflineRecord","getDownloadProgression","getOfflineUrl","getManifestUrl","getStatus","createRecord","manifestURL","downloadFromUrl","initDownload","startRecord","mediaInfos","startDownload","stopRecord","stopDownload","resumeRecord","resumeDownload","deleteRecord","getRecordProgression","resetRecords","resetDownload","reset","unregisterLoader","__dashjs_factory_name","factory","dashjs","FactoryMaker","getClassFactory","OfflineEvents","OfflineErrors","updateClassFactory"],"mappings":"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","file":"OfflineController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport OfflineConstants from '../constants/OfflineConstants';\r\nimport OfflineStoreController from './OfflineStoreController';\r\nimport OfflineDownload from '../OfflineDownload';\r\nimport IndexDBOfflineLoader from '../net/IndexDBOfflineLoader';\r\nimport OfflineUrlUtils from '../utils/OfflineUrlUtils';\r\nimport OfflineEvents from '../events/OfflineEvents';\r\nimport OfflineErrors from '../errors/OfflineErrors';\r\nimport OfflineRecord from '../vo/OfflineDownloadVo';\r\n\r\n/**\r\n * @module OfflineController\r\n * @param {Object} config - dependencies\r\n * @description Provides access to offline stream recording and playback functionality.\r\n */\r\nfunction OfflineController(config) {\r\n\r\n    const context = this.context;\r\n    const errHandler = config.errHandler;\r\n    const events = config.events;\r\n    const errors = config.errors;\r\n    const settings = config.settings;\r\n    const eventBus = config.eventBus;\r\n    const debug = config.debug;\r\n    const manifestLoader = config.manifestLoader;\r\n    const manifestModel = config.manifestModel;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const dashMetrics = config.dashMetrics;\r\n    const timelineConverter = config.timelineConverter;\r\n    const adapter = config.adapter;\r\n    const manifestUpdater = config.manifestUpdater;\r\n    const baseURLController = config.baseURLController;\r\n    const schemeLoaderFactory = config.schemeLoaderFactory;\r\n    const constants = config.constants;\r\n    const dashConstants = config.dashConstants;\r\n    const urlUtils = config.urlUtils;\r\n\r\n    let instance,\r\n        downloads,\r\n        logger,\r\n        offlineStoreController,\r\n        offlineUrlUtils;\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        offlineStoreController = OfflineStoreController(context).create({\r\n            eventBus: config.eventBus,\r\n            errHandler: errHandler\r\n        });\r\n        offlineUrlUtils = OfflineUrlUtils(context).getInstance();\r\n        urlUtils.registerUrlRegex(offlineUrlUtils.getRegex(), offlineUrlUtils);\r\n        schemeLoaderFactory.registerLoader(OfflineConstants.OFFLINE_SCHEME, IndexDBOfflineLoader);\r\n\r\n        downloads = [];\r\n    }\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n        DOWNLOAD LIST FUNCTIONS\r\n    ---------------------------------------------------------------------------\r\n    */\r\n    function getDownloadFromId(id) {\r\n        let download = downloads.find((item) => {\r\n            return item.getId() === id;\r\n        });\r\n        return download;\r\n    }\r\n\r\n    function createDownloadFromId(id) {\r\n        let download;\r\n        download = getDownloadFromId(id);\r\n\r\n        if (!download) {\r\n            // create download controller\r\n            download = OfflineDownload(context).create({\r\n                id: id,\r\n                eventBus: eventBus,\r\n                events: events,\r\n                errors: errors,\r\n                settings: settings,\r\n                manifestLoader: manifestLoader,\r\n                manifestModel: manifestModel,\r\n                mediaPlayerModel: mediaPlayerModel,\r\n                manifestUpdater: manifestUpdater,\r\n                baseURLController: baseURLController,\r\n                abrController: abrController,\r\n                playbackController: playbackController,\r\n                adapter: adapter,\r\n                dashMetrics: dashMetrics,\r\n                timelineConverter: timelineConverter,\r\n                errHandler: errHandler,\r\n                offlineStoreController: offlineStoreController,\r\n                debug: debug,\r\n                constants: constants,\r\n                dashConstants: dashConstants,\r\n                urlUtils: urlUtils\r\n            });\r\n\r\n            downloads.push(download);\r\n        }\r\n\r\n        return download;\r\n    }\r\n\r\n    function createDownloadFromStorage(offline) {\r\n        let download = getDownloadFromId(offline.manifestId);\r\n\r\n        if (!download) {\r\n            download = createDownloadFromId(offline.manifestId);\r\n            let status = offline.status;\r\n            if (status === OfflineConstants.OFFLINE_STATUS_STARTED) {\r\n                status = OfflineConstants.OFFLINE_STATUS_STOPPED;\r\n            }\r\n\r\n            download.setInitialState({\r\n                url: offline.url,\r\n                progress: offline.progress,\r\n                originalUrl: offline.originalURL,\r\n                status: status\r\n            });\r\n        }\r\n\r\n        return download;\r\n    }\r\n\r\n    function removeDownloadFromId(id) {\r\n        return new Promise(function (resolve, reject) {\r\n            let download = getDownloadFromId(id);\r\n            let waitForStatusChanged = false;\r\n            if (download) {\r\n                //is download running?\r\n                if (download.isDownloading()) {\r\n                    //register status changed event\r\n                    waitForStatusChanged = true;\r\n                    const downloadStopped = function () {\r\n                        eventBus.off(events.OFFLINE_RECORD_STOPPED, downloadStopped, instance);\r\n                        return offlineStoreController.deleteDownloadById(id).then(function () {\r\n                            resolve();\r\n                        }).catch(function (err) {\r\n                            reject(err);\r\n                        });\r\n                    };\r\n                    eventBus.on(events.OFFLINE_RECORD_STOPPED, downloadStopped, instance);\r\n                }\r\n                download.deleteDownload();\r\n                let index = downloads.indexOf(download);\r\n                downloads.splice(index, 1);\r\n            }\r\n\r\n            if (!waitForStatusChanged) {\r\n                resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    function generateManifestId() {\r\n        let timestamp = new Date().getTime();\r\n        return timestamp;\r\n    }\r\n\r\n    /*\r\n    ---------------------------------------------------------------------------\r\n\r\n        OFFLINE CONTROLLER API\r\n\r\n    ---------------------------------------------------------------------------\r\n    */\r\n\r\n    /**\r\n     * Loads records from storage\r\n     * This methods has to be called first, to be sure that all downloads have been loaded\r\n     *\r\n     * @return {Promise} asynchronously resolved\r\n     * @memberof module:OfflineController\r\n     */\r\n    function loadRecordsFromStorage() {\r\n        return new Promise(function (resolve, reject) {\r\n            offlineStoreController.getAllManifests().then((items) => {\r\n                items.manifests.forEach((offline) => {\r\n                    createDownloadFromStorage(offline);\r\n                });\r\n\r\n                resolve();\r\n            }).catch((e) => {\r\n                logger.error('Failed to load downloads ' + e);\r\n                reject(e);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get all records from storage\r\n     *\r\n     * @return {Promise} asynchronously resolved with records\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function getAllRecords() {\r\n        let records = [];\r\n        downloads.forEach((download) => {\r\n            const record = new OfflineRecord();\r\n            record.id = download.getId();\r\n            record.progress = download.getDownloadProgression();\r\n            record.url = download.getOfflineUrl();\r\n            record.originalUrl = download.getManifestUrl();\r\n            record.status = download.getStatus();\r\n            records.push(record);\r\n        });\r\n        return records;\r\n    }\r\n\r\n    /**\r\n     * Create a new content record in storage and download manifest from url\r\n     *\r\n     * @param {string} manifestURL - the content manifest url\r\n     * @return {Promise} asynchronously resolved with record identifier\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function createRecord(manifestURL) {\r\n        return new Promise(function (resolve, reject) {\r\n            let id = generateManifestId();\r\n\r\n            // create download controller\r\n            let download = createDownloadFromId(id);\r\n\r\n            download.downloadFromUrl(manifestURL).then(() => {\r\n                download.initDownload();\r\n                resolve(id);\r\n            })\r\n            .catch((e) => {\r\n                logger.error('Failed to download ' + e);\r\n                removeDownloadFromId(id).then(function () {\r\n                    reject(e);\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Start downloading the record with selected tracks representations\r\n     *\r\n     * @param {string} id - record identifier\r\n     * @param {MediaInfo[]} mediaInfos - the selected tracks representations\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function startRecord(id, mediaInfos) {\r\n        let download = getDownloadFromId(id);\r\n        if (download) {\r\n            download.startDownload(mediaInfos);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop downloading of the record\r\n     *\r\n     * @param {string} id - record identifier\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function stopRecord(id) {\r\n        let download = getDownloadFromId(id);\r\n        if (download) {\r\n            download.stopDownload();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume downloading of the record\r\n     *\r\n     * @param {string} id - record identifier\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function resumeRecord(id) {\r\n        let download = getDownloadFromId(id);\r\n        if (download) {\r\n            download.resumeDownload();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes a record from storage\r\n     *\r\n     * @param {string} id - record identifier\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function deleteRecord(id) {\r\n        return removeDownloadFromId(id).then(function () {\r\n            return offlineStoreController.deleteDownloadById(id);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Get download progression of a record\r\n     *\r\n     * @param {string} id - record identifier\r\n     * @return {number} percentage progression\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function getRecordProgression(id) {\r\n        let download = getDownloadFromId(id);\r\n        if (download) {\r\n            return download.getDownloadProgression();\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Reset all records\r\n     * @memberof module:OfflineController\r\n     * @instance\r\n     */\r\n    function resetRecords() {\r\n        downloads.forEach((download) => {\r\n            download.resetDownload();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     * @instance\r\n     */\r\n    function reset() {\r\n        resetRecords();\r\n        schemeLoaderFactory.unregisterLoader(OfflineConstants.OFFLINE_SCHEME);\r\n    }\r\n\r\n    instance = {\r\n        loadRecordsFromStorage: loadRecordsFromStorage,\r\n        createRecord: createRecord,\r\n        startRecord: startRecord,\r\n        stopRecord: stopRecord,\r\n        resumeRecord: resumeRecord,\r\n        deleteRecord: deleteRecord,\r\n        getRecordProgression: getRecordProgression,\r\n        getAllRecords: getAllRecords,\r\n        resetRecords: resetRecords,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nOfflineController.__dashjs_factory_name = 'OfflineController';\r\nconst factory = dashjs.FactoryMaker.getClassFactory(OfflineController); /* jshint ignore:line */\r\nfactory.events = OfflineEvents;\r\nfactory.errors = OfflineErrors;\r\ndashjs.FactoryMaker.updateClassFactory(OfflineController.__dashjs_factory_name, factory); /* jshint ignore:line */\r\nexport default factory;\r\n"]}