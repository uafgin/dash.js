{"version":3,"sources":["../../../../src/offline/OfflineStream.js"],"names":["OfflineStream","config","context","eventBus","events","errors","constants","dashConstants","settings","debug","errHandler","mediaPlayerModel","abrController","playbackController","adapter","dashMetrics","baseURLController","timelineConverter","offlineStoreController","manifestId","id","startedCb","callbacks","started","progressionCb","progression","finishedCb","finished","updateManifest","updateManifestNeeded","instance","offlineStreamProcessors","startedOfflineStreamProcessors","finishedOfflineStreamProcessors","streamInfo","representationsToUpdate","allMediasInfosList","progressionById","setup","resetInitialSettings","initialize","initStreamInfo","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","getStreamId","getMediaInfos","mediaInfos","getAllMediaInfoForType","VIDEO","concat","AUDIO","FRAGMENTED_TEXT","TEXT","trigger","OFFLINE_RECORD_LOADEDMETADATA","initializeAllMediasInfoList","mediasInfoList","initializeMedia","createOfflineStreamProcessorFor","MUXED","IMAGE","type","allMediaInfoForType","forEach","media","bitrateList","filter","bitrate","indexOf","length","mediaInfo","createStreamProcessor","streamProcessor","create","mimeType","completed","onStreamCompleted","onStreamProgression","push","sender","message","downloadedSegments","availableSegments","getRepresentationId","segments","allSegments","waitForAllProgress","property","hasOwnProperty","e","currentRepresentation","sp","i","getRepresentationController","getType","mediaType","checkIfAllOfflineStreamProcessorsStarted","representations","startOfflineStreamProcessors","getStreamInfo","getStartTime","start","NaN","getDuration","duration","stopOfflineStreamProcessors","stop","deactivate","ln","removeExecutedRequestsBeforeTime","reset","off","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineStream.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport OfflineStreamProcessor from './OfflineStreamProcessor';\r\n\r\n/**\r\n * Initialize and Manage Offline Stream for each type\r\n */\r\n/**\r\n * @class OfflineStream\r\n * @description Initialize and Manage Offline Stream for each type\r\n * @param {Object} config - dependences\r\n * @ignore\r\n */\r\nfunction OfflineStream(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = config.eventBus;\r\n    const events = config.events;\r\n    const errors = config.errors;\r\n    const constants = config.constants;\r\n    const dashConstants = config.dashConstants;\r\n    const settings = config.settings;\r\n    const debug = config.debug;\r\n    const errHandler = config.errHandler;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const adapter = config.adapter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const baseURLController = config.baseURLController;\r\n    const timelineConverter = config.timelineConverter;\r\n    const offlineStoreController = config.offlineStoreController;\r\n    const manifestId = config.id;\r\n    const startedCb = config.callbacks && config.callbacks.started;\r\n    const progressionCb = config.callbacks && config.callbacks.progression;\r\n    const finishedCb = config.callbacks && config.callbacks.finished;\r\n    const updateManifest = config.callbacks && config.callbacks.updateManifestNeeded;\r\n\r\n    let instance,\r\n        offlineStreamProcessors,\r\n        startedOfflineStreamProcessors,\r\n        finishedOfflineStreamProcessors,\r\n        streamInfo,\r\n        representationsToUpdate,\r\n        allMediasInfosList,\r\n        progressionById;\r\n\r\n    function setup() {\r\n        resetInitialSettings();\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     */\r\n    function resetInitialSettings() {\r\n        streamInfo = null;\r\n        offlineStreamProcessors = [];\r\n        startedOfflineStreamProcessors = 0;\r\n        finishedOfflineStreamProcessors = 0;\r\n        allMediasInfosList = [];\r\n        representationsToUpdate = [];\r\n        progressionById = {};\r\n    }\r\n\r\n    /**\r\n     * Initialize offlinestream\r\n     * @param {Object} initStreamInfo\r\n     */\r\n    function initialize(initStreamInfo) {\r\n        streamInfo = initStreamInfo;\r\n        eventBus.on(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n    }\r\n\r\n    function getStreamId() {\r\n        return streamInfo.id;\r\n    }\r\n\r\n    /**\r\n     * Creates media infos list, so that user will be able to choose the representation he wants to download\r\n     */\r\n    function getMediaInfos() {\r\n        let mediaInfos = adapter.getAllMediaInfoForType(streamInfo, constants.VIDEO);\r\n        mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.AUDIO));\r\n        mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.FRAGMENTED_TEXT));\r\n        mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.TEXT));\r\n\r\n        // mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.MUXED));\r\n        // mediaInfos = mediaInfos.concat(adapter.getAllMediaInfoForType(streamInfo, constants.IMAGE));\r\n\r\n        eventBus.trigger(events.OFFLINE_RECORD_LOADEDMETADATA, {\r\n            id: manifestId,\r\n            mediaInfos: mediaInfos\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Initialize with choosen representations by user\r\n     * @param {Object} mediasInfoList\r\n     */\r\n    function initializeAllMediasInfoList(mediasInfoList) {\r\n        allMediasInfosList = mediasInfoList;\r\n        initializeMedia(streamInfo);\r\n    }\r\n\r\n    /**\r\n     * Initialize media for each type\r\n     * @param {Object} streamInfo\r\n     */\r\n    function initializeMedia(streamInfo) {\r\n        createOfflineStreamProcessorFor(constants.VIDEO,streamInfo);\r\n        createOfflineStreamProcessorFor(constants.AUDIO,streamInfo);\r\n        createOfflineStreamProcessorFor(constants.FRAGMENTED_TEXT,streamInfo);\r\n        createOfflineStreamProcessorFor(constants.TEXT,streamInfo);\r\n\r\n        createOfflineStreamProcessorFor(constants.MUXED,streamInfo);\r\n        createOfflineStreamProcessorFor(constants.IMAGE,streamInfo);\r\n    }\r\n\r\n    function createOfflineStreamProcessorFor(type, streamInfo) {\r\n        // filter mediaInfo according to choosen representation id\r\n        let allMediaInfoForType = adapter.getAllMediaInfoForType(streamInfo, type);\r\n        allMediaInfoForType.forEach((media) => {\r\n            media.bitrateList = media.bitrateList.filter((bitrate) => {\r\n                if (allMediasInfosList[type] && allMediasInfosList[type].indexOf(bitrate.id) !== -1) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        });\r\n\r\n        allMediaInfoForType = allMediaInfoForType.filter((media) => {\r\n            return (media.bitrateList && media.bitrateList.length > 0);\r\n        });\r\n\r\n        // cration of an offline stream processor for each choosen representation\r\n        allMediaInfoForType.forEach((mediaInfo) => {\r\n            if (mediaInfo.bitrateList) {\r\n                mediaInfo.bitrateList.forEach((bitrate) => {\r\n                    createStreamProcessor(mediaInfo, bitrate);\r\n                });\r\n            }\r\n        });\r\n        return allMediaInfoForType;\r\n    }\r\n\r\n    function createStreamProcessor (mediaInfo, bitrate) {\r\n\r\n        let streamProcessor = OfflineStreamProcessor(context).create({\r\n            id: manifestId,\r\n            streamInfo: streamInfo,\r\n            debug: debug,\r\n            events: events,\r\n            errors: errors,\r\n            eventBus: eventBus,\r\n            constants: constants,\r\n            dashConstants: dashConstants,\r\n            settings: settings,\r\n            type: mediaInfo.type,\r\n            mimeType: mediaInfo.mimeType,\r\n            bitrate: bitrate,\r\n            errHandler: errHandler,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            abrController: abrController,\r\n            playbackController: playbackController,\r\n            adapter: adapter,\r\n            dashMetrics: dashMetrics,\r\n            baseURLController: baseURLController,\r\n            timelineConverter: timelineConverter,\r\n            offlineStoreController: offlineStoreController,\r\n            callbacks: {\r\n                completed: onStreamCompleted,\r\n                progression: onStreamProgression\r\n            }\r\n        });\r\n        offlineStreamProcessors.push(streamProcessor);\r\n        streamProcessor.initialize(mediaInfo);\r\n\r\n        progressionById[bitrate.id] = null;\r\n    }\r\n\r\n    function onStreamCompleted() {\r\n        finishedOfflineStreamProcessors++;\r\n        if (finishedOfflineStreamProcessors === offlineStreamProcessors.length) {\r\n            finishedCb({sender: this, id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\r\n        }\r\n    }\r\n\r\n    function onStreamProgression(streamProcessor, downloadedSegments, availableSegments ) {\r\n        progressionById[streamProcessor.getRepresentationId()] = {\r\n            downloadedSegments,\r\n            availableSegments\r\n        };\r\n\r\n        let segments = 0;\r\n        let allSegments = 0;\r\n        let waitForAllProgress;\r\n        for (var property in progressionById) {\r\n            if (progressionById.hasOwnProperty(property)) {\r\n                if (progressionById[property] === null) {\r\n                    waitForAllProgress = true;\r\n                } else {\r\n                    segments += progressionById[property].downloadedSegments;\r\n                    allSegments += progressionById[property].availableSegments;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!waitForAllProgress && progressionCb) {\r\n            // all progression have been started, we can compute global progression\r\n            if (allSegments > 0) {\r\n                progressionCb(instance, segments, allSegments);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        if (e.currentRepresentation.segments && e.currentRepresentation.segments.length > 0) {\r\n            representationsToUpdate.push(e.currentRepresentation);\r\n        }\r\n\r\n        let sp;\r\n        // data are ready fr stream processor, let's start download\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++ ) {\r\n            if (offlineStreamProcessors[i].getRepresentationController().getType() === e.mediaType) {\r\n                sp = offlineStreamProcessors[i];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (sp) {\r\n            checkIfAllOfflineStreamProcessorsStarted();\r\n        }\r\n    }\r\n\r\n    function checkIfAllOfflineStreamProcessorsStarted() {\r\n        startedOfflineStreamProcessors++;\r\n        if (startedOfflineStreamProcessors === offlineStreamProcessors.length) {\r\n            startedCb({sender: this, id: manifestId, message: 'Downloading started for this stream !'});\r\n\r\n            if (representationsToUpdate.length > 0) {\r\n                updateManifest({sender: this, id: manifestId, representations: representationsToUpdate });\r\n            } else {\r\n                startOfflineStreamProcessors();\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function getStartTime() {\r\n        return streamInfo ? streamInfo.start : NaN;\r\n    }\r\n\r\n    function getDuration() {\r\n        return streamInfo ? streamInfo.duration : NaN;\r\n    }\r\n\r\n    /**\r\n     * Stop offline stream processors\r\n     */\r\n    function stopOfflineStreamProcessors() {\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\r\n            offlineStreamProcessors[i].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start offline stream processors\r\n     */\r\n    function startOfflineStreamProcessors() {\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\r\n            offlineStreamProcessors[i].start();\r\n        }\r\n    }\r\n\r\n    function deactivate() {\r\n        let ln = offlineStreamProcessors ? offlineStreamProcessors.length : 0;\r\n        for (let i = 0; i < ln; i++) {\r\n            offlineStreamProcessors[i].removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\r\n            offlineStreamProcessors[i].reset();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     */\r\n    function reset() {\r\n        stopOfflineStreamProcessors();\r\n        deactivate();\r\n        resetInitialSettings();\r\n\r\n        eventBus.off(events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getStreamId: getStreamId,\r\n        getMediaInfos: getMediaInfos,\r\n        initializeAllMediasInfoList: initializeAllMediasInfoList,\r\n        getStreamInfo: getStreamInfo,\r\n        stopOfflineStreamProcessors: stopOfflineStreamProcessors,\r\n        startOfflineStreamProcessors: startOfflineStreamProcessors,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nOfflineStream.__dashjs_factory_name = 'OfflineStream';\r\nexport default dashjs.FactoryMaker.getClassFactory(OfflineStream); /* jshint ignore:line */\r\n"]}