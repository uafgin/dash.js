{"version":3,"sources":["../../../../src/offline/OfflineDownload.js"],"names":["OfflineDownload","config","context","manifestLoader","mediaPlayerModel","abrController","playbackController","adapter","dashMetrics","timelineConverter","offlineStoreController","manifestId","id","eventBus","errHandler","events","errors","settings","debug","manifestUpdater","baseURLController","constants","dashConstants","urlUtils","instance","logger","_manifestURL","_offlineURL","_xmlManifest","_streams","_manifest","_isDownloadingStatus","_isComposed","_representationsToUpdate","_indexDBManifestParser","_progressionById","_progression","_status","setup","getLogger","initialize","undefined","getId","getOfflineUrl","getManifestUrl","getStatus","setInitialState","state","url","progress","originalUrl","status","downloadFromUrl","OfflineConstants","OFFLINE_SCHEME","OFFLINE_STATUS_CREATED","setupOfflineEvents","offlineManifest","createOfflineManifest","initDownload","load","on","MANIFEST_UPDATED","onManifestUpdated","ORIGINAL_MANIFEST_LOADED","onOriginalManifestLoaded","setupIndexedDBEvents","ERROR","onError","isDownloading","e","error","manifest","err","OFFLINE_STATUS_ERROR","code","OfflineErrors","OFFLINE_ERROR","message","data","onDownloadingStarted","OFFLINE_STATUS_STARTED","setDownloadingStatus","then","trigger","OFFLINE_RECORD_STARTED","OnStreamProgression","stream","downloaded","available","getStreamInfo","segments","allSegments","waitForAllProgress","property","hasOwnProperty","getManifestById","item","updateOfflineManifest","onDownloadingFinished","OFFLINE_STATUS_FINISHED","OFFLINE_RECORD_FINISHED","resetDownload","onManifestUpdateNeeded","representations","length","parse","parsedManifest","i","ln","startOfflineStreamProcessors","catch","composeStreams","updatePeriods","streamsInfo","getStreamsInfo","streamInfo","create","callbacks","started","progression","finished","updateManifestNeeded","push","info","getMediaInfos","forEach","createFragmentStore","off","originalManifest","type","DYNAMIC","Period_asArray","STREAMS_COMPOSED","initializeAllMediasInfoList","selectedRepresentations","getSelectedRepresentations","mediaInfos","rep","VIDEO","AUDIO","TEXT","FRAGMENTED_TEXT","mediaInfo","bitrateList","bitrate","startDownload","saveSelectedRepresentations","generateOfflineManifest","allMediaInfos","originalURL","Promise","reject","stopDownload","stopOfflineStreamProcessors","OFFLINE_STATUS_STOPPED","OFFLINE_RECORD_STOPPED","sender","deleteDownload","resumeDownload","parser","selected","getDownloadProgression","Math","round","reset","resetIndexedDBEvents","INDEXEDDB_QUOTA_EXCEED_ERROR","INDEXEDDB_INVALID_STATE_ERROR","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineDownload.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport OfflineConstants from './constants/OfflineConstants';\r\nimport OfflineStream from './OfflineStream';\r\nimport OfflineIndexDBManifestParser from './utils/OfflineIndexDBManifestParser';\r\nimport OfflineErrors from './errors/OfflineErrors';\r\nimport DashParser from '../dash/parser/DashParser';\r\n\r\nfunction OfflineDownload(config) {\r\n    config = config || {};\r\n\r\n    const context = this.context;\r\n    const manifestLoader = config.manifestLoader;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const adapter = config.adapter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const timelineConverter = config.timelineConverter;\r\n    const offlineStoreController = config.offlineStoreController;\r\n    const manifestId = config.id;\r\n    const eventBus = config.eventBus;\r\n    const errHandler = config.errHandler;\r\n    const events = config.events;\r\n    const errors = config.errors;\r\n    const settings = config.settings;\r\n    const debug = config.debug;\r\n    const manifestUpdater = config.manifestUpdater;\r\n    const baseURLController = config.baseURLController;\r\n    const constants = config.constants;\r\n    const dashConstants = config.dashConstants;\r\n    const urlUtils = config.urlUtils;\r\n\r\n    let instance,\r\n        logger,\r\n        _manifestURL,\r\n        _offlineURL,\r\n        _xmlManifest,\r\n        _streams,\r\n        _manifest,\r\n        _isDownloadingStatus,\r\n        _isComposed,\r\n        _representationsToUpdate,\r\n        _indexDBManifestParser,\r\n        _progressionById,\r\n        _progression,\r\n        _status;\r\n\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        manifestUpdater.initialize();\r\n        _streams = [];\r\n        _isDownloadingStatus = false;\r\n        _isComposed = false;\r\n        _progressionById = {};\r\n        _progression = 0;\r\n        _status = undefined;\r\n    }\r\n\r\n    function getId() {\r\n        return manifestId;\r\n    }\r\n\r\n    function getOfflineUrl () {\r\n        return _offlineURL;\r\n    }\r\n\r\n    function getManifestUrl () {\r\n        return _manifestURL;\r\n    }\r\n\r\n    function getStatus () {\r\n        return _status;\r\n    }\r\n\r\n    function setInitialState(state) {\r\n        _offlineURL = state.url;\r\n        _progression = state.progress;\r\n        _manifestURL = state.originalUrl;\r\n        _status = state.status;\r\n    }\r\n\r\n    /**\r\n     * Download a stream, from url of manifest\r\n     * @param {string} url\r\n     * @instance\r\n     */\r\n    function downloadFromUrl(url) {\r\n        _manifestURL = url;\r\n        _offlineURL = `${OfflineConstants.OFFLINE_SCHEME}://${manifestId}`;\r\n        _status = OfflineConstants.OFFLINE_STATUS_CREATED;\r\n        setupOfflineEvents();\r\n        let offlineManifest = {\r\n            'fragmentStore': manifestId,\r\n            'status': _status,\r\n            'manifestId': manifestId,\r\n            'url': _offlineURL,\r\n            'originalURL': url\r\n        };\r\n        return createOfflineManifest(offlineManifest);\r\n    }\r\n\r\n    function initDownload() {\r\n        manifestLoader.load(_manifestURL);\r\n        _isDownloadingStatus = true;\r\n    }\r\n\r\n    function setupOfflineEvents() {\r\n        eventBus.on(events.MANIFEST_UPDATED, onManifestUpdated, instance);\r\n        eventBus.on(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\r\n        setupIndexedDBEvents();\r\n    }\r\n\r\n    function setupIndexedDBEvents() {\r\n        eventBus.on(events.ERROR, onError, instance);\r\n    }\r\n\r\n    function isDownloading() {\r\n        return _isDownloadingStatus;\r\n    }\r\n\r\n    function onManifestUpdated(e) {\r\n        if (_isComposed) {\r\n            return;\r\n        }\r\n        if (!e.error) {\r\n            try {\r\n                _manifest = e.manifest;\r\n            } catch (err) {\r\n                _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n                errHandler.error({\r\n                    code: OfflineErrors.OFFLINE_ERROR,\r\n                    message: err.message,\r\n                    data: {\r\n                        id: manifestId,\r\n                        status: _status\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    function onDownloadingStarted(e) {\r\n        if (e.id !== manifestId) {\r\n            return;\r\n        }\r\n        if (!e.error && manifestId !== null) {\r\n            _status = OfflineConstants.OFFLINE_STATUS_STARTED;\r\n            offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () {\r\n                eventBus.trigger(events.OFFLINE_RECORD_STARTED, { id: manifestId, message: 'Downloading started for this stream !' });\r\n            });\r\n        } else {\r\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n            errHandler.error({\r\n                code: OfflineErrors.OFFLINE_ERROR,\r\n                message: 'Cannot start download ',\r\n                data: {\r\n                    id: manifestId,\r\n                    status: _status,\r\n                    error: e.error\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function OnStreamProgression(stream, downloaded, available) {\r\n\r\n        _progressionById[stream.getStreamInfo().id] = {\r\n            downloaded,\r\n            available\r\n        };\r\n\r\n        let segments = 0;\r\n        let allSegments = 0;\r\n        let waitForAllProgress;\r\n        for (var property in _progressionById) {\r\n            if (_progressionById.hasOwnProperty(property)) {\r\n                if (_progressionById[property] === null) {\r\n                    waitForAllProgress = true;\r\n                } else {\r\n                    segments += _progressionById[property].downloaded;\r\n                    allSegments += _progressionById[property].available;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!waitForAllProgress) {\r\n            // all progression have been started, we can compute global progression\r\n            _progression = segments / allSegments;\r\n\r\n            // store progression\r\n            offlineStoreController.getManifestById(manifestId)\r\n                .then((item) => {\r\n                    item.progress = _progression;\r\n                    return updateOfflineManifest(item);\r\n                });\r\n        }\r\n    }\r\n\r\n    function onDownloadingFinished(e) {\r\n        if (e.id !== manifestId) {\r\n            return;\r\n        }\r\n        if (!e.error && manifestId !== null) {\r\n            _status = OfflineConstants.OFFLINE_STATUS_FINISHED;\r\n            offlineStoreController.setDownloadingStatus(manifestId, _status)\r\n            .then(function () {\r\n                eventBus.trigger(events.OFFLINE_RECORD_FINISHED, { id: manifestId, message: 'Downloading has been successfully completed for this stream !' });\r\n                resetDownload();\r\n            });\r\n        } else {\r\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n            errHandler.error({\r\n                code: OfflineErrors.OFFLINE_ERROR,\r\n                message: 'Error finishing download ',\r\n                data: {\r\n                    id: manifestId,\r\n                    status: _status,\r\n                    error: e.error\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function onManifestUpdateNeeded(e) {\r\n        if (e.id !== manifestId) {\r\n            return;\r\n        }\r\n\r\n        _representationsToUpdate = e.representations;\r\n\r\n        if (_representationsToUpdate.length > 0) {\r\n            _indexDBManifestParser.parse(_xmlManifest, _representationsToUpdate).then(function (parsedManifest) {\r\n                if (parsedManifest !== null && manifestId !== null) {\r\n                    offlineStoreController.getManifestById(manifestId)\r\n                    .then((item) => {\r\n                        item.manifest = parsedManifest;\r\n                        return updateOfflineManifest(item);\r\n                    })\r\n                    .then( function () {\r\n                        for (let i = 0, ln = _streams.length; i < ln; i++) {\r\n                            _streams[i].startOfflineStreamProcessors();\r\n                        }\r\n                    });\r\n                } else {\r\n                    throw 'falling parsing offline manifest';\r\n                }\r\n            }).catch(function (err) {\r\n                throw err;\r\n            });\r\n        }\r\n    }\r\n\r\n    function composeStreams() {\r\n        try {\r\n            adapter.updatePeriods(_manifest);\r\n            baseURLController.initialize(_manifest);\r\n            const streamsInfo = adapter.getStreamsInfo();\r\n            if (streamsInfo.length === 0) {\r\n                _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n                errHandler.error({\r\n                    code: OfflineErrors.OFFLINE_ERROR,\r\n                    message: 'Cannot download - no streams',\r\n                    data: {\r\n                        id: manifestId,\r\n                        status: _status\r\n                    }\r\n                });\r\n            }\r\n            for (let i = 0, ln = streamsInfo.length; i < ln; i++) {\r\n                const streamInfo = streamsInfo[i];\r\n                let stream = OfflineStream(context).create({\r\n                    id: manifestId,\r\n                    callbacks: {\r\n                        started: onDownloadingStarted,\r\n                        progression: OnStreamProgression,\r\n                        finished: onDownloadingFinished,\r\n                        updateManifestNeeded: onManifestUpdateNeeded\r\n                    },\r\n                    constants: constants,\r\n                    dashConstants: dashConstants,\r\n                    eventBus: eventBus,\r\n                    events: events,\r\n                    errors: errors,\r\n                    settings: settings,\r\n                    debug: debug,\r\n                    errHandler: errHandler,\r\n                    mediaPlayerModel: mediaPlayerModel,\r\n                    abrController: abrController,\r\n                    playbackController: playbackController,\r\n                    dashMetrics: dashMetrics,\r\n                    baseURLController: baseURLController,\r\n                    timelineConverter: timelineConverter,\r\n                    adapter: adapter,\r\n                    offlineStoreController: offlineStoreController\r\n                });\r\n                _streams.push(stream);\r\n\r\n                // initialise stream and get downloadable representations\r\n                stream.initialize(streamInfo);\r\n                _progressionById[streamInfo.id] = null;\r\n            }\r\n            _isComposed = true;\r\n        } catch (e) {\r\n            logger.info(e);\r\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n            errHandler.error({\r\n                code: OfflineErrors.OFFLINE_ERROR,\r\n                message: e.message,\r\n                data: {\r\n                    id: manifestId,\r\n                    status: _status,\r\n                    error: e.error\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    function getMediaInfos() {\r\n        _streams.forEach(stream => {\r\n            stream.getMediaInfos();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Init databsse to store fragments\r\n     * @param {number} manifestId\r\n     * @instance\r\n     */\r\n    function createFragmentStore(manifestId) {\r\n        return offlineStoreController.createFragmentStore(manifestId);\r\n    }\r\n\r\n    /**\r\n     * Store in database the string representation of offline manifest (with only downloaded representations)\r\n     * @param {object} offlineManifest\r\n     * @instance\r\n     */\r\n    function createOfflineManifest(offlineManifest) {\r\n        return offlineStoreController.createOfflineManifest(offlineManifest);\r\n    }\r\n\r\n    /**\r\n     * Store in database the string representation of offline manifest (with only downloaded representations)\r\n     * @param {object} offlineManifest\r\n     * @instance\r\n     */\r\n    function updateOfflineManifest(offlineManifest) {\r\n        return offlineStoreController.updateOfflineManifest(offlineManifest);\r\n    }\r\n\r\n    /**\r\n     * Triggered when manifest is loaded from internet.\r\n     * @param {Object[]} e\r\n     */\r\n    function onOriginalManifestLoaded(e) {\r\n        // unregister form event\r\n        eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\r\n\r\n        _xmlManifest = e.originalManifest;\r\n\r\n        if (_manifest.type === dashConstants.DYNAMIC) {\r\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n            errHandler.error({\r\n                code: OfflineErrors.OFFLINE_ERROR,\r\n                message: 'Cannot handle DYNAMIC manifest',\r\n                data: {\r\n                    id: manifestId,\r\n                    status: _status\r\n                }\r\n            });\r\n            logger.error('Cannot handle DYNAMIC manifest');\r\n\r\n            return;\r\n        }\r\n\r\n        if (_manifest.Period_asArray.length > 1) {\r\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n            errHandler.error({\r\n                code: OfflineErrors.OFFLINE_ERROR,\r\n                message: 'MultiPeriod manifest are not yet supported',\r\n                data: {\r\n                    id: manifestId,\r\n                    status: _status\r\n                }\r\n            });\r\n            logger.error('MultiPeriod manifest are not yet supported');\r\n\r\n            return;\r\n        }\r\n\r\n        // save original manifest (for resume)\r\n\r\n        // initialise offline streams\r\n        composeStreams(_manifest);\r\n\r\n        // get MediaInfos\r\n        getMediaInfos();\r\n\r\n        eventBus.trigger(events.STREAMS_COMPOSED);\r\n    }\r\n\r\n    function initializeAllMediasInfoList(selectedRepresentations) {\r\n        for (let i = 0; i < _streams.length; i++) {\r\n            _streams[i].initializeAllMediasInfoList(selectedRepresentations);\r\n        }\r\n    }\r\n\r\n    function getSelectedRepresentations(mediaInfos) {\r\n        let rep = {};\r\n        rep[constants.VIDEO] = [];\r\n        rep[constants.AUDIO] = [];\r\n        rep[constants.TEXT] = [];\r\n        rep[constants.FRAGMENTED_TEXT] = [];\r\n\r\n        // selectedRepresentations.video.forEach(item => {\r\n        //     ret[constants.VIDEO].push(item.id);\r\n        // });\r\n        // selectedRepresentations.audio.forEach(item => {\r\n        //     ret[constants.AUDIO].push(item.id);\r\n        // });\r\n        // selectedRepresentations.text.forEach(item => {\r\n        //     ret[item.type].push(item.id);\r\n        // });\r\n\r\n        mediaInfos.forEach(mediaInfo => {\r\n            mediaInfo.bitrateList.forEach(bitrate => {\r\n                rep[mediaInfo.type].push(bitrate.id);\r\n            });\r\n        });\r\n        return rep;\r\n    }\r\n\r\n    function startDownload(mediaInfos) {\r\n        try {\r\n            let rep = getSelectedRepresentations(mediaInfos);\r\n\r\n            offlineStoreController.saveSelectedRepresentations(manifestId, rep)\r\n            .then(() => {\r\n                return createFragmentStore(manifestId);\r\n            })\r\n            .then(() => {\r\n                return generateOfflineManifest(rep);\r\n            })\r\n            .then(function () {\r\n                initializeAllMediasInfoList(rep);\r\n            });\r\n        } catch (err) {\r\n            _status = OfflineConstants.OFFLINE_STATUS_ERROR;\r\n            errHandler.error({\r\n                code: OfflineErrors.OFFLINE_ERROR,\r\n                message: err.message,\r\n                data: {\r\n                    id: manifestId,\r\n                    status: _status\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the parser used to convert original manifest in offline manifest\r\n     * Creates a JSON object that will be stored in database\r\n     * @param {Object[]} selectedRepresentations\r\n     * @instance\r\n     */\r\n    function generateOfflineManifest(selectedRepresentations) {\r\n        _indexDBManifestParser = OfflineIndexDBManifestParser(context).create({\r\n            manifestId: manifestId,\r\n            allMediaInfos: selectedRepresentations,\r\n            debug: debug,\r\n            dashConstants: dashConstants,\r\n            constants: constants,\r\n            urlUtils: urlUtils\r\n        });\r\n\r\n        return _indexDBManifestParser.parse(_xmlManifest).then(function (parsedManifest) {\r\n            if (parsedManifest !== null) {\r\n                return offlineStoreController.getManifestById(manifestId)\r\n                .then((item) => {\r\n                    item.originalURL = _manifest.url;\r\n                    item.originalManifest = _xmlManifest;\r\n                    item.manifest = parsedManifest;\r\n                    return updateOfflineManifest(item);\r\n                });\r\n            } else {\r\n                return Promise.reject('falling parsing offline manifest');\r\n            }\r\n        }).catch(function (err) {\r\n            return Promise.reject(err);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops downloading of fragments\r\n     * @instance\r\n     */\r\n    function stopDownload() {\r\n        if (manifestId !== null && isDownloading()) {\r\n            for (let i = 0, ln = _streams.length; i < ln; i++) {\r\n                _streams[i].stopOfflineStreamProcessors();\r\n            }\r\n\r\n            // remove streams\r\n            _streams = [];\r\n\r\n            _isComposed = false;\r\n\r\n            _status = OfflineConstants.OFFLINE_STATUS_STOPPED;\r\n            // update status\r\n            offlineStoreController.setDownloadingStatus(manifestId, _status).then(function () {\r\n                eventBus.trigger(events.OFFLINE_RECORD_STOPPED, {\r\n                    sender: this,\r\n                    id: manifestId,\r\n                    status: _status,\r\n                    message: 'Downloading has been stopped for this stream !'\r\n                });\r\n                _isDownloadingStatus = false;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete an offline manifest (and all of its data)\r\n     * @instance\r\n     */\r\n    function deleteDownload() {\r\n        stopDownload();\r\n    }\r\n\r\n    /**\r\n     * Resume download of a stream\r\n     * @instance\r\n     */\r\n    function resumeDownload() {\r\n        if (isDownloading()) {\r\n            return;\r\n        }\r\n\r\n        _isDownloadingStatus = true;\r\n\r\n        let selectedRepresentations;\r\n\r\n        offlineStoreController.getManifestById(manifestId)\r\n        .then((item) => {\r\n            let parser = DashParser(context).create({debug: debug});\r\n            _manifest = parser.parse(item.originalManifest);\r\n\r\n            composeStreams(_manifest);\r\n\r\n            selectedRepresentations = item.selected;\r\n\r\n            eventBus.trigger(events.STREAMS_COMPOSED);\r\n\r\n            return createFragmentStore(manifestId);\r\n        }). then(() => {\r\n            initializeAllMediasInfoList(selectedRepresentations);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compute the progression of download\r\n     * @instance\r\n     */\r\n    function getDownloadProgression() {\r\n        return Math.round(_progression * 100);\r\n    }\r\n\r\n    /**\r\n     * Reset events listeners\r\n     * @instance\r\n     */\r\n    function resetDownload() {\r\n        for (let i = 0, ln = _streams.length; i < ln; i++) {\r\n            _streams[i].reset();\r\n        }\r\n        _indexDBManifestParser = null;\r\n        _isDownloadingStatus = false;\r\n        _streams = [];\r\n        eventBus.off(events.MANIFEST_UPDATED, onManifestUpdated, instance);\r\n        eventBus.off(events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\r\n        resetIndexedDBEvents();\r\n    }\r\n\r\n    function onError(e) {\r\n        if ( e.error.code === OfflineErrors.INDEXEDDB_QUOTA_EXCEED_ERROR ||\r\n             e.error.code === OfflineErrors.INDEXEDDB_INVALID_STATE_ERROR ) {\r\n            stopDownload();\r\n        }\r\n    }\r\n\r\n    function resetIndexedDBEvents() {\r\n        eventBus.on(events.ERROR, onError, instance);\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     * @instance\r\n     */\r\n    function reset() {\r\n        if (isDownloading()) {\r\n            resetDownload();\r\n        }\r\n        baseURLController.reset();\r\n        manifestUpdater.reset();\r\n    }\r\n\r\n    instance = {\r\n        reset: reset,\r\n        getId: getId,\r\n        getOfflineUrl: getOfflineUrl,\r\n        getManifestUrl: getManifestUrl,\r\n        getStatus: getStatus,\r\n        setInitialState: setInitialState,\r\n        initDownload: initDownload,\r\n        downloadFromUrl: downloadFromUrl,\r\n        startDownload: startDownload,\r\n        stopDownload: stopDownload,\r\n        resumeDownload: resumeDownload,\r\n        deleteDownload: deleteDownload,\r\n        getDownloadProgression: getDownloadProgression,\r\n        isDownloading: isDownloading,\r\n        resetDownload: resetDownload\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nOfflineDownload.__dashjs_factory_name = 'OfflineDownload';\r\nexport default dashjs.FactoryMaker.getClassFactory(OfflineDownload); /* jshint ignore:line */\r\n"]}