{"version":3,"sources":["../../../../../src/offline/utils/OfflineIndexDBManifestParser.js"],"names":["Entities","require","XmlEntities","OFFLINE_BASE_URL","OfflineIndexDBManifestParser","config","manifestId","allMediaInfos","urlUtils","debug","dashConstants","constants","instance","DOM","logger","setup","getLogger","parse","XMLDoc","representation","Promise","resolve","reject","DOMParser","parseFromString","mpd","getElementsByTagName","MPD","i","length","editBaseURLAttribute","browsePeriods","manifestEncoded","encodeManifest","info","XMLSerializer","serializeToString","encode","currentMPD","basesURL","fragmentId","representationId","url","BASE_URL","element","createElement","innerHTML","appendChild","parent","parentNode","nodeName","REPRESENTATION","adaptationsSet","ADAPTATION_SET","isHTTPS","isHTTPURL","getFragmentId","getBestRepresentationId","periods","PERIOD","j","browseAdaptationsSet","currentPeriod","representationsToUpdate","currentAdaptationSet","currentAdaptationType","representations","findAdaptationType","findRepresentations","findAndKeepOnlySelectedRepresentations","deleteSegmentBase","removeChild","rep","segmentList","getSegmentList","editSegmentListAttributes","segmentTemplate","getSegmentTemplate","editSegmentTemplateAttributes","selectedRep","id","addSegmentTemplateAttributes","getIsMuxed","MUXED","getIsAudio","AUDIO","getIsVideo","VIDEO","getIsFragmentedText","FRAGMENTED_TEXT","getIsImage","IMAGE","TEXT","adaptation","getIsTypeOf","type","Error","isFragmentedTextCodecFound","testMimeType","mimeTypeRegEx","RegExp","mimeType","findMimeType","test","isFragmentedTextCodecFoundInTag","tag","codecs","getAttribute","CODECS","search","STPP","WVTT","MIME_TYPE","SEGMENT_TEMPLATE","SEGMENT_LIST","elements","SEGMENT_BASE","segmentBase","addSegmentTimelineElements","S","segments","segmentTimelineElement","SEGMENT_TIMELINE","changedDuration","getDurationChangeArray","repeatValue","setAttribute","duration","array","push","segmentsTemplates","media","MEDIA","substring","indexOf","START_NUMBER","INITIALIZATION_MINUS","segmentLists","repId","ID","initialisation","INITIALIZATION","sourceURL","SOURCE_URL","segmentURLs","SEGMENT_URL","segmentUrl","adaptationSet","segmentTemplateElement","adaptationType","bestRepresentation","console","log","idxFragId","lastIndexOf","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"OfflineIndexDBManifestParser.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nconst Entities = require('html-entities').XmlEntities;\r\nconst OFFLINE_BASE_URL = 'offline_indexeddb://';\r\n\r\nfunction OfflineIndexDBManifestParser(config) {\r\n\r\n    const manifestId = config.manifestId;\r\n    const allMediaInfos = config.allMediaInfos;\r\n    const urlUtils = config.urlUtils;\r\n    const debug = config.debug;\r\n    const dashConstants = config.dashConstants;\r\n    const constants = config.constants;\r\n\r\n    let instance,\r\n        DOM,\r\n        logger;\r\n\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n    }\r\n\r\n    /**\r\n     * Parse XML manifest\r\n     * @param {string} XMLDoc - xml manifest\r\n     * @param {object} representation\r\n     * @returns {Promise} a promise that will be resolved or rejected at the end of encoding process\r\n     * @instance\r\n    */\r\n    function parse(XMLDoc, representation) {\r\n        return new Promise(function (resolve, reject) {\r\n\r\n            DOM = new DOMParser().parseFromString(XMLDoc, 'application/xml');\r\n            let mpd = DOM.getElementsByTagName(dashConstants.MPD) ? DOM.getElementsByTagName(dashConstants.MPD) : null;\r\n\r\n            for (let i = 0; i < mpd.length; i++) {\r\n                if (mpd[i] !== null) {\r\n                    editBaseURLAttribute(mpd[i]);\r\n                    browsePeriods(mpd[i], representation);\r\n                }\r\n            }\r\n\r\n            let manifestEncoded = encodeManifest(DOM);\r\n            if (manifestEncoded !== '') {\r\n                resolve(manifestEncoded);\r\n            } else {\r\n                reject('Encoded error');\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * URL encode parsed manifest\r\n     * @param {string} DOM\r\n     * @returns {string} Url encoded XML\r\n     * @instance\r\n    */\r\n    function encodeManifest(DOM) {\r\n        logger.info('encodedManifest ' + new XMLSerializer().serializeToString(DOM));\r\n        return new Entities().encode(new XMLSerializer().serializeToString(DOM));\r\n    }\r\n\r\n    /**\r\n     * Update baseURL to point to local stored data P\r\n     * @param {XML} currentMPD\r\n     * @instance\r\n    */\r\n    function editBaseURLAttribute(currentMPD) {\r\n        let basesURL,\r\n            fragmentId,\r\n            representationId;\r\n\r\n        let url = `${OFFLINE_BASE_URL}${manifestId}/`;\r\n\r\n        basesURL = currentMPD.getElementsByTagName(dashConstants.BASE_URL);\r\n\r\n        if (basesURL.length === 0) {\r\n            // add baseURL\r\n            let element = DOM.createElement(dashConstants.BASE_URL);\r\n            element.innerHTML = url;\r\n            currentMPD.appendChild(element);\r\n        }\r\n        basesURL = currentMPD.getElementsByTagName(dashConstants.BASE_URL);\r\n        for (let i = 0; i < basesURL.length; i++) {\r\n            let parent = basesURL[i].parentNode;\r\n\r\n            if (parent.nodeName === dashConstants.MPD) {\r\n                basesURL[i].innerHTML = url;\r\n            } else if (parent.nodeName === dashConstants.REPRESENTATION) {\r\n                let adaptationsSet = parent.parentNode;\r\n                if (adaptationsSet.nodeName == dashConstants.ADAPTATION_SET) {\r\n\r\n                    if (urlUtils.isHTTPS(basesURL[i].innerHTML) || urlUtils.isHTTPURL(basesURL[i].innerHTML)) {\r\n                        fragmentId = getFragmentId(basesURL[i].innerHTML);\r\n                        representationId = getBestRepresentationId(adaptationsSet);\r\n                        basesURL[i].innerHTML = url + representationId + '_' + fragmentId;\r\n                    } else if (basesURL[i].innerHTML === './') {\r\n                        basesURL[i].innerHTML = url;\r\n                    } else {\r\n                        fragmentId = getFragmentId(basesURL[i].innerHTML);\r\n                        representationId = getBestRepresentationId(adaptationsSet);\r\n                        basesURL[i].innerHTML = representationId + '_' + fragmentId;\r\n                    }\r\n                }\r\n            } else {\r\n                basesURL[i].innerHTML = url;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Browse periods\r\n     * @param {XML} currentMPD\r\n     * @param {Object} representation\r\n     * @instance\r\n    */\r\n    function browsePeriods(currentMPD, representation) {\r\n        let periods = currentMPD.getElementsByTagName(dashConstants.PERIOD);\r\n        for (let j = 0; j < periods.length; j++) {\r\n            browseAdaptationsSet(periods[j], representation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Browse adapatation set to update data (delete those taht are not choosen by user ...)\r\n     * @param {XML} currentPeriod\r\n     * @param {Array} representationsToUpdate\r\n     * @instance\r\n    */\r\n    function browseAdaptationsSet(currentPeriod, representationsToUpdate) {\r\n        let adaptationsSet,\r\n            currentAdaptationSet,\r\n            currentAdaptationType,\r\n            representations;\r\n\r\n        adaptationsSet = currentPeriod.getElementsByTagName(dashConstants.ADAPTATION_SET);\r\n\r\n        for (let i = adaptationsSet.length - 1; i >= 0; i--) {\r\n            currentAdaptationSet = adaptationsSet[i];\r\n            if (currentAdaptationSet) {\r\n                currentAdaptationType = findAdaptationType(currentAdaptationSet);\r\n                representations = findRepresentations(currentAdaptationSet);\r\n\r\n                findAndKeepOnlySelectedRepresentations(currentAdaptationSet, representations, currentAdaptationType);\r\n\r\n                representations = findRepresentations(currentAdaptationSet);\r\n\r\n                deleteSegmentBase(currentAdaptationSet);\r\n\r\n                if (representations.length === 0) {\r\n                    currentPeriod.removeChild(currentAdaptationSet);\r\n                } else {\r\n                    //detect Segment list use case\r\n                    for (let i = 0; i < representations.length; i++) {\r\n                        let rep = representations[i];\r\n                        let segmentList = getSegmentList(rep);\r\n                        if (segmentList.length >= 1) {\r\n                            editSegmentListAttributes(segmentList, rep);\r\n                        }\r\n                    }\r\n\r\n                    let segmentTemplate = getSegmentTemplate(currentAdaptationSet);\r\n                    // segmentTemplate is defined, update attributes in order to be correctly played offline\r\n                    if (segmentTemplate.length >= 1) {\r\n                        editSegmentTemplateAttributes(segmentTemplate);\r\n                    }\r\n\r\n                    // detect SegmentBase use case => transfrom manifest to SegmentList in SegmentTemplate\r\n                    if (representationsToUpdate && representationsToUpdate.length > 0 ) {\r\n                        let selectedRep;\r\n                        for (let i = 0; i < representations.length; i++) {\r\n                            let rep = representations[i];\r\n                            for (let j = 0; representationsToUpdate && j < representationsToUpdate.length; j++) {\r\n                                if (representationsToUpdate[j].id === rep.id) {\r\n                                    selectedRep = representationsToUpdate[j];\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        addSegmentTemplateAttributes(currentAdaptationSet, selectedRep);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns type of adapation set\r\n     * @param {XML} currentAdaptationSet\r\n     * @returns {string|null} type\r\n     * @instance\r\n    */\r\n    function findAdaptationType(currentAdaptationSet) {\r\n        if (getIsMuxed(currentAdaptationSet)) {\r\n            return constants.MUXED;\r\n        } else if (getIsAudio(currentAdaptationSet)) {\r\n            return constants.AUDIO;\r\n        } else if (getIsVideo(currentAdaptationSet)) {\r\n            return constants.VIDEO;\r\n        } else if (getIsFragmentedText(currentAdaptationSet)) {\r\n            return constants.FRAGMENTED_TEXT;\r\n        } else if (getIsImage(currentAdaptationSet)) {\r\n            return constants.IMAGE;\r\n        }\r\n\r\n        return constants.TEXT;\r\n    }\r\n\r\n    function getIsAudio(adaptation) {\r\n        return getIsTypeOf(adaptation, constants.AUDIO);\r\n    }\r\n\r\n    function getIsVideo(adaptation) {\r\n        return getIsTypeOf(adaptation, constants.VIDEO);\r\n    }\r\n\r\n    function getIsFragmentedText(adaptation) {\r\n        return getIsTypeOf(adaptation, constants.FRAGMENTED_TEXT);\r\n    }\r\n\r\n    function getIsMuxed(adaptation) {\r\n        return getIsTypeOf(adaptation, constants.MUXED);\r\n    }\r\n\r\n    function getIsImage(adaptation) {\r\n        return getIsTypeOf(adaptation, constants.IMAGE);\r\n    }\r\n\r\n    // based upon DashManifestModel, but using DomParser\r\n    function getIsTypeOf(adaptation, type) {\r\n\r\n        if (!adaptation) {\r\n            throw new Error('adaptation is not defined');\r\n        }\r\n\r\n        if (!type) {\r\n            throw new Error('type is not defined');\r\n        }\r\n\r\n        // 1. check codecs for fragmented text\r\n        if (isFragmentedTextCodecFound(adaptation)) {\r\n            // fragmented text codec has been found for adaptation, let's check if tested type is fragmented text\r\n            return type === constants.FRAGMENTED_TEXT;\r\n        }\r\n\r\n        // 2. test mime type\r\n        return testMimeType(adaptation, type);\r\n    }\r\n\r\n    function testMimeType(adaptation, type) {\r\n        let mimeTypeRegEx = (type !== constants.TEXT) ? new RegExp(type) : new RegExp('(vtt|ttml)');\r\n\r\n        let mimeType = findMimeType(adaptation);\r\n        if (mimeType) {\r\n            return mimeTypeRegEx.test(mimeType);\r\n        }\r\n\r\n        // no mime type in adaptation, search in representation\r\n        let representations = findRepresentations(adaptation);\r\n        if (representations) {\r\n            for (let i = 0; i < representations.length; i++) {\r\n                let representation = representations[i];\r\n                mimeType = findMimeType(representation);\r\n                if (mimeType) {\r\n                    return mimeTypeRegEx.test(mimeType);\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Search for fragmented text codec in adaptation (STPP or WVTT)\r\n     * @param {Object} adaptation\r\n     */\r\n    function isFragmentedTextCodecFound (adaptation) {\r\n        let isFragmentedTextCodecFoundInTag = function (tag) {\r\n            let codecs = tag.getAttribute(dashConstants.CODECS);\r\n            if (codecs) {\r\n                if (codecs.search(constants.STPP) === 0 ||\r\n                    codecs.search(constants.WVTT) === 0 ) {\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        if (isFragmentedTextCodecFoundInTag(adaptation)) {\r\n            return true;\r\n        }\r\n\r\n        // check in representations\r\n        let representations = findRepresentations(adaptation);\r\n        if (representations && representations.length > 0) {\r\n\r\n            if (isFragmentedTextCodecFoundInTag(representations[0])) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Returns mime-type of xml tag\r\n     * @param {Object} tag\r\n     * @returns {string|null} mimeType\r\n     * @instance\r\n    */\r\n    function findMimeType(tag) {\r\n        return tag.getAttribute(dashConstants.MIME_TYPE);\r\n    }\r\n\r\n    /**\r\n     * Returns representations of adaptation set\r\n     * @param {XML} adaptation\r\n     * @returns {XML} representations\r\n     * @instance\r\n    */\r\n    function findRepresentations(adaptation) {\r\n        return adaptation.getElementsByTagName(dashConstants.REPRESENTATION);\r\n    }\r\n\r\n    /**\r\n     * Return segment template list of adaptations set\r\n     * @param {XML} currentAdaptationSet\r\n     * @returns {XML} representations\r\n     * @instance\r\n    */\r\n    function getSegmentTemplate(currentAdaptationSet) {\r\n        return currentAdaptationSet.getElementsByTagName(dashConstants.SEGMENT_TEMPLATE);\r\n    }\r\n\r\n    /**\r\n     * Return segment list tags of adaptations set\r\n     * @param {XML} tag\r\n     * @returns {XML} representations\r\n     * @instance\r\n    */\r\n    function getSegmentList(tag) {\r\n        return tag.getElementsByTagName(dashConstants.SEGMENT_LIST);\r\n    }\r\n\r\n    function deleteSegmentBase(tag) {\r\n        let elements = tag.getElementsByTagName(dashConstants.SEGMENT_BASE);\r\n        for (let i = 0; i < elements.length; i++) {\r\n            let segmentBase = elements[i];\r\n            segmentBase.parentNode.removeChild(segmentBase);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {XML} segmentTemplate\r\n     * @param {object} rep\r\n     * @instance\r\n    */\r\n    function addSegmentTimelineElements(segmentTemplate, rep) {\r\n        let S = DOM.createElement('S');\r\n        if (rep && rep.segments) {\r\n            let segmentTimelineElement = DOM.createElement(dashConstants.SEGMENT_TIMELINE);\r\n            let changedDuration = getDurationChangeArray(rep);\r\n            for (let i = 0; i < changedDuration.length; i++) {\r\n                let repeatValue = i + 1 < changedDuration.length ? (changedDuration[i + 1] - changedDuration[i]) - 1 : 0;\r\n                if (repeatValue > 1) {\r\n                    S.setAttribute('r', repeatValue);\r\n                }\r\n                S.setAttribute('d', rep.segments[changedDuration[i]].duration);\r\n                segmentTimelineElement.appendChild(S);\r\n                S = DOM.createElement('S');\r\n            }\r\n            segmentTemplate.appendChild(segmentTimelineElement);\r\n        }\r\n    }\r\n\r\n    function getDurationChangeArray(rep) {\r\n        let array = [];\r\n        array.push(0);\r\n        for (let i = 1; i < rep.segments.length; i++) {\r\n            if (rep.segments[i - 1].duration !== rep.segments[i].duration) {\r\n                array.push(i);\r\n            }\r\n        }\r\n        return array;\r\n    }\r\n\r\n    /**\r\n     * Update attributes of segment templates to match offline urls\r\n     * @param {Array} segmentsTemplates\r\n     * @instance\r\n    */\r\n    function editSegmentTemplateAttributes(segmentsTemplates) {\r\n        for (let i = 0; i < segmentsTemplates.length; i++) {\r\n            let media = segmentsTemplates[i].getAttribute(dashConstants.MEDIA);\r\n            media = '$RepresentationID$_$Number$' + media.substring(media.indexOf('.'), media.length); //id + extension\r\n            segmentsTemplates[i].setAttribute(dashConstants.START_NUMBER, '0');\r\n            segmentsTemplates[i].setAttribute(dashConstants.MEDIA, media);\r\n            segmentsTemplates[i].setAttribute(dashConstants.INITIALIZATION_MINUS,'$RepresentationID$_init');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update attributes of segment list to match offline urls\r\n     * @param {Array} segmentLists\r\n     * @param {Object} representation\r\n     * @instance\r\n    */\r\n    function editSegmentListAttributes(segmentLists, representation) {\r\n        let repId = representation.getAttribute(dashConstants.ID);\r\n        for (let i = 0; i < segmentLists.length; i++) {\r\n\r\n            let segmentList = segmentLists[i];\r\n            let initialisation = segmentList.getElementsByTagName(dashConstants.INITIALIZATION);\r\n            if (initialisation) {\r\n                let sourceURL = initialisation[0].getAttribute(dashConstants.SOURCE_URL);\r\n                sourceURL = `${repId}_init`;\r\n                initialisation[0].setAttribute(dashConstants.SOURCE_URL, sourceURL);\r\n            }\r\n            let segmentURLs = segmentList.getElementsByTagName(dashConstants.SEGMENT_URL);\r\n\r\n            if (segmentURLs) {\r\n                for (let j = 0; j < segmentURLs.length; j++) {\r\n                    let segmentUrl = segmentURLs[j];\r\n                    let media = segmentUrl.getAttribute(dashConstants.MEDIA);\r\n                    media = `${repId}_${j}`;\r\n                    segmentUrl.setAttribute(dashConstants.MEDIA, media);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {XML} adaptationSet\r\n     * @param {object} rep\r\n     * @instance\r\n    */\r\n    function addSegmentTemplateAttributes(adaptationSet, rep) {\r\n        let segmentTemplateElement = DOM.createElement(dashConstants.SEGMENT_TEMPLATE);\r\n        segmentTemplateElement.setAttribute(dashConstants.START_NUMBER, '0');\r\n        segmentTemplateElement.setAttribute(dashConstants.MEDIA, '$RepresentationID$-$Time$');\r\n        segmentTemplateElement.setAttribute(dashConstants.INITIALIZATION_MINUS,'$RepresentationID$_init');\r\n        addSegmentTimelineElements(segmentTemplateElement, rep);\r\n        adaptationSet.appendChild(segmentTemplateElement);\r\n    }\r\n\r\n    /**\r\n     * Delete all representations except the one choosed by user\r\n     * @param {XML} currentAdaptationSet\r\n     * @param {XML} representations\r\n     * @param {string} adaptationType\r\n     * @instance\r\n    */\r\n    function findAndKeepOnlySelectedRepresentations(currentAdaptationSet, representations, adaptationType) {\r\n        for ( var i = representations.length - 1; i >= 0; i--) {\r\n            let representation = representations[i];\r\n            let repId = representation.getAttribute(dashConstants.ID);\r\n            if (allMediaInfos[adaptationType] && allMediaInfos[adaptationType].indexOf(repId) === -1) {\r\n                // representation is not selected, remove it\r\n                currentAdaptationSet.removeChild(representation);\r\n            }\r\n        }\r\n    }\r\n\r\n    //  UTILS\r\n    /**\r\n     * Get id of first representation of adaptation set\r\n     * @param {XMl} currentAdaptationSet\r\n     * @returns {string} id\r\n     * @instance\r\n    */\r\n    function getBestRepresentationId(currentAdaptationSet) {\r\n        let bestRepresentation = currentAdaptationSet.getElementsByTagName(dashConstants.REPRESENTATION)[0];\r\n        console.log(bestRepresentation.getAttribute(dashConstants.ID));\r\n        return bestRepresentation.getAttribute(dashConstants.ID);\r\n    }\r\n\r\n    /**\r\n     * Parse and returns fragments of offline url => xxxx://xxxx/fragmentId/\r\n     * @param {string} url\r\n     * @returns {string} fragmentId\r\n     * @instance\r\n    */\r\n    function getFragmentId(url) {\r\n        let idxFragId = url.lastIndexOf('/');\r\n        //logger.warn('fragId : ' + url.substring(idxFragId + 1, url.length));\r\n        return url.substring(idxFragId,url.length);\r\n    }\r\n\r\n    setup();\r\n\r\n    instance = {\r\n        parse: parse\r\n    };\r\n\r\n    return instance;\r\n}\r\nOfflineIndexDBManifestParser.__dashjs_factory_name = 'OfflineIndexDBManifestParser';\r\nexport default dashjs.FactoryMaker.getClassFactory(OfflineIndexDBManifestParser); /* jshint ignore:line */\r\n"]}