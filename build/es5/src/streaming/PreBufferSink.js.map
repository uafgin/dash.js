{"version":3,"sources":["../../../../src/streaming/PreBufferSink.js"],"names":["PreBufferSink","onAppendedCallback","context","instance","logger","outstandingInit","chunks","onAppended","setup","getInstance","getLogger","reset","append","chunk","segmentType","push","sort","a","b","start","debug","end","remove","filter","isNaN","abort","getAllBufferRanges","ranges","i","length","timeranges","n","Object","defineProperty","get","hasDiscontinuitiesAfter","updateTimestampOffset","getBuffer","discharge","result","getChunksAt","waitForUpdateEnd","callback","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"mappings":"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","file":"PreBufferSink.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Debug from '../core/Debug';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\n\r\n/**\r\n * This is a sink that is used to temporarily hold onto media chunks before a video element is added.\r\n * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\r\n *\r\n * @class PreBufferSink\r\n * @ignore\r\n * @implements FragmentSink\r\n */\r\nfunction PreBufferSink(onAppendedCallback) {\r\n    const context = this.context;\r\n\r\n    let instance,\r\n        logger,\r\n        outstandingInit;\r\n    let chunks = [];\r\n    let onAppended = onAppendedCallback;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n    }\r\n\r\n    function reset() {\r\n        chunks = [];\r\n        outstandingInit = null;\r\n        onAppended = null;\r\n    }\r\n\r\n    function append(chunk) {\r\n        if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache.\r\n            chunks.push(chunk);\r\n            chunks.sort(function (a, b) { return a.start - b.start; });\r\n            outstandingInit = null;\r\n        } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\r\n            outstandingInit = chunk;\r\n        }\r\n\r\n        logger.debug('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\r\n        if (onAppended) {\r\n            onAppended({\r\n                chunk: chunk\r\n            });\r\n        }\r\n    }\r\n\r\n    function remove(start, end) {\r\n        chunks = chunks.filter( a => !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start))); //The opposite of the getChunks predicate.\r\n    }\r\n\r\n    //Nothing async, nothing to abort.\r\n    function abort() {\r\n    }\r\n\r\n    function getAllBufferRanges() {\r\n        let ranges = [];\r\n\r\n        for (let i = 0; i < chunks.length; i++) {\r\n            let chunk = chunks[i];\r\n            if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\r\n                ranges.push({ start: chunk.start, end: chunk.end });\r\n            } else {\r\n                ranges[ranges.length - 1].end = chunk.end;\r\n            }\r\n        }\r\n\r\n        //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\r\n        const timeranges = {\r\n            start: function (n) {\r\n                return ranges[n].start;\r\n            },\r\n            end: function (n) {\r\n                return ranges[n].end;\r\n            }\r\n        };\r\n\r\n        Object.defineProperty(timeranges, 'length', {\r\n            get: function () {\r\n                return ranges.length;\r\n            }\r\n        });\r\n\r\n        return timeranges;\r\n    }\r\n\r\n    function hasDiscontinuitiesAfter() {\r\n        return false;\r\n    }\r\n\r\n    function updateTimestampOffset() {\r\n        // Nothing to do\r\n    }\r\n\r\n    function getBuffer() {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Return the all chunks in the buffer the lie between times start and end.\r\n     * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\r\n     * Chunks are removed from the buffer when they are discharged.\r\n     * @function PreBufferSink#discharge\r\n     * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\r\n     * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\r\n     * @returns {Array} The set of chunks from the buffer within the time ranges.\r\n     */\r\n    function discharge(start, end) {\r\n        const result = getChunksAt(start, end);\r\n        if (outstandingInit) {\r\n            result.push(outstandingInit);\r\n            outstandingInit = null;\r\n        }\r\n\r\n        remove(start, end);\r\n\r\n        return result;\r\n    }\r\n\r\n    function getChunksAt(start, end) {\r\n        return chunks.filter( a => ((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start)) );\r\n    }\r\n\r\n    function waitForUpdateEnd(callback) {\r\n        callback();\r\n    }\r\n\r\n    instance = {\r\n        getAllBufferRanges: getAllBufferRanges,\r\n        append: append,\r\n        remove: remove,\r\n        abort: abort,\r\n        discharge: discharge,\r\n        reset: reset,\r\n        updateTimestampOffset: updateTimestampOffset,\r\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\r\n        waitForUpdateEnd: waitForUpdateEnd,\r\n        getBuffer: getBuffer\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\r\nconst factory = FactoryMaker.getClassFactory(PreBufferSink);\r\nexport default factory;\r\n"]}