{"version":3,"sources":["../../../../../src/streaming/controllers/EventController.js"],"names":["EventController","MPD_RELOAD_SCHEME","MPD_RELOAD_VALUE","MPD_CALLBACK_SCHEME","MPD_CALLBACK_VALUE","REFRESH_DELAY","REMAINING_EVENTS_THRESHOLD","EVENT_HANDLED_STATES","DISCARDED","UPDATED","ADDED","context","eventBus","getInstance","instance","logger","inlineEvents","inbandEvents","eventInterval","lastEventTimerCall","manifestUpdater","playbackController","eventHandlingInProgress","isStarted","_setup","getLogger","_resetInitialSettings","checkConfig","Error","Date","now","_stop","clearInterval","_onStopEventController","e","start","debug","isNaN","setInterval","_onEventTimer","addInlineEvents","values","i","length","event","result","_addOrUpdateEvent","id","_startEvent","MediaPlayerEvents","EVENT_MODE_ON_RECEIVE","addInbandEvents","eventStream","schemeIdUri","undefined","_handleManifestReloadEvent","value","events","shouldOverwriteExistingEvents","eventState","indexOfExistingEvent","findIndex","push","validUntil","calculatedPresentationTime","newDuration","NaN","duration","trigger","MANIFEST_VALIDITY_CHANGED","newManifestValidAfter","mode","EVENT_MODE_ON_START","currentVideoTime","getTime","presentationTimeThreshold","Math","max","_triggerEvents","_triggerRemainingEvents","callback","_eventHasExpired","_eventIsInvalid","_removeEvent","_iterateAndTriggerCallback","currentTime","periodDuration","period","periodStart","calculatedPresentationTimeInSeconds","abs","schemeIdUris","Object","keys","schemeIdEvents","forEach","threshold","periodEndTime","eventId","presentationTimeDelta","_refreshManifest","_sendCallbackRequest","messageData","filter","refreshManifest","url","loader","create","load","method","request","responseType","setConfig","config","getInlineEvents","getInbandEvents","reset","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"EventController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport EventBus from '../../core/EventBus';\r\nimport MediaPlayerEvents from '../../streaming/MediaPlayerEvents';\r\nimport XHRLoader from '../net/XHRLoader';\r\n\r\nfunction EventController() {\r\n\r\n    const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\r\n    const MPD_RELOAD_VALUE = 1;\r\n\r\n    const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\r\n    const MPD_CALLBACK_VALUE = 1;\r\n\r\n    const REFRESH_DELAY = 100;\r\n    const REMAINING_EVENTS_THRESHOLD = 300;\r\n\r\n    const EVENT_HANDLED_STATES = {\r\n        DISCARDED: 'discarded',\r\n        UPDATED: 'updated',\r\n        ADDED: 'added'\r\n    };\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        inlineEvents, // Holds all Inline Events not triggered yet\r\n        inbandEvents, // Holds all Inband Events not triggered yet\r\n        eventInterval, // variable holding the setInterval\r\n        lastEventTimerCall,\r\n        manifestUpdater,\r\n        playbackController,\r\n        eventHandlingInProgress,\r\n        isStarted;\r\n\r\n    /**\r\n     * Internal setup when class is instanced\r\n     */\r\n    function _setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        _resetInitialSettings();\r\n    }\r\n\r\n    /**\r\n     * Checks if the provded configuration is valid\r\n     */\r\n    function checkConfig() {\r\n        if (!manifestUpdater || !playbackController) {\r\n            throw new Error('setConfig function has to be called previously');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset to initial settings\r\n     */\r\n    function _resetInitialSettings() {\r\n        isStarted = false;\r\n        inlineEvents = {}; // Format inlineEvents[schemeIdUri]\r\n        inbandEvents = {}; // Format inlineEvents[schemeIdUri]\r\n        eventInterval = null;\r\n        eventHandlingInProgress = false;\r\n        lastEventTimerCall = Date.now() / 1000;\r\n    }\r\n\r\n    /**\r\n     * Stops the EventController by clearing the event interval\r\n     */\r\n    function _stop() {\r\n        try {\r\n            if (eventInterval !== null && isStarted) {\r\n                clearInterval(eventInterval);\r\n                eventInterval = null;\r\n                isStarted = false;\r\n                _onStopEventController();\r\n            }\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the interval function of the EventController\r\n     */\r\n    function start() {\r\n        try {\r\n            checkConfig();\r\n            logger.debug('Start Event Controller');\r\n            if (!isStarted && !isNaN(REFRESH_DELAY)) {\r\n                isStarted = true;\r\n                eventInterval = setInterval(_onEventTimer, REFRESH_DELAY);\r\n            }\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add MPD events to the list of events.\r\n     * Events that are not in the MPD anymore but not triggered yet will still be deleted.\r\n     * Existing events might get updated.\r\n     * @param {Array.<Object>} values\r\n     */\r\n    function addInlineEvents(values) {\r\n        try {\r\n            checkConfig();\r\n\r\n            if (values) {\r\n                for (let i = 0; i < values.length; i++) {\r\n                    let event = values[i];\r\n                    let result = _addOrUpdateEvent(event, inlineEvents, true);\r\n\r\n                    if (result === EVENT_HANDLED_STATES.ADDED) {\r\n                        logger.debug(`Added inline event with id ${event.id}`);\r\n                        // If we see the event for the first time we trigger it in onReceive mode\r\n                        _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\r\n                    } else if (result === EVENT_HANDLED_STATES.UPDATED) {\r\n                        logger.debug(`Updated inline event with id ${event.id}`);\r\n                    }\r\n                }\r\n            }\r\n            logger.debug(`Added ${values.length} inline events`);\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add EMSG events to the list of events\r\n     * Messages with the same id within the scope of the same scheme_id_uri and value pair are equivalent , i.e. processing of any one event message box with the same id is sufficient.\r\n     * @param {Array.<Object>} values\r\n     */\r\n    function addInbandEvents(values) {\r\n        try {\r\n            checkConfig();\r\n\r\n            for (let i = 0; i < values.length; i++) {\r\n                let event = values[i];\r\n                let result = _addOrUpdateEvent(event, inbandEvents, false);\r\n\r\n                if (result === EVENT_HANDLED_STATES.ADDED) {\r\n                    if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\r\n                        _handleManifestReloadEvent(event);\r\n                    }\r\n                    logger.debug('Added inband event with id ' + event.id);\r\n                    _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\r\n                } else {\r\n                    logger.debug(`Inband event with scheme_id_uri ${event.eventStream.schemeIdUri}, value ${event.eventStream.value} and id ${event.id} was ignored because it has been added before.`);\r\n                }\r\n            }\r\n            _onEventTimer();\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds or updates an event to/in the list of events\r\n     * @param {object} event\r\n     * @param {object} events\r\n     * @param {boolean} shouldOverwriteExistingEvents\r\n     * @return {string}\r\n     * @private\r\n     */\r\n    function _addOrUpdateEvent(event, events, shouldOverwriteExistingEvents = false) {\r\n        const schemeIdUri = event.eventStream.schemeIdUri;\r\n        const value = event.eventStream.value;\r\n        const id = event.id;\r\n        let eventState = EVENT_HANDLED_STATES.DISCARDED;\r\n\r\n        if (!events[schemeIdUri]) {\r\n            events[schemeIdUri] = [];\r\n        }\r\n\r\n        const indexOfExistingEvent = events[schemeIdUri].findIndex((e) => {\r\n            return ((!value || (e.eventStream.value && e.eventStream.value === value)) && (e.id === id));\r\n        });\r\n\r\n        if (indexOfExistingEvent === -1) {\r\n            events[schemeIdUri].push(event);\r\n            eventState = EVENT_HANDLED_STATES.ADDED;\r\n        } else if (shouldOverwriteExistingEvents) {\r\n            events[schemeIdUri][indexOfExistingEvent] = event;\r\n            eventState = EVENT_HANDLED_STATES.UPDATED;\r\n        }\r\n\r\n        return eventState;\r\n    }\r\n\r\n    /**\r\n     * Triggers an MPD reload\r\n     * @param {object} event\r\n     * @private\r\n     */\r\n    function _handleManifestReloadEvent(event) {\r\n        try {\r\n            if (event.eventStream.value == MPD_RELOAD_VALUE) {\r\n                const validUntil = event.calculatedPresentationTime;\r\n                let newDuration;\r\n                if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown\r\n                    newDuration = NaN;\r\n                } else {\r\n                    newDuration = event.calculatedPresentationTime + event.duration;\r\n                }\r\n                //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\r\n                eventBus.trigger(MediaPlayerEvents.MANIFEST_VALIDITY_CHANGED, {\r\n                    id: event.id,\r\n                    validUntil: validUntil,\r\n                    newDuration: newDuration,\r\n                    newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\r\n                }, {\r\n                    mode: MediaPlayerEvents.EVENT_MODE_ON_START\r\n                });\r\n            }\r\n        } catch (e) {\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate through the eventList and trigger the events\r\n     */\r\n    function _onEventTimer() {\r\n        try {\r\n            if (!eventHandlingInProgress) {\r\n                eventHandlingInProgress = true;\r\n                const currentVideoTime = playbackController.getTime();\r\n                let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall);\r\n\r\n                // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\r\n                presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\r\n\r\n                _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\r\n                _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\r\n\r\n                lastEventTimerCall = currentVideoTime;\r\n                eventHandlingInProgress = false;\r\n            }\r\n        } catch (e) {\r\n            eventHandlingInProgress = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When the EventController is stopped this callback is triggered. Starts the remaining events.\r\n     * @private\r\n     */\r\n    function _onStopEventController() {\r\n        try {\r\n            // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\r\n            _triggerRemainingEvents(inbandEvents);\r\n            _triggerRemainingEvents(inlineEvents);\r\n        } catch (e) {\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterate over a list of events and trigger the ones for which the presentation time is within the current timing interval\r\n     * @param {object} events\r\n     * @param {number} presentationTimeThreshold\r\n     * @param {number} currentVideoTime\r\n     * @private\r\n     */\r\n    function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\r\n        try {\r\n            const callback = function (event) {\r\n                if (event !== undefined) {\r\n                    const duration = !isNaN(event.duration) ? event.duration : 0;\r\n                    // The event is either about to start or has already been started and we are within its duration\r\n                    if ((event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime)) {\r\n                        _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\r\n                    } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\r\n                        logger.debug(`Deleting event ${event.id} as it is expired or invalid`);\r\n                        _removeEvent(events, event);\r\n                    }\r\n                }\r\n            };\r\n\r\n            _iterateAndTriggerCallback(events, callback);\r\n        } catch (e) {\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Triggers the remaining events after the EventController has been stopped\r\n     * @param {object} events\r\n     * @private\r\n     */\r\n    function _triggerRemainingEvents(events) {\r\n        try {\r\n            const currentTime = playbackController.getTime();\r\n            const callback = function (event) {\r\n                const periodDuration = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.duration) ? event.eventStream.period.duration : NaN;\r\n                const periodStart = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.start) ? event.eventStream.period.start : NaN;\r\n\r\n                if (isNaN(periodDuration) || isNaN(periodStart)) {\r\n                    return;\r\n                }\r\n\r\n                const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\r\n\r\n                if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\r\n                    _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\r\n                }\r\n\r\n            };\r\n\r\n            _iterateAndTriggerCallback(events, callback());\r\n\r\n        } catch (e) {\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Iterates over the inline/inband event object and triggers a callback for each event\r\n     * @param {object} events\r\n     * @param {function} callback\r\n     * @private\r\n     */\r\n    function _iterateAndTriggerCallback(events, callback) {\r\n        try {\r\n            if (events) {\r\n                const schemeIdUris = Object.keys(events);\r\n                for (let i = 0; i < schemeIdUris.length; i++) {\r\n                    const schemeIdEvents = events[schemeIdUris[i]];\r\n                    schemeIdEvents.forEach((event) => {\r\n                        if (event !== undefined) {\r\n                            callback(event);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        } catch (e) {\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if an event is expired. For instance if the presentationTime + the duration of an event are smaller than the current video time.\r\n     * @param {number} currentVideoTime\r\n     * @param {number} threshold\r\n     * @param {number} calculatedPresentationTimeInSeconds\r\n     * @return {boolean}\r\n     * @private\r\n     */\r\n    function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\r\n        try {\r\n            return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if an event is invalid. This is the case if the end time of the parent period is smaller than the presentation time of the event.\r\n     * @param {object} event\r\n     * @return {boolean}\r\n     * @private\r\n     */\r\n    function _eventIsInvalid(event) {\r\n        try {\r\n            const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\r\n\r\n            return event.calculatedPresentationTime > periodEndTime;\r\n        } catch (e) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts an event. Depending on the schemeIdUri we distinguis between\r\n     * - MPD Reload events\r\n     * - MPD Callback events\r\n     * - Events to be dispatched to the application\r\n     * Events should be removed from the list before beeing triggered. Otherwise the event handler might cause an error and the remove function will not be called.\r\n     * @param {object} event\r\n     * @param {object} events\r\n     * @param {String} mode\r\n     * @private\r\n     */\r\n    function _startEvent(event, events, mode) {\r\n        try {\r\n            const currentVideoTime = playbackController.getTime();\r\n            const eventId = event.id;\r\n\r\n            if (mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE) {\r\n                logger.debug(`Received event ${eventId}`);\r\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\r\n                return;\r\n            }\r\n\r\n            if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\r\n                if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\r\n                    logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`);\r\n                    _removeEvent(events, event);\r\n                    _refreshManifest();\r\n                }\r\n            } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\r\n                logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`);\r\n                _removeEvent(events, event);\r\n                _sendCallbackRequest(event.messageData);\r\n            } else {\r\n                logger.debug(`Starting event ${eventId} at ${currentVideoTime}`);\r\n                _removeEvent(events, event);\r\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\r\n            }\r\n\r\n        } catch (e) {\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes an event from the list. If this is the last event of type \"schemeIdUri\"  the corresponding schemeIdUri Object in the list of events is deleted.\r\n     * @param {object} events\r\n     * @param {object} event\r\n     * @private\r\n     */\r\n    function _removeEvent(events, event) {\r\n        const schemeIdUri = event.eventStream.schemeIdUri;\r\n        const value = event.eventStream.value;\r\n        const id = event.id;\r\n\r\n        events[schemeIdUri] = events[schemeIdUri].filter((e) => {\r\n            return (value && e.eventStream.value && e.eventStream.value !== value) || (e.id !== id);\r\n        });\r\n\r\n        if (events[schemeIdUri].length === 0) {\r\n            delete events[schemeIdUri];\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Refresh the manifest\r\n     * @private\r\n     */\r\n    function _refreshManifest() {\r\n        try {\r\n            checkConfig();\r\n            manifestUpdater.refreshManifest();\r\n        } catch (e) {\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a callback request\r\n     * @param {String} url\r\n     * @private\r\n     */\r\n    function _sendCallbackRequest(url) {\r\n        try {\r\n            let loader = XHRLoader(context).create({});\r\n            loader.load({\r\n                method: 'get',\r\n                url: url,\r\n                request: {\r\n                    responseType: 'arraybuffer'\r\n                }\r\n            });\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the config of the EventController\r\n     * @param {object} config\r\n     */\r\n    function setConfig(config) {\r\n        try {\r\n            if (!config) {\r\n                return;\r\n            }\r\n\r\n            if (config.manifestUpdater) {\r\n                manifestUpdater = config.manifestUpdater;\r\n            }\r\n\r\n            if (config.playbackController) {\r\n                playbackController = config.playbackController;\r\n            }\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns all inline events that have not been triggered yet\r\n     * @return {object}\r\n     */\r\n    function getInlineEvents() {\r\n        return inlineEvents;\r\n    }\r\n\r\n    /**\r\n     * Returns all inband events that have not been triggered yet\r\n     * @return {object}\r\n     */\r\n    function getInbandEvents() {\r\n        return inbandEvents;\r\n    }\r\n\r\n    /**\r\n     * Stop the EventController and reset all initial settings\r\n     */\r\n    function reset() {\r\n        _stop();\r\n        _resetInitialSettings();\r\n    }\r\n\r\n    instance = {\r\n        addInlineEvents,\r\n        addInbandEvents,\r\n        getInbandEvents,\r\n        getInlineEvents,\r\n        start,\r\n        setConfig,\r\n        reset\r\n    };\r\n\r\n    _setup();\r\n\r\n    return instance;\r\n}\r\n\r\nEventController.__dashjs_factory_name = 'EventController';\r\nexport default FactoryMaker.getSingletonFactory(EventController);\r\n"]}