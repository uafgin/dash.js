{"version":3,"sources":["../../../../../src/streaming/controllers/GapController.js"],"names":["GAP_HANDLER_INTERVAL","THRESHOLD_TO_STALLS","GAP_THRESHOLD","GapController","context","eventBus","getInstance","instance","lastPlaybackTime","settings","wallclockTicked","gapHandlerInterval","lastGapJumpPosition","playbackController","streamController","videoModel","timelineConverter","adapter","jumpTimeoutHandler","logger","initialize","registerEvents","setup","getLogger","reset","stopGapHandler","unregisterEvents","resetInitialSettings","NaN","setConfig","config","on","Events","WALLCLOCK_TIME_UPDATED","_onWallclockTimeUpdated","PLAYBACK_SEEKING","_onPlaybackSeeking","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","off","startGapHandler","clearTimeout","_shouldCheckForGaps","currentTime","getTime","jumpGap","get","streaming","jumpGaps","getActiveStreamProcessors","length","isSeeking","hasStreamFinishedBuffering","getActiveStream","isPaused","getIsStreamSwitchInProgress","getHasMediaOrIntialisationError","getNextRangeIndex","ranges","nextRangeIndex","j","isNaN","rangeEnd","end","start","e","debug","setInterval","clearInterval","playbackStalled","smallGapLimit","jumpLargeGaps","getBufferRange","seekToPosition","jumpToStreamEnd","gap","timeToStreamEnd","getTimeToStreamEnd","isFinite","parseFloat","getStreamEndTime","toFixed","timeUntilGapEnd","warn","trigger","GAP_CAUSED_SEEK_TO_PERIOD_END","seekTime","duration","isDynamic","getIsDynamic","timeToWait","window","setTimeout","seek","GAP_CAUSED_INTERNAL_SEEK","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"GapController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport Events from '../../core/events/Events';\r\nimport EventBus from '../../core/EventBus';\r\n\r\nconst GAP_HANDLER_INTERVAL = 100;\r\nconst THRESHOLD_TO_STALLS = 30;\r\nconst GAP_THRESHOLD = 0.1;\r\n\r\nfunction GapController() {\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        lastPlaybackTime,\r\n        settings,\r\n        wallclockTicked,\r\n        gapHandlerInterval,\r\n        lastGapJumpPosition,\r\n        playbackController,\r\n        streamController,\r\n        videoModel,\r\n        timelineConverter,\r\n        adapter,\r\n        jumpTimeoutHandler,\r\n        logger;\r\n\r\n    function initialize() {\r\n        registerEvents();\r\n    }\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n\r\n        reset();\r\n    }\r\n\r\n    function reset() {\r\n        stopGapHandler();\r\n        unregisterEvents();\r\n        resetInitialSettings();\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        gapHandlerInterval = null;\r\n        lastGapJumpPosition = NaN;\r\n        wallclockTicked = 0;\r\n        jumpTimeoutHandler = null;\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) {\r\n            return;\r\n        }\r\n        if (config.settings) {\r\n            settings = config.settings;\r\n        }\r\n        if (config.playbackController) {\r\n            playbackController = config.playbackController;\r\n        }\r\n        if (config.streamController) {\r\n            streamController = config.streamController;\r\n        }\r\n        if (config.videoModel) {\r\n            videoModel = config.videoModel;\r\n        }\r\n        if (config.timelineConverter) {\r\n            timelineConverter = config.timelineConverter;\r\n        }\r\n        if (config.adapter) {\r\n            adapter = config.adapter;\r\n        }\r\n    }\r\n\r\n    function registerEvents() {\r\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\r\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\r\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\r\n    }\r\n\r\n    function unregisterEvents() {\r\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\r\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\r\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\r\n    }\r\n\r\n    function onBytesAppended() {\r\n        if (!gapHandlerInterval) {\r\n            startGapHandler();\r\n        }\r\n    }\r\n\r\n    function _onPlaybackSeeking() {\r\n        if (jumpTimeoutHandler) {\r\n            clearTimeout(jumpTimeoutHandler);\r\n            jumpTimeoutHandler = null;\r\n        }\r\n    }\r\n\r\n    function _onWallclockTimeUpdated(/*e*/) {\r\n        if (!_shouldCheckForGaps()) {\r\n            return;\r\n        }\r\n\r\n        wallclockTicked++;\r\n        if (wallclockTicked >= THRESHOLD_TO_STALLS) {\r\n            const currentTime = playbackController.getTime();\r\n            if (lastPlaybackTime === currentTime) {\r\n                jumpGap(currentTime, true);\r\n            } else {\r\n                lastPlaybackTime = currentTime;\r\n                lastGapJumpPosition = NaN;\r\n            }\r\n            wallclockTicked = 0;\r\n        }\r\n    }\r\n\r\n    function _shouldCheckForGaps() {\r\n        return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 &&\r\n            (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() &&\r\n            !streamController.getHasMediaOrIntialisationError();\r\n    }\r\n\r\n    function getNextRangeIndex(ranges, currentTime) {\r\n        try {\r\n\r\n            if (!ranges || (ranges.length <= 1 && currentTime > 0)) {\r\n                return NaN;\r\n            }\r\n            let nextRangeIndex = NaN;\r\n            let j = 0;\r\n\r\n            while (isNaN(nextRangeIndex) && j < ranges.length) {\r\n                const rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\r\n                if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\r\n                    nextRangeIndex = j;\r\n                }\r\n                j += 1;\r\n            }\r\n            return nextRangeIndex;\r\n\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    function startGapHandler() {\r\n        try {\r\n            if (!gapHandlerInterval) {\r\n                logger.debug('Starting the gap controller');\r\n                gapHandlerInterval = setInterval(() => {\r\n                    if (!_shouldCheckForGaps()) {\r\n                        return;\r\n                    }\r\n                    const currentTime = playbackController.getTime();\r\n                    jumpGap(currentTime);\r\n\r\n                }, GAP_HANDLER_INTERVAL);\r\n            }\r\n        } catch (e) {\r\n        }\r\n    }\r\n\r\n    function stopGapHandler() {\r\n        logger.debug('Stopping the gap controller');\r\n        if (gapHandlerInterval) {\r\n            clearInterval(gapHandlerInterval);\r\n            gapHandlerInterval = null;\r\n        }\r\n    }\r\n\r\n    function jumpGap(currentTime, playbackStalled = false) {\r\n        const smallGapLimit = settings.get().streaming.smallGapLimit;\r\n        const jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\r\n        const ranges = videoModel.getBufferRange();\r\n        let nextRangeIndex;\r\n        let seekToPosition = NaN;\r\n        let jumpToStreamEnd = false;\r\n\r\n\r\n        // Get the range just after current time position\r\n        nextRangeIndex = getNextRangeIndex(ranges, currentTime);\r\n\r\n        if (!isNaN(nextRangeIndex)) {\r\n            const start = ranges.start(nextRangeIndex);\r\n            const gap = start - currentTime;\r\n            if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\r\n                seekToPosition = start;\r\n            }\r\n        }\r\n\r\n        // Playback has stalled before period end. We seek to the end of the period\r\n        const timeToStreamEnd = playbackController.getTimeToStreamEnd();\r\n        if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && timeToStreamEnd < smallGapLimit) {\r\n            seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\r\n            jumpToStreamEnd = true;\r\n        }\r\n\r\n        if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition && seekToPosition > currentTime && !jumpTimeoutHandler) {\r\n            const timeUntilGapEnd = seekToPosition - currentTime;\r\n\r\n            if (jumpToStreamEnd) {\r\n                logger.warn(`Jumping to end of stream because of gap from ${currentTime} to ${seekToPosition}. Gap duration: ${timeUntilGapEnd}`);\r\n                eventBus.trigger(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, {\r\n                    seekTime: seekToPosition,\r\n                    duration: timeUntilGapEnd\r\n                });\r\n            } else {\r\n                const isDynamic = playbackController.getIsDynamic();\r\n                const start = nextRangeIndex > 0 ? ranges.end(nextRangeIndex - 1) : currentTime;\r\n                const timeToWait = !isDynamic ? 0 : timeUntilGapEnd * 1000;\r\n\r\n                jumpTimeoutHandler = window.setTimeout(() => {\r\n                    playbackController.seek(seekToPosition, true, true);\r\n                    logger.warn(`Jumping gap starting at ${start} and ending at ${seekToPosition}. Jumping by: ${timeUntilGapEnd}`);\r\n                    eventBus.trigger(Events.GAP_CAUSED_INTERNAL_SEEK, {\r\n                        seekTime: seekToPosition,\r\n                        duration: timeUntilGapEnd\r\n                    });\r\n                    jumpTimeoutHandler = null;\r\n                }, timeToWait);\r\n            }\r\n            lastGapJumpPosition = seekToPosition;\r\n        }\r\n    }\r\n\r\n    instance = {\r\n        reset,\r\n        setConfig,\r\n        initialize\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nGapController.__dashjs_factory_name = 'GapController';\r\nexport default FactoryMaker.getSingletonFactory(GapController);\r\n"]}