{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":["HTTP_TIMEOUT_MS","DEFAULT_MAXIMUM_ALLOWED_DRIFT","DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR","DEFAULT_BACKGROUND_ATTEMPTS","DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS","DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS","DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC","DEFAULT_MINIMUM_TIME_BETWEEN_SYNC","TimeSyncController","context","eventBus","getInstance","urlUtils","instance","logger","isSynchronizing","isBackgroundSynchronizing","settings","handlers","dashMetrics","backgroundSyncTimeOffsets","timingSources","timeOfLastSync","timeOfLastBackgroundSync","lastOffset","lastTimingSource","internalTimeBetweenSyncAttempts","baseURLController","setup","getLogger","on","Events","ATTEMPT_BACKGROUND_SYNC","_onAttemptBackgroundSync","setConfig","config","_resetInitialSettings","NaN","get","streaming","utcSynchronization","timeBetweenSyncAttempts","initialize","_httpHeadHandler","_httpHandler","bind","_xsdatetimeDecoder","_iso8601Decoder","_directHandler","_notSupportedHandler","attemptSync","tSources","_shouldPerformSynchronization","trigger","TIME_SYNCHRONIZATION_COMPLETED","_attemptRecursiveSync","value","schemeIdUri","isNaN","backgroundAttempts","Date","now","_attemptBackgroundSync","attempts","_completeBackgroundTimeSyncSequence","deviceTimeBeforeSync","serverTime","deviceTimeAfterSync","offset","_calculateOffset","push","e","sourceIndex","index","length","_onComplete","source","hasOwnProperty","getTime","deviceReferenceTime","failed","useManifestDateHeaderTimeSource","_checkForDateHeader","_completeTimeSyncSequence","_alternateXsdatetimeDecoder","xsdatetimeStr","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","exec","UTC","parseInt","parseFloat","parsedDate","parse","isoStr","_rfc1123Decoder","dateStr","url","onSuccessCB","onFailureCB","time","decoder","isHeadRequest","oncomplete","onload","complete","req","XMLHttpRequest","verb","HTTPRequest","HEAD","GET","urls","shift","join","result","status","getResponseHeader","response","isRelative","baseUrl","resolve","open","timeout","onloadend","send","dateHeaderValue","getLatestMPDRequestHeaderValueByID","dateHeaderTime","Number","offsetToDeviceTimeMs","_adjustTimeBetweenSyncAttempts","shouldAttemptBackgroundSync","debug","UPDATE_TIME_SYNC_OFFSET","error","DashJSError","Errors","TIME_SYNC_FAILED_ERROR_CODE","TIME_SYNC_FAILED_ERROR_MESSAGE","isOffsetDriftWithinThreshold","_isOffsetDriftWithinThreshold","timeBetweenSyncAttemptsAdjustmentFactor","maximumTimeBetweenSyncAttempts","minimumTimeBetweenSyncAttempts","adjustedTimeBetweenSyncAttempts","Math","min","max","averageOffset","reduce","acc","curr","maxAllowedDrift","maximumAllowedDrift","lowerBound","upperBound","reset","off","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"TimeSyncController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport DashJSError from './../vo/DashJSError';\r\nimport {HTTPRequest} from '../vo/metrics/HTTPRequest';\r\nimport EventBus from './../../core/EventBus';\r\nimport Events from './../../core/events/Events';\r\nimport Errors from './../../core/errors/Errors';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport URLUtils from '../utils/URLUtils';\r\n\r\nconst HTTP_TIMEOUT_MS = 5000;\r\nconst DEFAULT_MAXIMUM_ALLOWED_DRIFT = 100;\r\nconst DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR = 2;\r\nconst DEFAULT_BACKGROUND_ATTEMPTS = 2;\r\nconst DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS = 30;\r\nconst DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS = 30;\r\nconst DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC = 600;\r\nconst DEFAULT_MINIMUM_TIME_BETWEEN_SYNC = 2;\r\n\r\nfunction TimeSyncController() {\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const urlUtils = URLUtils(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        isSynchronizing,\r\n        isBackgroundSynchronizing,\r\n        settings,\r\n        handlers,\r\n        dashMetrics,\r\n        backgroundSyncTimeOffsets,\r\n        timingSources,\r\n        timeOfLastSync,\r\n        timeOfLastBackgroundSync,\r\n        lastOffset,\r\n        lastTimingSource,\r\n        internalTimeBetweenSyncAttempts,\r\n        baseURLController;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n\r\n        eventBus.on(Events.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.dashMetrics) {\r\n            dashMetrics = config.dashMetrics;\r\n        }\r\n\r\n        if (config.baseURLController) {\r\n            baseURLController = config.baseURLController;\r\n        }\r\n\r\n        if (config.settings) {\r\n            settings = config.settings;\r\n        }\r\n    }\r\n\r\n    function _resetInitialSettings() {\r\n        backgroundSyncTimeOffsets = [];\r\n        timingSources = [];\r\n        timeOfLastSync = null;\r\n        timeOfLastBackgroundSync = null;\r\n        lastTimingSource = null;\r\n        lastOffset = NaN;\r\n        isSynchronizing = false;\r\n        isBackgroundSynchronizing = false;\r\n        internalTimeBetweenSyncAttempts = settings.get().streaming.utcSynchronization.timeBetweenSyncAttempts;\r\n    }\r\n\r\n    /**\r\n     * Register the timing handler depending on the schemeIdUris. This method is called once when the StreamController is initialized\r\n     */\r\n    function initialize() {\r\n        _resetInitialSettings();\r\n\r\n        // a list of known schemeIdUris and a method to call with @value\r\n        handlers = {\r\n            'urn:mpeg:dash:utc:http-head:2014': _httpHeadHandler,\r\n            'urn:mpeg:dash:utc:http-xsdate:2014': _httpHandler.bind(null, _xsdatetimeDecoder),\r\n            'urn:mpeg:dash:utc:http-iso:2014': _httpHandler.bind(null, _iso8601Decoder),\r\n            'urn:mpeg:dash:utc:direct:2014': _directHandler,\r\n\r\n            // some specs referencing early ISO23009-1 drafts incorrectly use\r\n            // 2012 in the URI, rather than 2014. support these for now.\r\n            'urn:mpeg:dash:utc:http-head:2012': _httpHeadHandler,\r\n            'urn:mpeg:dash:utc:http-xsdate:2012': _httpHandler.bind(null, _xsdatetimeDecoder),\r\n            'urn:mpeg:dash:utc:http-iso:2012': _httpHandler.bind(null, _iso8601Decoder),\r\n            'urn:mpeg:dash:utc:direct:2012': _directHandler,\r\n\r\n            // it isn't clear how the data returned would be formatted, and\r\n            // no public examples available so http-ntp not supported for now.\r\n            // presumably you would do an arraybuffer type xhr and decode the\r\n            // binary data returned but I would want to see a sample first.\r\n            'urn:mpeg:dash:utc:http-ntp:2014': _notSupportedHandler,\r\n\r\n            // not clear how this would be supported in javascript (in browser)\r\n            'urn:mpeg:dash:utc:ntp:2014': _notSupportedHandler,\r\n            'urn:mpeg:dash:utc:sntp:2014': _notSupportedHandler\r\n        };\r\n\r\n    }\r\n\r\n    /**\r\n     * Sync against a timing source. T\r\n     * @param {array} tSources\r\n     */\r\n    function attemptSync(tSources) {\r\n\r\n        timingSources = tSources;\r\n\r\n        // Stop if we are already synchronizing\r\n        if (isSynchronizing) {\r\n            return;\r\n        }\r\n\r\n        // No synchronization required we can signal the completion immediately\r\n        if (!_shouldPerformSynchronization()) {\r\n            eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED);\r\n            return;\r\n        }\r\n\r\n        isSynchronizing = true;\r\n        _attemptRecursiveSync();\r\n    }\r\n\r\n    /**\r\n     * Does a synchronization in the background in case the last offset should be verified or a 404 occurs\r\n     */\r\n    function _onAttemptBackgroundSync() {\r\n        if (isSynchronizing || isBackgroundSynchronizing || !lastTimingSource || !lastTimingSource.value || !lastTimingSource.schemeIdUri || isNaN(lastOffset) || isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts)) {\r\n            return;\r\n        }\r\n\r\n        if (timeOfLastBackgroundSync && ((Date.now() - timeOfLastBackgroundSync) / 1000) < DEFAULT_MINIMUM_TIME_BETWEEN_BACKGROUND_SYNC_ATTEMPTS) {\r\n            return;\r\n        }\r\n\r\n        backgroundSyncTimeOffsets = [];\r\n        isBackgroundSynchronizing = true;\r\n        const backgroundAttempts = !isNaN(settings.get().streaming.utcSynchronization.backgroundAttempts) ? settings.get().streaming.utcSynchronization.backgroundAttempts : DEFAULT_BACKGROUND_ATTEMPTS;\r\n        _attemptBackgroundSync(backgroundAttempts);\r\n    }\r\n\r\n    /**\r\n     * Perform a defined number of background attempts\r\n     * @param {number} attempts\r\n     * @private\r\n     */\r\n    function _attemptBackgroundSync(attempts) {\r\n        try {\r\n            if (attempts <= 0) {\r\n                _completeBackgroundTimeSyncSequence();\r\n                return;\r\n            }\r\n\r\n            const deviceTimeBeforeSync = Date.now();\r\n            handlers[lastTimingSource.schemeIdUri](\r\n                lastTimingSource.value,\r\n                function (serverTime) {\r\n                    // the timing source returned something useful\r\n                    const deviceTimeAfterSync = Date.now();\r\n                    const offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\r\n\r\n                    backgroundSyncTimeOffsets.push(offset);\r\n                    _attemptBackgroundSync(attempts - 1);\r\n                },\r\n                function () {\r\n                    _completeBackgroundTimeSyncSequence();\r\n                }\r\n            );\r\n        } catch (e) {\r\n            _completeBackgroundTimeSyncSequence();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sync against a timing source. This method is called recursively if the time sync for the first entry in timingSources fails.\r\n     * @param {number} sourceIndex\r\n     */\r\n    function _attemptRecursiveSync(sourceIndex = null) {\r\n        // if called with no sourceIndex, use zero (highest priority)\r\n        let index = sourceIndex || 0;\r\n\r\n        // the sources should be ordered in priority from the manifest.\r\n        // try each in turn, from the top, until either something\r\n        // sensible happens, or we run out of sources to try.\r\n        if (!timingSources || timingSources.length === 0 || index >= timingSources.length) {\r\n            _onComplete();\r\n            return;\r\n        }\r\n        let source = timingSources[index];\r\n\r\n        if (source) {\r\n            // check if there is a handler for this @schemeIdUri\r\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\r\n                // if so, call it with its @value\r\n                const deviceTimeBeforeSync = new Date().getTime();\r\n                handlers[source.schemeIdUri](\r\n                    source.value,\r\n                    function (serverTime) {\r\n                        // the timing source returned something useful\r\n                        const deviceTimeAfterSync = new Date().getTime();\r\n                        const offset = _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime);\r\n                        lastTimingSource = source;\r\n\r\n                        _onComplete(offset);\r\n                    },\r\n                    function () {\r\n                        // the timing source was probably uncontactable\r\n                        // or returned something we can't use - try again\r\n                        // with the remaining sources\r\n                        _attemptRecursiveSync(index + 1);\r\n                    }\r\n                );\r\n            } else {\r\n                // an unknown schemeIdUri must have been found\r\n                // try again with the remaining sources\r\n                _attemptRecursiveSync(index + 1);\r\n            }\r\n        } else {\r\n            // no valid time source could be found, just use device time\r\n            _onComplete();\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Calculate the offset between client and server. Account for the roundtrip time\r\n     * @param {number} deviceTimeBeforeSync\r\n     * @param {number} deviceTimeAfterSync\r\n     * @param {number} serverTime\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    function _calculateOffset(deviceTimeBeforeSync, deviceTimeAfterSync, serverTime) {\r\n        const deviceReferenceTime = deviceTimeAfterSync - ((deviceTimeAfterSync - deviceTimeBeforeSync) / 2);\r\n\r\n        return serverTime - deviceReferenceTime;\r\n    }\r\n\r\n    /**\r\n     * Checks if a synchronization is required\r\n     * @return {boolean}\r\n     * @private\r\n     */\r\n    function _shouldPerformSynchronization() {\r\n        try {\r\n            const timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\r\n\r\n            if (!timeOfLastSync || !timeBetweenSyncAttempts || isNaN(timeBetweenSyncAttempts)) {\r\n                return true;\r\n            }\r\n\r\n            return ((Date.now() - timeOfLastSync) / 1000) >= timeBetweenSyncAttempts;\r\n        } catch (e) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback after sync has been completed\r\n     * @param {number} offset\r\n     * @private\r\n     */\r\n    function _onComplete(offset = NaN) {\r\n        let failed = isNaN(offset);\r\n        if (failed && settings.get().streaming.useManifestDateHeaderTimeSource) {\r\n            //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\r\n            _checkForDateHeader();\r\n        } else {\r\n            _completeTimeSyncSequence(failed, offset);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Takes xsdatetime and returns milliseconds since UNIX epoch. May not be necessary as xsdatetime is very similar to ISO 8601 which is natively understood by javascript Date parser\r\n     * @param {string} xsdatetimeStr\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    function _alternateXsdatetimeDecoder(xsdatetimeStr) {\r\n        // taken from DashParser - should probably refactor both uses\r\n        const SECONDS_IN_MIN = 60;\r\n        const MINUTES_IN_HOUR = 60;\r\n        const MILLISECONDS_IN_SECONDS = 1000;\r\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\r\n\r\n        let utcDate,\r\n            timezoneOffset;\r\n\r\n        let match = datetimeRegex.exec(xsdatetimeStr);\r\n\r\n        // If the string does not contain a timezone offset different browsers can interpret it either\r\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\r\n        // all browsers\r\n        utcDate = Date.UTC(\r\n            parseInt(match[1], 10),\r\n            parseInt(match[2], 10) - 1, // months start from zero\r\n            parseInt(match[3], 10),\r\n            parseInt(match[4], 10),\r\n            parseInt(match[5], 10),\r\n            (match[6] && (parseInt(match[6], 10) || 0)),\r\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\r\n        );\r\n        // If the date has timezone offset take it into account as well\r\n        if (match[9] && match[10]) {\r\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\r\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\r\n        }\r\n\r\n        return new Date(utcDate).getTime();\r\n    }\r\n\r\n\r\n    /**\r\n     * Try to use the built in parser, since xsdate is a constrained ISO8601 which is supported natively by Date.parse. if that fails, try a regex-based version used elsewhere in this application.\r\n     * @param {string} xsdatetimeStr\r\n     * @return {number}\r\n     */\r\n    function _xsdatetimeDecoder(xsdatetimeStr) {\r\n        let parsedDate = Date.parse(xsdatetimeStr);\r\n\r\n        if (isNaN(parsedDate)) {\r\n            parsedDate = _alternateXsdatetimeDecoder(xsdatetimeStr);\r\n        }\r\n\r\n        return parsedDate;\r\n    }\r\n\r\n    /**\r\n     * Takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\r\n     * @param {string} isoStr\r\n     * @return {number}\r\n     */\r\n    function _iso8601Decoder(isoStr) {\r\n        return Date.parse(isoStr);\r\n    }\r\n\r\n    /**\r\n     * Takes RFC 1123 timestamp (which is same as ISO8601) and returns milliseconds since UNIX epoch\r\n     * @param {string} dateStr\r\n     * @return {number}\r\n     */\r\n    function _rfc1123Decoder(dateStr) {\r\n        return Date.parse(dateStr);\r\n    }\r\n\r\n    /**\r\n     * Handler for unsupported scheme ids.\r\n     * @param {string} url\r\n     * @param {function} onSuccessCB\r\n     * @param {function} onFailureCB\r\n     * @private\r\n     */\r\n    function _notSupportedHandler(url, onSuccessCB, onFailureCB) {\r\n        onFailureCB();\r\n    }\r\n\r\n    /**\r\n     * Direct handler\r\n     * @param {string} xsdatetimeStr\r\n     * @param {function} onSuccessCB\r\n     * @param {function} onFailureCB\r\n     */\r\n    function _directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\r\n        let time = _xsdatetimeDecoder(xsdatetimeStr);\r\n\r\n        if (!isNaN(time)) {\r\n            onSuccessCB(time);\r\n            return;\r\n        }\r\n\r\n        onFailureCB();\r\n    }\r\n\r\n    /**\r\n     * Generic http handler\r\n     * @param {function} decoder\r\n     * @param {string} url\r\n     * @param {function} onSuccessCB\r\n     * @param {function} onFailureCB\r\n     * @param {boolean} isHeadRequest\r\n     * @private\r\n     */\r\n    function _httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\r\n        let oncomplete,\r\n            onload;\r\n        let complete = false;\r\n        let req = new XMLHttpRequest();\r\n\r\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\r\n        let urls = url.match(/\\S+/g);\r\n\r\n        // according to ISO 23009-1, url could be a white-space\r\n        // separated list of URLs. just handle one at a time.\r\n        url = urls.shift();\r\n\r\n        oncomplete = function () {\r\n            if (complete) {\r\n                return;\r\n            }\r\n\r\n            // we only want to pass through here once per xhr,\r\n            // regardless of whether the load was successful.\r\n            complete = true;\r\n\r\n            // if there are more urls to try, call self.\r\n            if (urls.length) {\r\n                _httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\r\n            } else {\r\n                onFailureCB();\r\n            }\r\n        };\r\n\r\n        onload = function () {\r\n            let time,\r\n                result;\r\n\r\n            if (req.status === 200) {\r\n                time = isHeadRequest ?\r\n                    req.getResponseHeader('Date') :\r\n                    req.response;\r\n\r\n                result = decoder(time);\r\n\r\n                // decoder returns NaN if non-standard input\r\n                if (!isNaN(result)) {\r\n                    onSuccessCB(result);\r\n                    complete = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (urlUtils.isRelative(url)) {\r\n            // passing no path to resolve will return just MPD BaseURL/baseUri\r\n            const baseUrl = baseURLController.resolve();\r\n            if (baseUrl) {\r\n                url = urlUtils.resolve(url, baseUrl.url);\r\n            }\r\n        }\r\n\r\n        req.open(verb, url);\r\n        req.timeout = HTTP_TIMEOUT_MS || 0;\r\n        req.onload = onload;\r\n        req.onloadend = oncomplete;\r\n        req.send();\r\n    }\r\n\r\n    /**\r\n     * Handler for http-head schemeIdUri\r\n     * @param {string} url\r\n     * @param {function} onSuccessCB\r\n     * @param {function} onFailureCB\r\n     * @private\r\n     */\r\n    function _httpHeadHandler(url, onSuccessCB, onFailureCB) {\r\n        _httpHandler(_rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\r\n    }\r\n\r\n    /**\r\n     * Checks if a date header is present in the MPD response and calculates the offset based on the header\r\n     * @private\r\n     */\r\n    function _checkForDateHeader() {\r\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID('Date');\r\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\r\n\r\n        if (!isNaN(dateHeaderTime)) {\r\n            const offsetToDeviceTimeMs = dateHeaderTime - Date.now();\r\n            _completeTimeSyncSequence(false, offsetToDeviceTimeMs);\r\n        } else {\r\n            _completeTimeSyncSequence(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Triggers the event to signal that the time synchronization was completed\r\n     * @param {boolean} failed\r\n     * @param {number} offset\r\n     * @private\r\n     */\r\n    function _completeTimeSyncSequence(failed, offset) {\r\n\r\n        // Adjust the time of the next sync based on the drift between current offset and last offset\r\n        if (!isNaN(lastOffset) && !isNaN(offset) && !failed) {\r\n            _adjustTimeBetweenSyncAttempts(offset);\r\n        }\r\n\r\n        // Update the internal data\r\n        if (!failed && !isNaN(offset)) {\r\n            timeOfLastSync = Date.now();\r\n            isSynchronizing = false;\r\n\r\n            // if this is the first sync we are doing perform background syncs as well to confirm current offset\r\n            const shouldAttemptBackgroundSync = isNaN(lastOffset);\r\n            lastOffset = offset;\r\n            if (shouldAttemptBackgroundSync) {\r\n                _onAttemptBackgroundSync();\r\n            }\r\n            logger.debug(`Completed UTC sync. Setting client - server offset to ${offset}`);\r\n        }\r\n\r\n        if (failed) {\r\n            lastTimingSource = null;\r\n        }\r\n\r\n        // Notify other classes\r\n        eventBus.trigger(Events.UPDATE_TIME_SYNC_OFFSET, {\r\n            offset: offset,\r\n            error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null\r\n        });\r\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED);\r\n    }\r\n\r\n    function _adjustTimeBetweenSyncAttempts(offset) {\r\n        try {\r\n            const isOffsetDriftWithinThreshold = _isOffsetDriftWithinThreshold(offset);\r\n            const timeBetweenSyncAttempts = !isNaN(internalTimeBetweenSyncAttempts) ? internalTimeBetweenSyncAttempts : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS;\r\n            const timeBetweenSyncAttemptsAdjustmentFactor = !isNaN(settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? settings.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor : DEFAULT_TIME_BETWEEN_SYNC_ATTEMPTS_ADJUSTMENT_FACTOR;\r\n            const maximumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts : DEFAULT_MAXIMUM_TIME_BETWEEN_SYNC;\r\n            const minimumTimeBetweenSyncAttempts = !isNaN(settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? settings.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts : DEFAULT_MINIMUM_TIME_BETWEEN_SYNC;\r\n            let adjustedTimeBetweenSyncAttempts;\r\n\r\n            if (isOffsetDriftWithinThreshold) {\r\n                // The drift between the current offset and the last offset is within the allowed threshold. Increase sync time\r\n                adjustedTimeBetweenSyncAttempts = Math.min(timeBetweenSyncAttempts * timeBetweenSyncAttemptsAdjustmentFactor, maximumTimeBetweenSyncAttempts);\r\n                logger.debug(`Increasing timeBetweenSyncAttempts to ${adjustedTimeBetweenSyncAttempts}`);\r\n            } else {\r\n                // Drift between the current offset and the last offset is not within the allowed threshold. Decrease sync time\r\n                adjustedTimeBetweenSyncAttempts = Math.max(timeBetweenSyncAttempts / timeBetweenSyncAttemptsAdjustmentFactor, minimumTimeBetweenSyncAttempts);\r\n                logger.debug(`Decreasing timeBetweenSyncAttempts to ${adjustedTimeBetweenSyncAttempts}`);\r\n            }\r\n\r\n            internalTimeBetweenSyncAttempts = adjustedTimeBetweenSyncAttempts;\r\n        } catch (e) {\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Callback after all background syncs have been completed.\r\n     * @private\r\n     */\r\n    function _completeBackgroundTimeSyncSequence() {\r\n        if (!backgroundSyncTimeOffsets || backgroundSyncTimeOffsets.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const averageOffset = backgroundSyncTimeOffsets.reduce((acc, curr) => {\r\n            return acc + curr;\r\n        }, 0) / backgroundSyncTimeOffsets.length;\r\n\r\n        if (!_isOffsetDriftWithinThreshold(averageOffset)) {\r\n            logger.debug(`Completed background UTC sync. Setting client - server offset to ${averageOffset}`);\r\n            lastOffset = averageOffset;\r\n            eventBus.trigger(Events.UPDATE_TIME_SYNC_OFFSET, {\r\n                offset: lastOffset\r\n            });\r\n        } else {\r\n            logger.debug(`Completed background UTC sync. Offset is within allowed threshold and is not adjusted.`);\r\n        }\r\n\r\n        isBackgroundSynchronizing = false;\r\n        timeOfLastBackgroundSync = Date.now();\r\n    }\r\n\r\n    function _isOffsetDriftWithinThreshold(offset) {\r\n        try {\r\n            if (isNaN(lastOffset)) {\r\n                return true;\r\n            }\r\n\r\n            const maxAllowedDrift = settings.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(settings.get().streaming.utcSynchronization.maximumAllowedDrift) ? settings.get().streaming.utcSynchronization.maximumAllowedDrift : DEFAULT_MAXIMUM_ALLOWED_DRIFT;\r\n            const lowerBound = lastOffset - maxAllowedDrift;\r\n            const upperBound = lastOffset + maxAllowedDrift;\r\n\r\n            return offset >= lowerBound && offset <= upperBound;\r\n        } catch (e) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function reset() {\r\n        _resetInitialSettings();\r\n\r\n        eventBus.off(Events.ATTEMPT_BACKGROUND_SYNC, _onAttemptBackgroundSync, instance);\r\n    }\r\n\r\n    instance = {\r\n        initialize,\r\n        attemptSync,\r\n        setConfig,\r\n        reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\r\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\r\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\r\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\r\nexport default factory;\r\n"]}