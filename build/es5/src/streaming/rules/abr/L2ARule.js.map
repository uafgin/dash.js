{"version":3,"sources":["../../../../../../src/streaming/rules/abr/L2ARule.js"],"names":["L2A_STATE_ONE_BITRATE","L2A_STATE_STARTUP","L2A_STATE_STEADY","L2ARule","config","context","dashMetrics","eventBus","getInstance","instance","l2AStateDict","l2AParameterDict","logger","setup","getLogger","_resetInitialSettings","on","Events","PLAYBACK_SEEKING","_onPlaybackSeeking","MEDIA_FRAGMENT_LOADED","_onMediaFragmentLoaded","METRIC_ADDED","_onMetricAdded","QUALITY_CHANGE_REQUESTED","_onQualityChangeRequested","_getInitialL2AState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrates","bitrateList","map","b","bandwidth","state","lastQuality","_initializeL2AParameters","_clearL2AStateOnSeek","type","w","prev_w","Q","segment_request_start_s","segment_download_finish_s","B_target","l2AState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","_getL2AState","mediaType","getMediaType","hasOwnProperty","l2aState","e","chunk","l2AParameters","start","isNaN","duration","quality","_checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","length","trequest","getTime","_tfinish","L2AState","abrQuality","newQuality","_dotmultiplication","arr1","arr2","sumdot","i","euclideanProjection","arr","m","bget","ii","s","sort","a","tmpsum","tmax","x","Math","max","getMaxIndex","switchRequest","create","horizon","vl","pow","alpha","sqrt","bitrateCount","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","isDynamic","manifestInfo","useL2AABR","bufferLevel","getCurrentBufferLevel","safeThroughput","getSafeAverageThroughput","throughput","getAverageThroughput","react","latency","getAverageLatency","videoModel","getVideoModel","currentPlaybackRate","getPlaybackRate","reason","Constants","AUDIO","setTimeToLoadDelay","l2AParameter","getQualityForBitrate","diff1","throughputMeasureTime","getCurrentHttpRequest","reduce","d","downloadBytes","lastthroughput","round","V","sign","temp","abs","indexOf","min","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"L2ARule.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2020, Unified Streaming.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\r\n\r\nimport MetricsConstants from '../../constants/MetricsConstants';\r\nimport SwitchRequest from '../SwitchRequest';\r\nimport FactoryMaker from '../../../core/FactoryMaker';\r\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\r\nimport EventBus from '../../../core/EventBus';\r\nimport Events from '../../../core/events/Events';\r\nimport Debug from '../../../core/Debug';\r\nimport Constants from '../../constants/Constants';\r\n\r\nconst L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\r\nconst L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\r\nconst L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\r\n\r\n\r\nfunction L2ARule(config) {\r\n    config = config || {};\r\n    const context = this.context;\r\n\r\n    const dashMetrics = config.dashMetrics;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        l2AStateDict,\r\n        l2AParameterDict,\r\n        logger;\r\n\r\n    /**\r\n     * Setup function to initialize L2ARule\r\n     */\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        _resetInitialSettings();\r\n\r\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\r\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\r\n        eventBus.on(Events.METRIC_ADDED, _onMetricAdded, instance);\r\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\r\n    }\r\n\r\n    /**\r\n     * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\r\n     * @param {object} rulesContext\r\n     * @return {object} initialState\r\n     * @private\r\n     */\r\n    function _getInitialL2AState(rulesContext) {\r\n        const initialState = {};\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const bitrates = mediaInfo.bitrateList.map((b) => {\r\n            return b.bandwidth / 1000;\r\n        });\r\n\r\n        initialState.state = L2A_STATE_STARTUP;\r\n        initialState.bitrates = bitrates;\r\n        initialState.lastQuality = 0;\r\n\r\n        _initializeL2AParameters(mediaInfo);\r\n        _clearL2AStateOnSeek(initialState);\r\n\r\n        return initialState;\r\n    }\r\n\r\n    /**\r\n     * Initializes the parameters of the algorithm. This will be done once for each media type.\r\n     * @param {object} mediaInfo\r\n     * @private\r\n     */\r\n    function _initializeL2AParameters(mediaInfo) {\r\n\r\n        if (!mediaInfo || !mediaInfo.type) {\r\n            return;\r\n        }\r\n        l2AParameterDict[mediaInfo.type] = {};\r\n        l2AParameterDict[mediaInfo.type].w = []; //Vector of probabilities associated with bitrate decisions\r\n        l2AParameterDict[mediaInfo.type].prev_w = []; //Vector of probabilities associated with bitrate decisions calculated in the previous step\r\n        l2AParameterDict[mediaInfo.type].Q = 0; //Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\r\n        l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\r\n        l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\r\n        l2AParameterDict[mediaInfo.type].B_target = 1.5; //Target buffer level\r\n    }\r\n\r\n\r\n    /**\r\n     * Clears the state object\r\n     * @param {object} l2AState\r\n     * @private\r\n     */\r\n    function _clearL2AStateOnSeek(l2AState) {\r\n        l2AState.placeholderBuffer = 0;\r\n        l2AState.mostAdvancedSegmentStart = NaN;\r\n        l2AState.lastSegmentWasReplacement = false;\r\n        l2AState.lastSegmentStart = NaN;\r\n        l2AState.lastSegmentDurationS = NaN;\r\n        l2AState.lastSegmentRequestTimeMs = NaN;\r\n        l2AState.lastSegmentFinishTimeMs = NaN;\r\n    }\r\n\r\n\r\n    /**\r\n     * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\r\n     * @param {object} rulesContext\r\n     * @return {object} l2AState\r\n     * @private\r\n     */\r\n    function _getL2AState(rulesContext) {\r\n        const mediaType = rulesContext.getMediaType();\r\n        let l2AState = l2AStateDict[mediaType];\r\n\r\n        if (!l2AState) {\r\n            l2AState = _getInitialL2AState(rulesContext);\r\n            l2AStateDict[mediaType] = l2AState;\r\n        }\r\n\r\n        return l2AState;\r\n    }\r\n\r\n    /**\r\n     * Event handler for the seeking event.\r\n     * @private\r\n     */\r\n    function _onPlaybackSeeking() {\r\n        for (const mediaType in l2AStateDict) {\r\n            if (l2AStateDict.hasOwnProperty(mediaType)) {\r\n                const l2aState = l2AStateDict[mediaType];\r\n                if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\r\n                    l2aState.state = L2A_STATE_STARTUP;\r\n                    _clearL2AStateOnSeek(l2aState);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler for the mediaFragmentLoaded event\r\n     * @param {object} e\r\n     * @private\r\n     */\r\n    function _onMediaFragmentLoaded(e) {\r\n        if (e && e.chunk && e.chunk.mediaInfo) {\r\n            const l2AState = l2AStateDict[e.chunk.mediaInfo.type];\r\n            const l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\r\n\r\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\r\n                const start = e.chunk.start;\r\n                if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\r\n                    l2AState.mostAdvancedSegmentStart = start;\r\n                    l2AState.lastSegmentWasReplacement = false;\r\n                } else {\r\n                    l2AState.lastSegmentWasReplacement = true;\r\n                }\r\n\r\n                l2AState.lastSegmentStart = start;\r\n                l2AState.lastSegmentDurationS = e.chunk.duration;\r\n                l2AState.lastQuality = e.chunk.quality;\r\n\r\n                _checkNewSegment(l2AState, l2AParameters);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler for the metricAdded event\r\n     * @param {object} e\r\n     * @private\r\n     */\r\n    function _onMetricAdded(e) {\r\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\r\n            const l2AState = l2AStateDict[e.mediaType];\r\n            const l2AParameters = l2AParameterDict[e.mediaType];\r\n\r\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\r\n                l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\r\n                l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\r\n                _checkNewSegment(l2AState, l2AParameters);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\r\n     * @param {object} L2AState\r\n     * @param {object} l2AParameters\r\n     * @private\r\n     */\r\n    function _checkNewSegment(L2AState, l2AParameters) {\r\n        if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\r\n            l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\r\n            l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\r\n            L2AState.lastSegmentStart = NaN;\r\n            L2AState.lastSegmentRequestTimeMs = NaN;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Event handler for the qualityChangeRequested event\r\n     * @param {object} e\r\n     * @private\r\n     */\r\n    function _onQualityChangeRequested(e) {\r\n        // Useful to store change requests when abandoning a download.\r\n        if (e && e.mediaType) {\r\n            const L2AState = l2AStateDict[e.mediaType];\r\n            if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\r\n                L2AState.abrQuality = e.newQuality;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dot multiplication of two arrays\r\n     * @param {array} arr1\r\n     * @param {array} arr2\r\n     * @return {number} sumdot\r\n     * @private\r\n     */\r\n\r\n    function _dotmultiplication(arr1, arr2) {\r\n        if (arr1.length !== arr2.length) {\r\n            return -1;\r\n        }\r\n        let sumdot = 0;\r\n        for (let i = 0; i < arr1.length; i++) {\r\n            sumdot = sumdot + arr1[i] * arr2[i];\r\n        }\r\n        return sumdot;\r\n    }\r\n\r\n    /**\r\n     * Project an n-dim vector y to the simplex Dn\r\n     * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\r\n     * Algorithm is explained at http://arxiv.org/abs/1101.6081\r\n     * @param {array} arr\r\n     * @return {array}\r\n     */\r\n    function euclideanProjection(arr) {\r\n        const m = arr.length;\r\n        let bget = false;\r\n        let arr2 = [];\r\n        for (let ii = 0; ii < m; ++ii) {\r\n            arr2[ii] = arr[ii];\r\n        }\r\n        let s = arr.sort(function (a, b) {\r\n            return b - a;\r\n        });\r\n        let tmpsum = 0;\r\n        let tmax = 0;\r\n        let x = [];\r\n        for (let ii = 0; ii < m - 1; ++ii) {\r\n            tmpsum = tmpsum + s[ii];\r\n            tmax = (tmpsum - 1) / (ii + 1);\r\n            if (tmax >= s[ii + 1]) {\r\n                bget = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!bget) {\r\n            tmax = (tmpsum + s[m - 1] - 1) / m;\r\n        }\r\n        for (let ii = 0; ii < m; ++ii) {\r\n            x[ii] = Math.max(arr2[ii] - tmax, 0);\r\n        }\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * Returns a switch request object indicating which quality is to be played\r\n     * @param {object} rulesContext\r\n     * @return {object}\r\n     */\r\n    function getMaxIndex(rulesContext) {\r\n        const switchRequest = SwitchRequest(context).create();\r\n        const horizon = 4; // Optimization horizon (The amount of steps required to achieve convergence)\r\n        const vl = Math.pow(horizon, 0.99);// Cautiousness parameter, used to control aggressiveness of the bitrate decision process.\r\n        const alpha = Math.max(Math.pow(horizon, 1), vl * Math.sqrt(horizon));// Step size, used for gradient descent exploration granularity\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const mediaType = rulesContext.getMediaType();\r\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\r\n        const bitrateCount = bitrates.length;\r\n        const scheduleController = rulesContext.getScheduleController();\r\n        const streamInfo = rulesContext.getStreamInfo();\r\n        const abrController = rulesContext.getAbrController();\r\n        const throughputHistory = abrController.getThroughputHistory();\r\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\r\n        const useL2AABR = rulesContext.useL2AABR();\r\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\r\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\r\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic); // In kbits/s\r\n        const react = 2; // Reactiveness to volatility (abrupt throughput drops), used to re-calibrate Lagrangian multiplier Q\r\n        const latency = throughputHistory.getAverageLatency(mediaType);\r\n        const videoModel = rulesContext.getVideoModel();\r\n        let quality;\r\n        let currentPlaybackRate = videoModel.getPlaybackRate();\r\n\r\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\r\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\r\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\r\n            return switchRequest;\r\n        }\r\n\r\n        switchRequest.reason = switchRequest.reason || {};\r\n\r\n        if ((!useL2AABR) || (mediaType === Constants.AUDIO)) {// L2A decides bitrate only for video. Audio to be included in decision process in a later stage\r\n            return switchRequest;\r\n        }\r\n\r\n        scheduleController.setTimeToLoadDelay(0);\r\n\r\n        const l2AState = _getL2AState(rulesContext);\r\n\r\n        if (l2AState.state === L2A_STATE_ONE_BITRATE) {\r\n            // shouldn't even have been called\r\n            return switchRequest;\r\n        }\r\n\r\n        const l2AParameter = l2AParameterDict[mediaType];\r\n\r\n        if (!l2AParameter) {\r\n            return switchRequest;\r\n        }\r\n\r\n        switchRequest.reason.state = l2AState.state;\r\n        switchRequest.reason.throughput = throughput;\r\n        switchRequest.reason.latency = latency;\r\n\r\n        if (isNaN(throughput)) {\r\n            // still starting up - not enough information\r\n            return switchRequest;\r\n        }\r\n\r\n        switch (l2AState.state) {\r\n            case L2A_STATE_STARTUP:\r\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);//During strat-up phase abr.controller is responsible for bitrate decisions.\r\n                switchRequest.quality = quality;\r\n                switchRequest.reason.throughput = safeThroughput;\r\n                l2AState.lastQuality = quality;\r\n\r\n                if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AParameter.B_target) {\r\n                    l2AState.state = L2A_STATE_STEADY;\r\n                    l2AParameter.Q = vl;// Initialization of Q langrangian multiplier\r\n                    // Update of probability vector w, to be used in main adaptation logic of L2A below (steady state)\r\n                    for (let i = 0; i < bitrateCount; ++i) {\r\n                        if (i === l2AState.lastQuality) {\r\n                            l2AParameter.prev_w[i] = 1;\r\n                        } else {\r\n                            l2AParameter.prev_w[i] = 0;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                break; // L2A_STATE_STARTUP\r\n            case L2A_STATE_STEADY:\r\n                let diff1 = [];//Used to calculate the difference between consecutive decisions (w-w_prev)\r\n\r\n                // Manual calculation of latency and throughput during previous request\r\n                let throughputMeasureTime = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.d, 0);\r\n                const downloadBytes = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.b[0], 0);\r\n                let lastthroughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\r\n\r\n                if (lastthroughput < 1) {\r\n                    lastthroughput = 1;\r\n                }//To avoid division with 0 (avoid infinity) in case of an absolute network outage\r\n\r\n                let V = l2AState.lastSegmentDurationS;\r\n                let sign = 1;\r\n\r\n                //Main adaptation logic of L2A-LL\r\n                for (let i = 0; i < bitrateCount; ++i) {\r\n                    bitrates[i] = bitrates[i] / 1000; // Originally in bps, now in Kbps\r\n                    if (currentPlaybackRate * bitrates[i] > lastthroughput) {// In this case buffer would deplete, leading to a stall, which increases latency and thus the particular probability of selsection of bitrate[i] should be decreased.\r\n                        sign = -1;\r\n                    }\r\n                    // The objective of L2A is to minimize the overall latency=request-response time + buffer length after download+ potential stalling (if buffer less than chunk downlad time)\r\n                    l2AParameter.w[i] = l2AParameter.prev_w[i] + sign * (V / (2 * alpha)) * ((l2AParameter.Q + vl) * (currentPlaybackRate * bitrates[i] / lastthroughput));//Lagrangian descent\r\n                }\r\n\r\n                // Apply euclidean projection on w to ensure w expresses a probability distribution\r\n                l2AParameter.w = euclideanProjection(l2AParameter.w);\r\n\r\n                for (let i = 0; i < bitrateCount; ++i) {\r\n                    diff1[i] = l2AParameter.w[i] - l2AParameter.prev_w[i];\r\n                    l2AParameter.prev_w[i] = l2AParameter.w[i];\r\n                }\r\n\r\n                // Lagrangian multiplier Q calculation:\r\n                l2AParameter.Q = Math.max(0, l2AParameter.Q - V + V * currentPlaybackRate * ((_dotmultiplication(bitrates, l2AParameter.prev_w) + _dotmultiplication(bitrates, diff1)) / lastthroughput));\r\n\r\n                // Quality is calculated as argmin of the absolute difference between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)).\r\n                let temp = [];\r\n                for (let i = 0; i < bitrateCount; ++i) {\r\n                    temp[i] = Math.abs(bitrates[i] - _dotmultiplication(l2AParameter.w, bitrates));\r\n                }\r\n\r\n                // Quality is calculated based on the probability distribution w (the output of L2A)\r\n                quality = temp.indexOf(Math.min(...temp));\r\n\r\n                // We employ a cautious -stepwise- ascent\r\n                if (quality > l2AState.lastQuality) {\r\n                    if (bitrates[l2AState.lastQuality + 1] <= lastthroughput) {\r\n                        quality = l2AState.lastQuality + 1;\r\n                    }\r\n                }\r\n\r\n                // Provision against bitrate over-estimation, by re-calibrating the Lagrangian multiplier Q, to be taken into account for the next chunk\r\n                if (bitrates[quality] >= lastthroughput) {\r\n                    l2AParameter.Q = react * Math.max(vl, l2AParameter.Q);\r\n                }\r\n\r\n                switchRequest.quality = quality;\r\n                switchRequest.reason.throughput = throughput;\r\n                switchRequest.reason.latency = latency;\r\n                switchRequest.reason.bufferLevel = bufferLevel;\r\n                l2AState.lastQuality = switchRequest.quality;\r\n                break;\r\n            default:\r\n                // should not arrive here, try to recover\r\n                logger.debug('L2A ABR rule invoked in bad state.');\r\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n                switchRequest.reason.state = l2AState.state;\r\n                switchRequest.reason.throughput = safeThroughput;\r\n                switchRequest.reason.latency = latency;\r\n                l2AState.state = L2A_STATE_STARTUP;\r\n                _clearL2AStateOnSeek(l2AState);\r\n        }\r\n        return switchRequest;\r\n    }\r\n\r\n    /**\r\n     * Reset objects to their initial state\r\n     * @private\r\n     */\r\n    function _resetInitialSettings() {\r\n        l2AStateDict = {};\r\n        l2AParameterDict = {};\r\n    }\r\n\r\n    /**\r\n     * Reset the rule\r\n     */\r\n    function reset() {\r\n        _resetInitialSettings();\r\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\r\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\r\n        eventBus.off(Events.METRIC_ADDED, _onMetricAdded, instance);\r\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\r\n    }\r\n\r\n    instance = {\r\n        getMaxIndex: getMaxIndex,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nL2ARule.__dashjs_factory_name = 'L2ARule';\r\nexport default FactoryMaker.getClassFactory(L2ARule);\r\n"]}