{"version":3,"sources":["../../../../../../src/streaming/rules/abr/ABRRulesCollection.js"],"names":["QUALITY_SWITCH_RULES","ABANDON_FRAGMENT_RULES","ABRRulesCollection","config","context","mediaPlayerModel","dashMetrics","settings","instance","qualitySwitchRules","abandonFragmentRules","initialize","get","streaming","abr","useDefaultABRRules","ABRStrategy","Constants","ABR_STRATEGY_L2A","push","create","ABR_STRATEGY_LoLP","customRules","getABRCustomRules","forEach","rule","type","getActiveRules","srArray","filter","sr","quality","SwitchRequest","NO_CHANGE","getMinSwitchRequest","values","newSwitchReq","i","len","req","reason","length","PRIORITY","STRONG","WEAK","DEFAULT","priority","getMaxQuality","rulesContext","switchRequestArray","map","getMaxIndex","activeRules","maxQuality","shouldAbandonFragment","abandonRequestArray","shouldAbandon","reset","rules","getQualitySwitchRules","__dashjs_factory_name","factory","FactoryMaker","getClassFactory","updateSingletonFactory"],"mappings":"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","file":"ABRRulesCollection.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport ThroughputRule from './ThroughputRule';\r\nimport InsufficientBufferRule from './InsufficientBufferRule';\r\nimport AbandonRequestsRule from './AbandonRequestsRule';\r\nimport DroppedFramesRule from './DroppedFramesRule';\r\nimport SwitchHistoryRule from './SwitchHistoryRule';\r\nimport BolaRule from './BolaRule';\r\nimport L2ARule from './L2ARule.js';\r\nimport LoLPRule from './lolp/LoLpRule.js';\r\nimport FactoryMaker from '../../../core/FactoryMaker';\r\nimport SwitchRequest from '../SwitchRequest';\r\nimport Constants from '../../constants/Constants';\r\n\r\nconst QUALITY_SWITCH_RULES = 'qualitySwitchRules';\r\nconst ABANDON_FRAGMENT_RULES = 'abandonFragmentRules';\r\n\r\n\r\nfunction ABRRulesCollection(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const dashMetrics = config.dashMetrics;\r\n    const settings = config.settings;\r\n\r\n    let instance,\r\n        qualitySwitchRules,\r\n        abandonFragmentRules;\r\n\r\n    function initialize() {\r\n        qualitySwitchRules = [];\r\n        abandonFragmentRules = [];\r\n\r\n        if (settings.get().streaming.abr.useDefaultABRRules) {\r\n\r\n            // If L2A is used we only need this one rule\r\n            if (settings.get().streaming.abr.ABRStrategy === Constants.ABR_STRATEGY_L2A) {\r\n                qualitySwitchRules.push(\r\n                    L2ARule(context).create({\r\n                        dashMetrics: dashMetrics,\r\n                        mediaPlayerModel: mediaPlayerModel,\r\n                        settings: settings\r\n                    })\r\n                );\r\n            }\r\n            // If LoLP is used we only need this one rule\r\n            else if (settings.get().streaming.abr.ABRStrategy === Constants.ABR_STRATEGY_LoLP) {\r\n                qualitySwitchRules.push(\r\n                    LoLPRule(context).create({\r\n                        dashMetrics: dashMetrics\r\n                    })\r\n                );\r\n            } else {\r\n                // Only one of BolaRule and ThroughputRule will give a switchRequest.quality !== SwitchRequest.NO_CHANGE.\r\n                // This is controlled by useBufferOccupancyABR mechanism in AbrController.\r\n                qualitySwitchRules.push(\r\n                    BolaRule(context).create({\r\n                        dashMetrics: dashMetrics,\r\n                        mediaPlayerModel: mediaPlayerModel,\r\n                        settings: settings\r\n                    })\r\n                );\r\n\r\n                qualitySwitchRules.push(\r\n                    ThroughputRule(context).create({\r\n                        dashMetrics: dashMetrics\r\n                    })\r\n                );\r\n                qualitySwitchRules.push(\r\n                    InsufficientBufferRule(context).create({\r\n                        dashMetrics: dashMetrics\r\n                    })\r\n                );\r\n                qualitySwitchRules.push(\r\n                    SwitchHistoryRule(context).create()\r\n                );\r\n                qualitySwitchRules.push(\r\n                    DroppedFramesRule(context).create()\r\n                );\r\n\r\n                abandonFragmentRules.push(\r\n                    AbandonRequestsRule(context).create({\r\n                        dashMetrics: dashMetrics,\r\n                        mediaPlayerModel: mediaPlayerModel,\r\n                        settings: settings\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        // add custom ABR rules if any\r\n        const customRules = mediaPlayerModel.getABRCustomRules();\r\n        customRules.forEach(function (rule) {\r\n            if (rule.type === QUALITY_SWITCH_RULES) {\r\n                qualitySwitchRules.push(rule.rule(context).create());\r\n            }\r\n\r\n            if (rule.type === ABANDON_FRAGMENT_RULES) {\r\n                abandonFragmentRules.push(rule.rule(context).create());\r\n            }\r\n        });\r\n    }\r\n\r\n    function getActiveRules(srArray) {\r\n        return srArray.filter(sr => sr.quality > SwitchRequest.NO_CHANGE);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {array} srArray\r\n     * @return {object} SwitchRequest\r\n     */\r\n    function getMinSwitchRequest(srArray) {\r\n        const values = {};\r\n        let newSwitchReq = null;\r\n        let i,\r\n            len,\r\n            req,\r\n            quality,\r\n            reason;\r\n\r\n        if (srArray.length === 0) {\r\n            return;\r\n        }\r\n\r\n        values[SwitchRequest.PRIORITY.STRONG] = { quality: SwitchRequest.NO_CHANGE, reason: null };\r\n        values[SwitchRequest.PRIORITY.WEAK] = { quality: SwitchRequest.NO_CHANGE, reason: null };\r\n        values[SwitchRequest.PRIORITY.DEFAULT] = { quality: SwitchRequest.NO_CHANGE, reason: null };\r\n\r\n        for (i = 0, len = srArray.length; i < len; i += 1) {\r\n            req = srArray[i];\r\n            if (req.quality !== SwitchRequest.NO_CHANGE) {\r\n                // We only use the new quality in case it is lower than the already saved one or if no new quality has been selected for the respective priority\r\n                if (values[req.priority].quality === SwitchRequest.NO_CHANGE || values[req.priority].quality > req.quality) {\r\n                    values[req.priority].quality = req.quality;\r\n                    values[req.priority].reason = req.reason || null;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (values[SwitchRequest.PRIORITY.WEAK].quality !== SwitchRequest.NO_CHANGE) {\r\n            newSwitchReq = values[SwitchRequest.PRIORITY.WEAK];\r\n        }\r\n\r\n        if (values[SwitchRequest.PRIORITY.DEFAULT].quality !== SwitchRequest.NO_CHANGE) {\r\n            newSwitchReq = values[SwitchRequest.PRIORITY.DEFAULT];\r\n        }\r\n\r\n        if (values[SwitchRequest.PRIORITY.STRONG].quality !== SwitchRequest.NO_CHANGE) {\r\n            newSwitchReq = values[SwitchRequest.PRIORITY.STRONG];\r\n        }\r\n\r\n        if (newSwitchReq) {\r\n            quality = newSwitchReq.quality;\r\n            reason = newSwitchReq.reason;\r\n        }\r\n\r\n        return SwitchRequest(context).create(quality, reason);\r\n    }\r\n\r\n    function getMaxQuality(rulesContext) {\r\n        const switchRequestArray = qualitySwitchRules.map(rule => rule.getMaxIndex(rulesContext));\r\n        const activeRules = getActiveRules(switchRequestArray);\r\n        const maxQuality = getMinSwitchRequest(activeRules);\r\n\r\n        return maxQuality || SwitchRequest(context).create();\r\n    }\r\n\r\n    function shouldAbandonFragment(rulesContext) {\r\n        const abandonRequestArray = abandonFragmentRules.map(rule => rule.shouldAbandon(rulesContext));\r\n        const activeRules = getActiveRules(abandonRequestArray);\r\n        const shouldAbandon = getMinSwitchRequest(activeRules);\r\n\r\n        return shouldAbandon || SwitchRequest(context).create();\r\n    }\r\n\r\n    function reset() {\r\n        [qualitySwitchRules, abandonFragmentRules].forEach(rules => {\r\n            if (rules && rules.length) {\r\n                rules.forEach(rule => rule.reset && rule.reset());\r\n            }\r\n        });\r\n        qualitySwitchRules = [];\r\n        abandonFragmentRules = [];\r\n    }\r\n\r\n    function getQualitySwitchRules() {\r\n        return qualitySwitchRules;\r\n    }\r\n\r\n    instance = {\r\n        initialize,\r\n        reset,\r\n        getMaxQuality,\r\n        getMinSwitchRequest,\r\n        shouldAbandonFragment,\r\n        getQualitySwitchRules\r\n    };\r\n\r\n    return instance;\r\n}\r\n\r\nABRRulesCollection.__dashjs_factory_name = 'ABRRulesCollection';\r\nconst factory = FactoryMaker.getClassFactory(ABRRulesCollection);\r\nfactory.QUALITY_SWITCH_RULES = QUALITY_SWITCH_RULES;\r\nfactory.ABANDON_FRAGMENT_RULES = ABANDON_FRAGMENT_RULES;\r\nFactoryMaker.updateSingletonFactory(ABRRulesCollection.__dashjs_factory_name, factory);\r\n\r\nexport default factory;\r\n"]}