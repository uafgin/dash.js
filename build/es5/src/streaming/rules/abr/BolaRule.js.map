{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":["BOLA_STATE_ONE_BITRATE","BOLA_STATE_STARTUP","BOLA_STATE_STEADY","MINIMUM_BUFFER_S","MINIMUM_BUFFER_PER_BITRATE_LEVEL_S","PLACEHOLDER_BUFFER_DECAY","BolaRule","config","context","dashMetrics","mediaPlayerModel","eventBus","getInstance","instance","logger","bolaStateDict","setup","getLogger","resetInitialSettings","on","Events","BUFFER_EMPTY","onBufferEmpty","PLAYBACK_SEEKING","onPlaybackSeeking","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","METRIC_ADDED","onMetricAdded","QUALITY_CHANGE_REQUESTED","onQualityChangeRequested","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","utilitiesFromBitrates","bitrates","map","Math","log","b","calculateBolaParameters","stableBufferTime","utilities","highestUtilityIndex","reduce","highestIndex","u","uIndex","bufferTime","max","length","gp","Vp","getInitialBolaState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrateList","bandwidth","getStableBufferTime","params","state","lastQuality","clearBolaStateOnSeek","bolaState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","checkBolaStateStableBufferTime","mediaType","bufferLevel","getCurrentBufferLevel","effectiveBufferLevel","getBolaState","getMediaType","getQualityFromBufferLevel","bitrateCount","quality","score","i","s","isNaN","maxBufferLevelForQuality","minBufferLevelForQuality","qBitrate","qUtility","min","iBitrate","iUtility","level","updatePlaceholderBuffer","nowMs","Date","now","delay","lastCallTimeMs","hasOwnProperty","e","chunk","type","start","duration","checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","trequest","getTime","_tfinish","bufferAtLastSegmentRequest","maxEffectiveBufferForLastSegment","maxPlaceholderBuffer","abrQuality","newQuality","wantEffectiveBufferLevel","getMaxIndex","switchRequest","create","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","streamId","id","isDynamic","manifestInfo","useBufferOccupancyABR","reason","setTimeToLoadDelay","throughput","getAverageThroughput","safeThroughput","getSafeAverageThroughput","latency","getAverageLatency","getQualityForBitrate","qualityForThroughput","delayS","getTopQualityIndexFor","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2016, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\r\n\r\nimport MetricsConstants from '../../constants/MetricsConstants';\r\nimport SwitchRequest from '../SwitchRequest';\r\nimport FactoryMaker from '../../../core/FactoryMaker';\r\nimport { HTTPRequest } from '../../vo/metrics/HTTPRequest';\r\nimport EventBus from '../../../core/EventBus';\r\nimport Events from '../../../core/events/Events';\r\nimport Debug from '../../../core/Debug';\r\n\r\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\r\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\r\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\r\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\r\nconst BOLA_STATE_ONE_BITRATE    = 0;\r\nconst BOLA_STATE_STARTUP        = 1;\r\nconst BOLA_STATE_STEADY         = 2;\r\n\r\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\r\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\r\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\r\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\r\n\r\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\r\n\r\nfunction BolaRule(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n\r\n    const dashMetrics = config.dashMetrics;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        bolaStateDict;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\r\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\r\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\r\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\r\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\r\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\r\n    }\r\n\r\n    function utilitiesFromBitrates(bitrates) {\r\n        return bitrates.map(b => Math.log(b));\r\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\r\n    }\r\n\r\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\r\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\r\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\r\n\r\n        if (highestUtilityIndex === 0) {\r\n            // if highestUtilityIndex === 0, then always use lowest bitrate\r\n            return null;\r\n        }\r\n\r\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\r\n\r\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\r\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\r\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\r\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\r\n        // giving:\r\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\r\n        const Vp = MINIMUM_BUFFER_S / gp;\r\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\r\n\r\n        return {gp: gp, Vp: Vp};\r\n    }\r\n\r\n    function getInitialBolaState(rulesContext) {\r\n        const initialState = {};\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\r\n        let utilities = utilitiesFromBitrates(bitrates);\r\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\r\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\r\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\r\n\r\n        if (!params) {\r\n            // only happens when there is only one bitrate level\r\n            initialState.state = BOLA_STATE_ONE_BITRATE;\r\n        } else {\r\n            initialState.state = BOLA_STATE_STARTUP;\r\n\r\n            initialState.bitrates = bitrates;\r\n            initialState.utilities = utilities;\r\n            initialState.stableBufferTime = stableBufferTime;\r\n            initialState.Vp = params.Vp;\r\n            initialState.gp = params.gp;\r\n\r\n            initialState.lastQuality = 0;\r\n            clearBolaStateOnSeek(initialState);\r\n        }\r\n\r\n        return initialState;\r\n    }\r\n\r\n    function clearBolaStateOnSeek(bolaState) {\r\n        bolaState.placeholderBuffer = 0;\r\n        bolaState.mostAdvancedSegmentStart = NaN;\r\n        bolaState.lastSegmentWasReplacement = false;\r\n        bolaState.lastSegmentStart = NaN;\r\n        bolaState.lastSegmentDurationS = NaN;\r\n        bolaState.lastSegmentRequestTimeMs = NaN;\r\n        bolaState.lastSegmentFinishTimeMs = NaN;\r\n    }\r\n\r\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\r\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\r\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\r\n        if (bolaState.stableBufferTime !== stableBufferTime) {\r\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\r\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\r\n                // correct placeholder buffer using two criteria:\r\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\r\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\r\n\r\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\r\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\r\n\r\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\r\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\r\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\r\n\r\n                bolaState.stableBufferTime = stableBufferTime;\r\n                bolaState.Vp = params.Vp;\r\n                bolaState.gp = params.gp;\r\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBolaState(rulesContext) {\r\n        const mediaType = rulesContext.getMediaType();\r\n        let bolaState = bolaStateDict[mediaType];\r\n        if (!bolaState) {\r\n            bolaState = getInitialBolaState(rulesContext);\r\n            bolaStateDict[mediaType] = bolaState;\r\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n            checkBolaStateStableBufferTime(bolaState, mediaType);\r\n        }\r\n        return bolaState;\r\n    }\r\n\r\n    // The core idea of BOLA.\r\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\r\n        const bitrateCount = bolaState.bitrates.length;\r\n        let quality = NaN;\r\n        let score = NaN;\r\n        for (let i = 0; i < bitrateCount; ++i) {\r\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\r\n            if (isNaN(score) || s >= score) {\r\n                score = s;\r\n                quality = i;\r\n            }\r\n        }\r\n        return quality;\r\n    }\r\n\r\n    // maximum buffer level which prefers to download at quality rather than wait\r\n    function maxBufferLevelForQuality(bolaState, quality) {\r\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\r\n    }\r\n\r\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\r\n    function minBufferLevelForQuality(bolaState, quality) {\r\n        const qBitrate = bolaState.bitrates[quality];\r\n        const qUtility = bolaState.utilities[quality];\r\n\r\n        let min = 0;\r\n        for (let i = quality - 1; i >= 0; --i) {\r\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\r\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\r\n                const iBitrate = bolaState.bitrates[i];\r\n                const iUtility = bolaState.utilities[i];\r\n\r\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\r\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    /*\r\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\r\n     * There are two main reasons we might want to increase the placeholder buffer:\r\n     *\r\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\r\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\r\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\r\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\r\n     *\r\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\r\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\r\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\r\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\r\n     */\r\n    function updatePlaceholderBuffer(bolaState, mediaType) {\r\n        const nowMs = Date.now();\r\n\r\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\r\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\r\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\r\n            bolaState.placeholderBuffer += Math.max(0, delay);\r\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\r\n            // no download after last call, compensate for delay between calls\r\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\r\n            bolaState.placeholderBuffer += Math.max(0, delay);\r\n        }\r\n\r\n        bolaState.lastCallTimeMs = nowMs;\r\n        bolaState.lastSegmentStart = NaN;\r\n        bolaState.lastSegmentRequestTimeMs = NaN;\r\n        bolaState.lastSegmentFinishTimeMs = NaN;\r\n\r\n        checkBolaStateStableBufferTime(bolaState, mediaType);\r\n    }\r\n\r\n    function onBufferEmpty() {\r\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\r\n        for (const mediaType in bolaStateDict) {\r\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\r\n                bolaStateDict[mediaType].placeholderBuffer = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onPlaybackSeeking() {\r\n        // TODO: 1. Verify what happens if we seek mid-fragment.\r\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\r\n        for (const mediaType in bolaStateDict) {\r\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\r\n                const bolaState = bolaStateDict[mediaType];\r\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\r\n                    clearBolaStateOnSeek(bolaState);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function onMediaFragmentLoaded(e) {\r\n        if (e && e.chunk && e.chunk.mediaInfo) {\r\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                const start = e.chunk.start;\r\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\r\n                    bolaState.mostAdvancedSegmentStart = start;\r\n                    bolaState.lastSegmentWasReplacement = false;\r\n                } else {\r\n                    bolaState.lastSegmentWasReplacement = true;\r\n                }\r\n\r\n                bolaState.lastSegmentStart = start;\r\n                bolaState.lastSegmentDurationS = e.chunk.duration;\r\n                bolaState.lastQuality = e.chunk.quality;\r\n\r\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onMetricAdded(e) {\r\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\r\n            const bolaState = bolaStateDict[e.mediaType];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\r\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\r\n\r\n                checkNewSegment(bolaState, e.mediaType);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\r\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\r\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\r\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\r\n     * decides not to increase the quality to avoid oscillations.\r\n     *\r\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\r\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\r\n     * We avoid this by growing the placeholder buffer.\r\n     */\r\n    function checkNewSegment(bolaState, mediaType) {\r\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\r\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\r\n\r\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\r\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\r\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\r\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\r\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\r\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\r\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\r\n            }\r\n\r\n            // then see if we should grow placeholder buffer\r\n\r\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\r\n                // compensate for segments that were downloaded but did not grow the buffer\r\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\r\n            }\r\n\r\n            bolaState.lastSegmentStart = NaN;\r\n            bolaState.lastSegmentRequestTimeMs = NaN;\r\n        }\r\n    }\r\n\r\n    function onQualityChangeRequested(e) {\r\n        // Useful to store change requests when abandoning a download.\r\n        if (e) {\r\n            const bolaState = bolaStateDict[e.mediaType];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                bolaState.abrQuality = e.newQuality;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onFragmentLoadingAbandoned(e) {\r\n        if (e) {\r\n            const bolaState = bolaStateDict[e.mediaType];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\r\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(e.mediaType);\r\n                let wantEffectiveBufferLevel;\r\n                if (bolaState.abrQuality > 0) {\r\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\r\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\r\n                } else {\r\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\r\n                }\r\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\r\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getMaxIndex(rulesContext) {\r\n        const switchRequest = SwitchRequest(context).create();\r\n\r\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\r\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\r\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useBufferOccupancyABR')) {\r\n            return switchRequest;\r\n        }\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const mediaType = rulesContext.getMediaType();\r\n        const scheduleController = rulesContext.getScheduleController();\r\n        const streamInfo = rulesContext.getStreamInfo();\r\n        const abrController = rulesContext.getAbrController();\r\n        const throughputHistory = abrController.getThroughputHistory();\r\n        const streamId = streamInfo ? streamInfo.id : null;\r\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\r\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\r\n        switchRequest.reason = switchRequest.reason || {};\r\n\r\n        if (!useBufferOccupancyABR) {\r\n            return switchRequest;\r\n        }\r\n\r\n        scheduleController.setTimeToLoadDelay(0);\r\n\r\n        const bolaState = getBolaState(rulesContext);\r\n\r\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\r\n            // shouldn't even have been called\r\n            return switchRequest;\r\n        }\r\n\r\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType);\r\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\r\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\r\n        const latency = throughputHistory.getAverageLatency(mediaType);\r\n        let quality;\r\n\r\n        switchRequest.reason.state = bolaState.state;\r\n        switchRequest.reason.throughput = throughput;\r\n        switchRequest.reason.latency = latency;\r\n\r\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\r\n            // still starting up - not enough information\r\n            return switchRequest;\r\n        }\r\n\r\n        switch (bolaState.state) {\r\n            case BOLA_STATE_STARTUP:\r\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n\r\n                switchRequest.quality = quality;\r\n                switchRequest.reason.throughput = safeThroughput;\r\n\r\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\r\n                bolaState.lastQuality = quality;\r\n\r\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\r\n                    bolaState.state = BOLA_STATE_STEADY;\r\n                }\r\n\r\n                break; // BOLA_STATE_STARTUP\r\n\r\n            case BOLA_STATE_STEADY:\r\n\r\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\r\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\r\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\r\n                //     However, the InsufficientBufferRule takes care of this scenario.\r\n\r\n                updatePlaceholderBuffer(bolaState, mediaType);\r\n\r\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\r\n\r\n                // we want to avoid oscillations\r\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\r\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\r\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\r\n                    // we are only avoid oscillations - do not drop below last quality\r\n\r\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\r\n                }\r\n\r\n                // We do not want to overfill buffer with low quality chunks.\r\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\r\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\r\n\r\n                // First reduce placeholder buffer, then tell schedule controller to pause.\r\n                if (delayS <= bolaState.placeholderBuffer) {\r\n                    bolaState.placeholderBuffer -= delayS;\r\n                    delayS = 0;\r\n                } else {\r\n                    delayS -= bolaState.placeholderBuffer;\r\n                    bolaState.placeholderBuffer = 0;\r\n\r\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\r\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\r\n                        scheduleController.setTimeToLoadDelay(1000 * delayS);\r\n                    } else {\r\n                        delayS = 0;\r\n                    }\r\n                }\r\n\r\n                switchRequest.quality = quality;\r\n                switchRequest.reason.throughput = throughput;\r\n                switchRequest.reason.latency = latency;\r\n                switchRequest.reason.bufferLevel = bufferLevel;\r\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\r\n                switchRequest.reason.delay = delayS;\r\n\r\n                bolaState.lastQuality = quality;\r\n                // keep bolaState.state === BOLA_STATE_STEADY\r\n\r\n                break; // BOLA_STATE_STEADY\r\n\r\n            default:\r\n                logger.debug('BOLA ABR rule invoked in bad state.');\r\n                // should not arrive here, try to recover\r\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n                switchRequest.reason.state = bolaState.state;\r\n                switchRequest.reason.throughput = safeThroughput;\r\n                switchRequest.reason.latency = latency;\r\n                bolaState.state = BOLA_STATE_STARTUP;\r\n                clearBolaStateOnSeek(bolaState);\r\n        }\r\n\r\n        return switchRequest;\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        bolaStateDict = {};\r\n    }\r\n\r\n    function reset() {\r\n        resetInitialSettings();\r\n\r\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\r\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\r\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\r\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\r\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\r\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\r\n    }\r\n\r\n    instance = {\r\n        getMaxIndex: getMaxIndex,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nBolaRule.__dashjs_factory_name = 'BolaRule';\r\nexport default FactoryMaker.getClassFactory(BolaRule);\r\n"]}