{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LearningAbrController.js"],"names":["WEIGHT_SELECTION_MODES","MANUAL","RANDOM","DYNAMIC","LearningAbrController","context","instance","logger","somBitrateNeurons","bitrateNormalizationFactor","latencyNormalizationFactor","minBitrate","minBitrateNeuron","weights","sortedCenters","weightSelectionMode","_setup","getInstance","getLogger","_resetInitialSettings","reset","_getMaxThroughput","maxThroughput","i","length","neuron","state","throughput","_getMagnitude","w","magnitude","map","x","Math","pow","reduce","sum","now","sqrt","_getDistance","a","b","sign","abs","_getNeuronDistance","aState","latency","rebuffer","switch","bState","_updateNeurons","winnerNeuron","somElements","somNeuron","sigma","neuronDistance","neighbourHood","exp","_updateNeuronState","_getDownShiftNeuron","currentNeuron","currentThroughput","maxSuitableBitrate","result","n","bitrate","getNextQuality","mediaInfo","bufferSize","playbackRate","currentQualityIndex","dynamicWeightsSelector","currentLatency","currentBuffer","_getSomBitrateNeurons","throughputNormalized","targetLatency","targetRebufferLevel","targetSwitch","throughputDelta","debug","downloadTime","getSegmentDuration","max","getMinBuffer","qualityIndex","_manualWeightSelection","_randomWeightSelection","_dynamicWeightSelection","minDistance","minIndex","winnerWeights","somNeuronState","somData","distanceWeights","slice","nextBuffer","getNextBufferWithBitrate","isBufferLow","distance","bitrateSwitch","throughputWeight","latencyWeight","bufferWeight","switchWeight","_getXavierWeights","weightVector","findWeightVector","neuronCount","weightCount","W","upperBound","push","random","bitrateList","bitrateVector","bandwidth","forEach","element","_getInitialKmeansPlusPlusCenters","_getRandomData","size","dataArray","data","centers","randomDataSet","k","nextPoint","maxDistance","currentPoint","j","leastSimilarIndex","splice","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"sEAsCA,2D,yDACA,6C,8HAvCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+BA;;;;;GAUA,GAAMA,wBAAyB,CAC3BC,OAAQ,yBADmB,CAE3BC,OAAQ,yBAFmB,CAG3BC,QAAS,0BAHkB,CAA/B,CAMA,QAASC,sBAAT,EAAiC,CAC7B,GAAMC,SAAU,KAAKA,OAArB,CAEA,GAAIC,gBAAJ,CACIC,aADJ,CAEIC,wBAFJ,CAGIC,iCAHJ,CAIIC,iCAJJ,CAKIC,iBALJ,CAMIC,uBANJ,CAOIC,cAPJ,CAQIC,oBARJ,CASIC,0BATJ,CAWA;;OAGA,QAASC,OAAT,EAAkB,CACdT,OAAS,oBAAMF,OAAN,EAAeY,WAAf,GAA6BC,SAA7B,CAAuCZ,QAAvC,CAAT,CACAa,wBACH,CAED;;OAGA,QAASC,MAAT,EAAiB,CACbD,wBACH,CAED;;;OAIA,QAASA,sBAAT,EAAiC,CAC7BX,kBAAoB,IAApB,CACAC,2BAA6B,CAA7B,CACAC,2BAA6B,GAA7B,CACAC,WAAa,CAAb,CACAC,iBAAmB,IAAnB,CACAC,QAAU,IAAV,CACAC,cAAgB,IAAhB,CACAC,oBAAsBf,uBAAuBG,OAA7C,CACH,CAED;;;;OAKA,QAASkB,kBAAT,EAA6B,CACzB,GAAIC,eAAgB,CAApB,CAEA,GAAId,iBAAJ,CAAuB,CACnB,IAAK,GAAIe,GAAI,CAAb,CAAgBA,EAAIf,kBAAkBgB,MAAtC,CAA8CD,GAA9C,CAAmD,CAC/C,GAAIE,QAASjB,kBAAkBe,CAAlB,CAAb,CACA,GAAIE,OAAOC,KAAP,CAAaC,UAAb,CAA0BL,aAA9B,CAA6C,CACzCA,cAAgBG,OAAOC,KAAP,CAAaC,UAA7B,CACH,CACJ,CACJ,CAED,MAAOL,cAAP,CACH,CAED;;;;;OAMA,QAASM,cAAT,CAAuBC,CAAvB,CAA0B,CACtB,GAAMC,WAAYD,EAAEE,GAAF,CAAM,SAACC,CAAD,QAAQC,MAAKC,GAAL,CAASF,CAAT,CAAY,CAAZ,CAAR,EAAN,EAA+BG,MAA/B,CAAsC,SAACC,GAAD,CAAMC,GAAN,QAAcD,KAAMC,GAApB,EAAtC,CAAlB,CAEA,MAAOJ,MAAKK,IAAL,CAAUR,SAAV,CAAP,CACH,CAED;;;;;;;OAQA,QAASS,aAAT,CAAsBC,CAAtB,CAAyBC,CAAzB,CAA4BZ,CAA5B,CAA+B,CAC3B,GAAIO,KAAMI,EACLT,GADK,CACD,SAACC,CAAD,CAAIT,CAAJ,QAAWM,GAAEN,CAAF,EAAQU,KAAKC,GAAL,CAASF,EAAIS,EAAElB,CAAF,CAAb,CAAmB,CAAnB,CAAnB,EADC,CAC2C;AAD3C,CAELY,MAFK,CAEE,SAACC,GAAD,CAAMC,GAAN,QAAcD,KAAMC,GAApB,EAFF,CAAV,CAEsC;AACtC,GAAIK,MAAQN,IAAM,CAAP,CAAY,CAAC,CAAb,CAAiB,CAA5B,CAEA,MAAOM,MAAOT,KAAKK,IAAL,CAAUL,KAAKU,GAAL,CAASP,GAAT,CAAV,CAAd,CACH,CAED;;;;;;OAOA,QAASQ,mBAAT,CAA4BJ,CAA5B,CAA+BC,CAA/B,CAAkC,CAC9B,GAAII,QAAS,CAACL,EAAEd,KAAF,CAAQC,UAAT,CAAqBa,EAAEd,KAAF,CAAQoB,OAA7B,CAAsCN,EAAEd,KAAF,CAAQqB,QAA9C,CAAwDP,EAAEd,KAAF,CAAQsB,MAAhE,CAAb,CACA,GAAIC,QAAS,CAACR,EAAEf,KAAF,CAAQC,UAAT,CAAqBc,EAAEf,KAAF,CAAQoB,OAA7B,CAAsCL,EAAEf,KAAF,CAAQqB,QAA9C,CAAwDN,EAAEf,KAAF,CAAQsB,MAAhE,CAAb,CAEA,MAAOT,cAAaM,MAAb,CAAqBI,MAArB,CAA6B,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAU,CAAV,CAA7B,CAAP,CACH,CAED;;;;;;OAOA,QAASC,eAAT,CAAwBC,YAAxB,CAAsCC,WAAtC,CAAmDpB,CAAnD,CAAsD,CAClD,IAAK,GAAIT,GAAI,CAAb,CAAgBA,EAAI6B,YAAY5B,MAAhC,CAAwCD,GAAxC,CAA6C,CACzC,GAAI8B,WAAYD,YAAY7B,CAAZ,CAAhB,CACA,GAAI+B,OAAQ,GAAZ,CACA,GAAMC,gBAAiBX,mBAAmBS,SAAnB,CAA8BF,YAA9B,CAAvB,CACA,GAAIK,eAAgBvB,KAAKwB,GAAL,CAAS,CAAC,CAAD,CAAKxB,KAAKC,GAAL,CAASqB,cAAT,CAAyB,CAAzB,CAAL,EAAoC,EAAItB,KAAKC,GAAL,CAASoB,KAAT,CAAgB,CAAhB,CAAxC,CAAT,CAApB,CACAI,mBAAmBL,SAAnB,CAA8BrB,CAA9B,CAAiCwB,aAAjC,EACH,CACJ,CAED;;;;;;OAOA,QAASE,mBAAT,CAA4BjC,MAA5B,CAAoCO,CAApC,CAAuCwB,aAAvC,CAAsD,CAClD,GAAI9B,OAAQD,OAAOC,KAAnB,CACA,GAAIG,GAAI,CAAC,IAAD,CAAO,IAAP,CAAa,IAAb,CAAmB,IAAnB,CAAR,CAAkC;AAElCH,MAAMC,UAAN,CAAmBD,MAAMC,UAAN,CAAmB,CAACK,EAAE,CAAF,EAAON,MAAMC,UAAd,EAA4BE,EAAE,CAAF,CAA5B,CAAmC2B,aAAzE,CACA9B,MAAMoB,OAAN,CAAgBpB,MAAMoB,OAAN,CAAgB,CAACd,EAAE,CAAF,EAAON,MAAMoB,OAAd,EAAyBjB,EAAE,CAAF,CAAzB,CAAgC2B,aAAhE,CACA9B,MAAMqB,QAAN,CAAiBrB,MAAMqB,QAAN,CAAiB,CAACf,EAAE,CAAF,EAAON,MAAMqB,QAAd,EAA0BlB,EAAE,CAAF,CAA1B,CAAiC2B,aAAnE,CACA9B,MAAMsB,MAAN,CAAetB,MAAMsB,MAAN,CAAe,CAAChB,EAAE,CAAF,EAAON,MAAMsB,MAAd,EAAwBnB,EAAE,CAAF,CAAxB,CAA+B2B,aAA7D,CACH,CAED;;;;;;OAOA,QAASG,oBAAT,CAA6BC,aAA7B,CAA4CC,iBAA5C,CAA+D,CAC3D,GAAIC,oBAAqB,CAAzB,CACA,GAAIC,QAASH,aAAb,CAEA,GAAIpD,iBAAJ,CAAuB,CACnB,IAAK,GAAIe,GAAI,CAAb,CAAgBA,EAAIf,kBAAkBgB,MAAtC,CAA8CD,GAA9C,CAAmD,CAC/C,GAAIyC,GAAIxD,kBAAkBe,CAAlB,CAAR,CACA,GAAIyC,EAAEC,OAAF,CAAYL,cAAcK,OAA1B,EAAqCD,EAAEC,OAAF,CAAYH,kBAAjD,EAAuED,kBAAoBG,EAAEC,OAAjG,CAA0G,CACtG;AACAH,mBAAqBE,EAAEC,OAAvB,CACAF,OAASC,CAAT,CACH,CACJ,CACJ,CAED,MAAOD,OAAP,CACH,CAED;;;;;;;;;;OAWA,QAASG,eAAT,CAAwBC,SAAxB,CAAmCxC,UAAnC,CAA+CmB,OAA/C,CAAwDsB,UAAxD,CAAoEC,YAApE,CAAkFC,mBAAlF,CAAuGC,sBAAvG,CAA+H,CAC3H;AACA,GAAIC,gBAAiB1B,OAArB,CACA,GAAI2B,eAAgBL,UAApB,CACA,GAAIP,mBAAoBlC,UAAxB,CAEA,GAAIyB,aAAcsB,sBAAsBP,SAAtB,CAAlB,CACA;AACA,GAAIQ,sBAAuBhD,WAAalB,0BAAxC,CACA;AACA,GAAIkE,qBAAuB,CAA3B,CAA8B,CAC1BA,qBAAuBtD,mBAAvB,CACH,CACD;AACAyB,QAAUA,QAAUpC,0BAApB,CAEA,GAAMkE,eAAgB,CAAtB,CACA,GAAMC,qBAAsB,CAA5B,CACA,GAAMC,cAAe,CAArB,CACA;AACA,GAAMC,iBAAkB,KAAxB,CAEAxE,OAAOyE,KAAP,qCAAiDL,oBAAjD,aAAiF7B,OAAjF,gBAAuGsB,UAAvG,yBAAyIE,mBAAzI,kBAA6KD,YAA7K,EAEA,GAAIT,eAAgBR,YAAYkB,mBAAZ,CAApB,CACA,GAAIW,cAAgBrB,cAAcK,OAAd,CAAwBM,uBAAuBW,kBAAvB,EAAzB,CAAwErB,iBAA3F,CACA,GAAId,UAAWd,KAAKkD,GAAL,CAAS,CAAT,CAAaF,aAAeR,aAA5B,CAAf,CAEA;AACA,GAAIA,cAAgBQ,YAAhB,CAA+BV,uBAAuBa,YAAvB,EAAnC,CAA0E,CACtE7E,OAAOyE,KAAP,+BAA2CpB,cAAcK,OAAzD,kBAAiFgB,YAAjF,mBAA+GR,aAA/G,cAAyI1B,QAAzI,EACA,MAAOY,qBAAoBC,aAApB,CAAmCC,iBAAnC,EAAsDwB,YAA7D,CACH,CAED,OAAQtE,mBAAR,EACI,IAAKf,wBAAuBC,MAA5B,CACIqF,yBACA,MACJ,IAAKtF,wBAAuBE,MAA5B,CACIqF,uBAAuBnC,WAAvB,EACA,MACJ,IAAKpD,wBAAuBG,OAA5B,CACIqF,wBAAwBjB,sBAAxB,CAAgDnB,WAAhD,CAA6DoB,cAA7D,CAA6EC,aAA7E,CAA4F1B,QAA5F,CAAsGc,iBAAtG,CAAyHQ,YAAzH,EACA,MACJ,QACImB,wBAAwBjB,sBAAxB,CAAgDnB,WAAhD,CAA6DoB,cAA7D,CAA6EC,aAA7E,CAA4F1B,QAA5F,CAAsGc,iBAAtG,CAAyHQ,YAAzH,EAXR,CAeA,GAAIoB,aAAc,IAAlB,CACA,GAAIC,UAAW,IAAf,CACA,GAAIvC,cAAe,IAAnB,CACA,GAAIwC,eAAgB,IAApB,CAEA,IAAK,GAAIpE,GAAI,CAAb,CAAgBA,EAAI6B,YAAY5B,MAAhC,CAAwCD,GAAxC,CAA6C,CACzC,GAAI8B,WAAYD,YAAY7B,CAAZ,CAAhB,CACA,GAAIqE,gBAAiBvC,UAAU3B,KAA/B,CACA,GAAImE,SAAU,CAACD,eAAejE,UAAhB,CACViE,eAAe9C,OADL,CAEV8C,eAAe7C,QAFL,CAGV6C,eAAe5C,MAHL,CAAd,CAKA,GAAI8C,iBAAkBjF,QAAQkF,KAAR,EAAtB,CACA,GAAIC,YAAazB,uBAAuB0B,wBAAvB,CAAgD5C,UAAUY,OAA1D,CAAmEQ,aAAnE,CAAkFZ,iBAAlF,CAAjB,CACA,GAAIqC,aAAcF,WAAazB,uBAAuBa,YAAvB,EAA/B,CACA,GAAIc,WAAJ,CAAiB,CACb3F,OAAOyE,KAAP,8BAA0C3B,UAAUY,OAApD,kBAA4EgB,YAA5E,mBAA0GR,aAA1G,gBAAsIuB,UAAtI,EACH,CACD;AACA,GAAI3C,UAAUY,OAAV,CAAoBtC,WAAaoD,eAAjC,EAAoDmB,WAAxD,CAAqE,CACjE,GAAI7C,UAAUY,OAAV,GAAsBtD,UAA1B,CAAsC,CAClC;AACAmF,gBAAgB,CAAhB,EAAqB,GAArB,CACH,CACJ,CAED;AACA,GAAIK,UAAW5D,aAAasD,OAAb,CAAsB,CAAClB,oBAAD,CAAuBC,aAAvB,CAAsCC,mBAAtC,CAA2DC,YAA3D,CAAtB,CAAgGgB,eAAhG,CAAf,CACA,GAAIL,cAAgB,IAAhB,EAAwBU,SAAWV,WAAvC,CAAoD,CAChDA,YAAcU,QAAd,CACAT,SAAWrC,UAAUgC,YAArB,CACAlC,aAAeE,SAAf,CACAsC,cAAgBG,eAAhB,CACH,CACJ,CAED;AACA;AACA,GAAIM,eAAgBnE,KAAKU,GAAL,CAASiB,cAAcK,OAAd,CAAwBd,aAAac,OAA9C,EAAyDxD,0BAA7E,CACAyC,eAAeU,aAAf,CAA8BR,WAA9B,CAA2C,CAACuB,oBAAD,CAAuB7B,OAAvB,CAAgCC,QAAhC,CAA0CqD,aAA1C,CAA3C,EAEA;AACAlD,eAAeC,YAAf,CAA6BC,WAA7B,CAA0C,CAACuB,oBAAD,CAAuBC,aAAvB,CAAsCC,mBAAtC,CAA2DuB,aAA3D,CAA1C,EAEA,MAAOV,SAAP,CACH,CAED;;;OAIA,QAASJ,uBAAT,EAAkC,CAC9B,GAAIe,kBAAmB,GAAvB,CACA,GAAIC,eAAgB,GAApB,CACA,GAAIC,cAAe,GAAnB,CACA,GAAIC,cAAe,GAAnB,CAEA3F,QAAU,CAACwF,gBAAD,CAAmBC,aAAnB,CAAkCC,YAAlC,CAAgDC,YAAhD,CAAV,CAAyE;AAC5E,CAED;;;;OAKA,QAASjB,uBAAT,CAAgCnC,WAAhC,CAA6C,CACzCvC,QAAU4F,kBAAkBrD,YAAY5B,MAA9B,CAAsC,CAAtC,CAAV,CACH,CAED;;;;;;;;;;OAWA,QAASgE,wBAAT,CAAiCjB,sBAAjC,CAAyDnB,WAAzD,CAAsEoB,cAAtE,CAAsFC,aAAtF,CAAqG1B,QAArG,CAA+Gc,iBAA/G,CAAkIQ,YAAlI,CAAgJ,CAC5I,GAAI,CAACxD,OAAL,CAAc,CACVA,QAAUC,cAAcA,cAAcU,MAAd,CAAuB,CAArC,CAAV,CACH,CACD;AACA,GAAIkF,cAAenC,uBAAuBoC,gBAAvB,CAAwCvD,WAAxC,CAAqDoB,cAArD,CAAqEC,aAArE,CAAoF1B,QAApF,CAA8Fc,iBAA9F,CAAiHQ,YAAjH,CAAnB,CACA,GAAIqC,eAAiB,IAAjB,EAAyBA,eAAiB,CAAC,CAA/C,CAAkD,CAAI;AAClD7F,QAAU6F,YAAV,CACH,CACJ,CAED;;;;;;OAOA,QAASD,kBAAT,CAA2BG,WAA3B,CAAwCC,WAAxC,CAAqD,CACjD,GAAIC,GAAI,EAAR,CACA,GAAIC,YAAa9E,KAAKK,IAAL,CAAW,EAAIsE,WAAf,CAAjB,CAEA,IAAK,GAAIrF,GAAI,CAAb,CAAgBA,EAAIsF,WAApB,CAAiCtF,GAAjC,CAAsC,CAClCuF,EAAEE,IAAF,CAAO/E,KAAKgF,MAAL,GAAgBF,UAAvB,EACH,CAEDlG,QAAUiG,CAAV,CAEA,MAAOjG,QAAP,CACH,CAED;;;;;OAMA,QAAS6D,sBAAT,CAA+BP,SAA/B,CAA0C,CACtC,GAAI,CAAC3D,iBAAL,CAAwB,CACpBA,kBAAoB,EAApB,CACA,GAAM0G,aAAc/C,UAAU+C,WAA9B,CACA,GAAIC,eAAgB,EAApB,CACAxG,WAAauG,YAAY,CAAZ,EAAeE,SAA5B,CAEAF,YAAYG,OAAZ,CAAoB,iBAAW,CAC3BF,cAAcH,IAAd,CAAmBM,QAAQF,SAA3B,EACA,GAAIE,QAAQF,SAAR,CAAoBzG,UAAxB,CAAoC,CAChCA,WAAa2G,QAAQF,SAArB,CACH,CACJ,CALD,EAMA3G,2BAA6BmB,cAAcuF,aAAd,CAA7B,CAEA,IAAK,GAAI5F,GAAI,CAAb,CAAgBA,EAAI2F,YAAY1F,MAAhC,CAAwCD,GAAxC,CAA6C,CACzC,GAAIE,QAAS,CACT4D,aAAc9D,CADL,CAET0C,QAASiD,YAAY3F,CAAZ,EAAe6F,SAFf,CAGT1F,MAAO,CACH;AACAC,WAAYuF,YAAY3F,CAAZ,EAAe6F,SAAf,CAA2B3G,0BAFpC,CAGHqC,QAAS,CAHN,CAIHC,SAAU,CAJP,CAKHC,OAAQ,CALL,CAHE,CAAb,CAWAxC,kBAAkBwG,IAAlB,CAAuBvF,MAAvB,EACA,GAAIA,OAAOwC,OAAP,GAAmBtD,UAAvB,CAAmC,CAC/BC,iBAAmBa,MAAnB,CACH,CACJ,CAEDX,cAAgByG,iCAAiC/G,iBAAjC,CAAhB,CACH,CAED,MAAOA,kBAAP,CACH,CAED;;;;;OAMA,QAASgH,eAAT,CAAwBC,IAAxB,CAA8B,CAC1B,GAAIC,WAAY,EAAhB,CAEA,IAAK,GAAInG,GAAI,CAAb,CAAgBA,EAAIkG,IAApB,CAA0BlG,GAA1B,CAA+B,CAC3B,GAAIoG,MAAO,CACP1F,KAAKgF,MAAL,GAAgB5F,mBADT,CAC8B;AACrCY,KAAKgF,MAAL,EAFO,CAEQ;AACfhF,KAAKgF,MAAL,EAHO,CAGQ;AACfhF,KAAKgF,MAAL,EAAc;AAJP,CAAX,CAMAS,UAAUV,IAAV,CAAeW,IAAf,EACH,CAED,MAAOD,UAAP,CACH,CAED;;;;;OAMA,QAASH,iCAAT,CAA0CnE,WAA1C,CAAuD,CACnD,GAAIwE,SAAU,EAAd,CACA,GAAIC,eAAgBL,eAAevF,KAAKC,GAAL,CAASkB,YAAY5B,MAArB,CAA6B,CAA7B,CAAf,CAApB,CACAoG,QAAQZ,IAAR,CAAaa,cAAc,CAAd,CAAb,EACA,GAAI/B,iBAAkB,CAAC,CAAD,CAAI,CAAJ,CAAO,CAAP,CAAU,CAAV,CAAtB,CAEA,IAAK,GAAIgC,GAAI,CAAb,CAAgBA,EAAI1E,YAAY5B,MAAhC,CAAwCsG,GAAxC,CAA6C,CACzC,GAAIC,WAAY,IAAhB,CACA,GAAIC,cAAc,IAAlB,CACA,IAAK,GAAIzG,GAAI,CAAb,CAAgBA,EAAIsG,cAAcrG,MAAlC,CAA0CD,GAA1C,CAA+C,CAC3C,GAAI0G,cAAeJ,cAActG,CAAd,CAAnB,CACA,GAAIkE,aAAc,IAAlB,CACA,IAAK,GAAIyC,GAAI,CAAb,CAAgBA,EAAIN,QAAQpG,MAA5B,CAAoC0G,GAApC,CAAyC,CACrC,GAAI/B,UAAW5D,aAAa0F,YAAb,CAA2BL,QAAQM,CAAR,CAA3B,CAAuCpC,eAAvC,CAAf,CACA,GAAIL,cAAgB,IAAhB,EAAwBU,SAAWV,WAAvC,CAAoD,CAChDA,YAAcU,QAAd,CACH,CACJ,CACD,GAAI6B,eAAgB,IAAhB,EAAwBvC,YAAcuC,YAA1C,CAAuD,CACnDD,UAAYE,YAAZ,CACAD,aAAcvC,WAAd,CACH,CACJ,CACDmC,QAAQZ,IAAR,CAAae,SAAb,EACH,CAED;AACA,GAAIC,aAAc,IAAlB,CACA,GAAIG,mBAAoB,IAAxB,CACA,IAAK,GAAI5G,IAAI,CAAb,CAAgBA,GAAIqG,QAAQpG,MAA5B,CAAoCD,IAApC,CAAyC,CACrC,GAAI4E,WAAW,CAAf,CACA,IAAK,GAAI+B,IAAI,CAAb,CAAgBA,GAAIN,QAAQpG,MAA5B,CAAoC0G,IAApC,CAAyC,CACrC,GAAI3G,KAAM2G,EAAV,CAAa,SACb/B,WAAY5D,aAAaqF,QAAQrG,EAAR,CAAb,CAAyBqG,QAAQM,EAAR,CAAzB,CAAqCpC,eAArC,CAAZ,CACH,CACD,GAAIkC,cAAgB,IAAhB,EAAwB7B,UAAW6B,WAAvC,CAAoD,CAChDA,YAAc7B,SAAd,CACAgC,kBAAoB5G,EAApB,CACH,CACJ,CAED;AACA,GAAIT,eAAgB,EAApB,CACAA,cAAckG,IAAd,CAAmBY,QAAQO,iBAAR,CAAnB,EACAP,QAAQQ,MAAR,CAAeD,iBAAf,CAAkC,CAAlC,EACA,MAAOP,QAAQpG,MAAR,CAAiB,CAAxB,CAA2B,CACvB,GAAIiE,cAAc,IAAlB,CACA,GAAIC,UAAW,IAAf,CACA,IAAK,GAAInE,KAAI,CAAb,CAAgBA,IAAIqG,QAAQpG,MAA5B,CAAoCD,KAApC,CAAyC,CACrC,GAAI4E,YAAW5D,aAAazB,cAAc,CAAd,CAAb,CAA+B8G,QAAQrG,GAAR,CAA/B,CAA2CuE,eAA3C,CAAf,CACA,GAAIL,eAAgB,IAAhB,EAAwBU,WAAWV,YAAvC,CAAoD,CAChDA,aAAcU,UAAd,CACAT,SAAWnE,GAAX,CACH,CACJ,CACDT,cAAckG,IAAd,CAAmBY,QAAQlC,QAAR,CAAnB,EACAkC,QAAQQ,MAAR,CAAe1C,QAAf,CAAyB,CAAzB,EACH,CAED,MAAO5E,cAAP,CACH,CAEDR,SAAW,CACP4D,6BADO,CAEP9C,WAFO,CAAX,CAKAJ,SACA,MAAOV,SAAP,CACH,CAEDF,sBAAsBiI,qBAAtB,CAA8C,uBAA9C,C,gBACeC,uBAAaC,eAAb,CAA6BnI,qBAA7B,C","file":"LearningAbrController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * Authors:\r\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\r\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\r\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\r\n */\r\n\r\nimport FactoryMaker from '../../../../core/FactoryMaker';\r\nimport Debug from '../../../../core/Debug';\r\n\r\nconst WEIGHT_SELECTION_MODES = {\r\n    MANUAL: 'manual_weight_selection',\r\n    RANDOM: 'random_weight_selection',\r\n    DYNAMIC: 'dynamic_weight_selection'\r\n};\r\n\r\nfunction LearningAbrController() {\r\n    const context = this.context;\r\n\r\n    let instance,\r\n        logger,\r\n        somBitrateNeurons,\r\n        bitrateNormalizationFactor,\r\n        latencyNormalizationFactor,\r\n        minBitrate,\r\n        minBitrateNeuron,\r\n        weights,\r\n        sortedCenters,\r\n        weightSelectionMode;\r\n\r\n    /**\r\n     * Setup the class\r\n     */\r\n    function _setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        _resetInitialSettings();\r\n    }\r\n\r\n    /**\r\n     * Reset all values\r\n     */\r\n    function reset() {\r\n        _resetInitialSettings();\r\n    }\r\n\r\n    /**\r\n     * Reset to initial settings\r\n     * @private\r\n     */\r\n    function _resetInitialSettings() {\r\n        somBitrateNeurons = null;\r\n        bitrateNormalizationFactor = 1;\r\n        latencyNormalizationFactor = 100;\r\n        minBitrate = 0;\r\n        minBitrateNeuron = null;\r\n        weights = null;\r\n        sortedCenters = null;\r\n        weightSelectionMode = WEIGHT_SELECTION_MODES.DYNAMIC;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum throughput\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    function _getMaxThroughput() {\r\n        let maxThroughput = 0;\r\n\r\n        if (somBitrateNeurons) {\r\n            for (let i = 0; i < somBitrateNeurons.length; i++) {\r\n                let neuron = somBitrateNeurons[i];\r\n                if (neuron.state.throughput > maxThroughput) {\r\n                    maxThroughput = neuron.state.throughput;\r\n                }\r\n            }\r\n        }\r\n\r\n        return maxThroughput;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {array} w\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    function _getMagnitude(w) {\r\n        const magnitude = w.map((x) => (Math.pow(x, 2))).reduce((sum, now) => sum + now);\r\n\r\n        return Math.sqrt(magnitude);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {array} a\r\n     * @param {array} b\r\n     * @param {array} w\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    function _getDistance(a, b, w) {\r\n        let sum = a\r\n            .map((x, i) => (w[i] * (Math.pow(x - b[i], 2)))) // square the difference*w\r\n            .reduce((sum, now) => sum + now); // sum\r\n        let sign = (sum < 0) ? -1 : 1;\r\n\r\n        return sign * Math.sqrt(Math.abs(sum));\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {object} a\r\n     * @param {object} b\r\n     * @return {number}\r\n     * @private\r\n     */\r\n    function _getNeuronDistance(a, b) {\r\n        let aState = [a.state.throughput, a.state.latency, a.state.rebuffer, a.state.switch];\r\n        let bState = [b.state.throughput, b.state.latency, b.state.rebuffer, b.state.switch];\r\n\r\n        return _getDistance(aState, bState, [1, 1, 1, 1]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {object} winnerNeuron\r\n     * @param {array} somElements\r\n     * @param {array} x\r\n     * @private\r\n     */\r\n    function _updateNeurons(winnerNeuron, somElements, x) {\r\n        for (let i = 0; i < somElements.length; i++) {\r\n            let somNeuron = somElements[i];\r\n            let sigma = 0.1;\r\n            const neuronDistance = _getNeuronDistance(somNeuron, winnerNeuron);\r\n            let neighbourHood = Math.exp(-1 * Math.pow(neuronDistance, 2) / (2 * Math.pow(sigma, 2)));\r\n            _updateNeuronState(somNeuron, x, neighbourHood);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {object} neuron\r\n     * @param {array} x\r\n     * @param {object} neighbourHood\r\n     * @private\r\n     */\r\n    function _updateNeuronState(neuron, x, neighbourHood) {\r\n        let state = neuron.state;\r\n        let w = [0.01, 0.01, 0.01, 0.01]; // learning rate\r\n\r\n        state.throughput = state.throughput + (x[0] - state.throughput) * w[0] * neighbourHood;\r\n        state.latency = state.latency + (x[1] - state.latency) * w[1] * neighbourHood;\r\n        state.rebuffer = state.rebuffer + (x[2] - state.rebuffer) * w[2] * neighbourHood;\r\n        state.switch = state.switch + (x[3] - state.switch) * w[3] * neighbourHood;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {object} currentNeuron\r\n     * @param {number} currentThroughput\r\n     * @return {object}\r\n     * @private\r\n     */\r\n    function _getDownShiftNeuron(currentNeuron, currentThroughput) {\r\n        let maxSuitableBitrate = 0;\r\n        let result = currentNeuron;\r\n\r\n        if (somBitrateNeurons) {\r\n            for (let i = 0; i < somBitrateNeurons.length; i++) {\r\n                let n = somBitrateNeurons[i];\r\n                if (n.bitrate < currentNeuron.bitrate && n.bitrate > maxSuitableBitrate && currentThroughput > n.bitrate) {\r\n                    // possible downshiftable neuron\r\n                    maxSuitableBitrate = n.bitrate;\r\n                    result = n;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {object} mediaInfo\r\n     * @param {number} throughput\r\n     * @param {number} latency\r\n     * @param {number} bufferSize\r\n     * @param {number} playbackRate\r\n     * @param {number} currentQualityIndex\r\n     * @param {object} dynamicWeightsSelector\r\n     * @return {null|*}\r\n     */\r\n    function getNextQuality(mediaInfo, throughput, latency, bufferSize, playbackRate, currentQualityIndex, dynamicWeightsSelector) {\r\n        // For Dynamic Weights Selector\r\n        let currentLatency = latency;\r\n        let currentBuffer = bufferSize;\r\n        let currentThroughput = throughput;\r\n\r\n        let somElements = _getSomBitrateNeurons(mediaInfo);\r\n        // normalize throughput\r\n        let throughputNormalized = throughput / bitrateNormalizationFactor;\r\n        // saturate values higher than 1\r\n        if (throughputNormalized > 1) {\r\n            throughputNormalized = _getMaxThroughput();\r\n        }\r\n        // normalize latency\r\n        latency = latency / latencyNormalizationFactor;\r\n\r\n        const targetLatency = 0;\r\n        const targetRebufferLevel = 0;\r\n        const targetSwitch = 0;\r\n        // 10K + video encoding is the recommended throughput\r\n        const throughputDelta = 10000;\r\n\r\n        logger.debug(`getNextQuality called throughput:${throughputNormalized} latency:${latency} bufferSize:${bufferSize} currentQualityIndex:${currentQualityIndex} playbackRate:${playbackRate}`);\r\n\r\n        let currentNeuron = somElements[currentQualityIndex];\r\n        let downloadTime = (currentNeuron.bitrate * dynamicWeightsSelector.getSegmentDuration()) / currentThroughput;\r\n        let rebuffer = Math.max(0, (downloadTime - currentBuffer));\r\n\r\n        // check buffer for possible stall\r\n        if (currentBuffer - downloadTime < dynamicWeightsSelector.getMinBuffer()) {\r\n            logger.debug(`Buffer is low for bitrate= ${currentNeuron.bitrate} downloadTime=${downloadTime} currentBuffer=${currentBuffer} rebuffer=${rebuffer}`);\r\n            return _getDownShiftNeuron(currentNeuron, currentThroughput).qualityIndex;\r\n        }\r\n\r\n        switch (weightSelectionMode) {\r\n            case WEIGHT_SELECTION_MODES.MANUAL:\r\n                _manualWeightSelection();\r\n                break;\r\n            case WEIGHT_SELECTION_MODES.RANDOM:\r\n                _randomWeightSelection(somElements);\r\n                break;\r\n            case WEIGHT_SELECTION_MODES.DYNAMIC:\r\n                _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\r\n                break;\r\n            default:\r\n                _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\r\n\r\n        }\r\n\r\n        let minDistance = null;\r\n        let minIndex = null;\r\n        let winnerNeuron = null;\r\n        let winnerWeights = null;\r\n\r\n        for (let i = 0; i < somElements.length; i++) {\r\n            let somNeuron = somElements[i];\r\n            let somNeuronState = somNeuron.state;\r\n            let somData = [somNeuronState.throughput,\r\n                somNeuronState.latency,\r\n                somNeuronState.rebuffer,\r\n                somNeuronState.switch];\r\n\r\n            let distanceWeights = weights.slice();\r\n            let nextBuffer = dynamicWeightsSelector.getNextBufferWithBitrate(somNeuron.bitrate, currentBuffer, currentThroughput);\r\n            let isBufferLow = nextBuffer < dynamicWeightsSelector.getMinBuffer();\r\n            if (isBufferLow) {\r\n                logger.debug(`Buffer is low for bitrate=${somNeuron.bitrate} downloadTime=${downloadTime} currentBuffer=${currentBuffer} nextBuffer=${nextBuffer}`);\r\n            }\r\n            // special condition downshift immediately\r\n            if (somNeuron.bitrate > throughput - throughputDelta || isBufferLow) {\r\n                if (somNeuron.bitrate !== minBitrate) {\r\n                    // encourage to pick smaller bitrates throughputWeight=100\r\n                    distanceWeights[0] = 100;\r\n                }\r\n            }\r\n\r\n            // calculate the distance with the target\r\n            let distance = _getDistance(somData, [throughputNormalized, targetLatency, targetRebufferLevel, targetSwitch], distanceWeights);\r\n            if (minDistance === null || distance < minDistance) {\r\n                minDistance = distance;\r\n                minIndex = somNeuron.qualityIndex;\r\n                winnerNeuron = somNeuron;\r\n                winnerWeights = distanceWeights;\r\n            }\r\n        }\r\n\r\n        // update current neuron and the neighbourhood with the calculated QoE\r\n        // will punish current if it is not picked\r\n        let bitrateSwitch = Math.abs(currentNeuron.bitrate - winnerNeuron.bitrate) / bitrateNormalizationFactor;\r\n        _updateNeurons(currentNeuron, somElements, [throughputNormalized, latency, rebuffer, bitrateSwitch]);\r\n\r\n        // update bmu and  neighbours with targetQoE=1, targetLatency=0\r\n        _updateNeurons(winnerNeuron, somElements, [throughputNormalized, targetLatency, targetRebufferLevel, bitrateSwitch]);\r\n\r\n        return minIndex;\r\n    }\r\n\r\n    /**\r\n     * Option 1: Manual weights\r\n     * @private\r\n     */\r\n    function _manualWeightSelection() {\r\n        let throughputWeight = 0.4;\r\n        let latencyWeight = 0.4;\r\n        let bufferWeight = 0.4;\r\n        let switchWeight = 0.4;\r\n\r\n        weights = [throughputWeight, latencyWeight, bufferWeight, switchWeight]; // throughput, latency, buffer, switch\r\n    }\r\n\r\n    /**\r\n     * Option 2: Random (Xavier) weights\r\n     * @param {array} somElements\r\n     * @private\r\n     */\r\n    function _randomWeightSelection(somElements) {\r\n        weights = _getXavierWeights(somElements.length, 4);\r\n    }\r\n\r\n    /**\r\n     * Dynamic Weight Selector weights\r\n     * @param {object} dynamicWeightsSelector\r\n     * @param {array} somElements\r\n     * @param {number} currentLatency\r\n     * @param {number} currentBuffer\r\n     * @param {number} rebuffer\r\n     * @param {number} currentThroughput\r\n     * @param {number} playbackRate\r\n     * @private\r\n     */\r\n    function _dynamicWeightSelection(dynamicWeightsSelector, somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate) {\r\n        if (!weights) {\r\n            weights = sortedCenters[sortedCenters.length - 1];\r\n        }\r\n        // Dynamic Weights Selector (step 2/2: find weights)\r\n        let weightVector = dynamicWeightsSelector.findWeightVector(somElements, currentLatency, currentBuffer, rebuffer, currentThroughput, playbackRate);\r\n        if (weightVector !== null && weightVector !== -1) {   // null: something went wrong, -1: constraints not met\r\n            weights = weightVector;\r\n        }\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number }neuronCount\r\n     * @param {number }weightCount\r\n     * @return {array}\r\n     * @private\r\n     */\r\n    function _getXavierWeights(neuronCount, weightCount) {\r\n        let W = [];\r\n        let upperBound = Math.sqrt((2 / neuronCount));\r\n\r\n        for (let i = 0; i < weightCount; i++) {\r\n            W.push(Math.random() * upperBound);\r\n        }\r\n\r\n        weights = W;\r\n\r\n        return weights;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {object} mediaInfo\r\n     * @return {array}\r\n     * @private\r\n     */\r\n    function _getSomBitrateNeurons(mediaInfo) {\r\n        if (!somBitrateNeurons) {\r\n            somBitrateNeurons = [];\r\n            const bitrateList = mediaInfo.bitrateList;\r\n            let bitrateVector = [];\r\n            minBitrate = bitrateList[0].bandwidth;\r\n\r\n            bitrateList.forEach(element => {\r\n                bitrateVector.push(element.bandwidth);\r\n                if (element.bandwidth < minBitrate) {\r\n                    minBitrate = element.bandwidth;\r\n                }\r\n            });\r\n            bitrateNormalizationFactor = _getMagnitude(bitrateVector);\r\n\r\n            for (let i = 0; i < bitrateList.length; i++) {\r\n                let neuron = {\r\n                    qualityIndex: i,\r\n                    bitrate: bitrateList[i].bandwidth,\r\n                    state: {\r\n                        // normalize throughputs\r\n                        throughput: bitrateList[i].bandwidth / bitrateNormalizationFactor,\r\n                        latency: 0,\r\n                        rebuffer: 0,\r\n                        switch: 0\r\n                    }\r\n                };\r\n                somBitrateNeurons.push(neuron);\r\n                if (neuron.bitrate === minBitrate) {\r\n                    minBitrateNeuron = neuron;\r\n                }\r\n            }\r\n\r\n            sortedCenters = _getInitialKmeansPlusPlusCenters(somBitrateNeurons);\r\n        }\r\n\r\n        return somBitrateNeurons;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} size\r\n     * @return {array}\r\n     * @private\r\n     */\r\n    function _getRandomData(size) {\r\n        let dataArray = [];\r\n\r\n        for (let i = 0; i < size; i++) {\r\n            let data = [\r\n                Math.random() * _getMaxThroughput(), //throughput\r\n                Math.random(), //latency\r\n                Math.random(), //buffersize\r\n                Math.random() //switch\r\n            ];\r\n            dataArray.push(data);\r\n        }\r\n\r\n        return dataArray;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {array} somElements\r\n     * @return {array}\r\n     * @private\r\n     */\r\n    function _getInitialKmeansPlusPlusCenters(somElements) {\r\n        let centers = [];\r\n        let randomDataSet = _getRandomData(Math.pow(somElements.length, 2));\r\n        centers.push(randomDataSet[0]);\r\n        let distanceWeights = [1, 1, 1, 1];\r\n\r\n        for (let k = 1; k < somElements.length; k++) {\r\n            let nextPoint = null;\r\n            let maxDistance = null;\r\n            for (let i = 0; i < randomDataSet.length; i++) {\r\n                let currentPoint = randomDataSet[i];\r\n                let minDistance = null;\r\n                for (let j = 0; j < centers.length; j++) {\r\n                    let distance = _getDistance(currentPoint, centers[j], distanceWeights);\r\n                    if (minDistance === null || distance < minDistance) {\r\n                        minDistance = distance;\r\n                    }\r\n                }\r\n                if (maxDistance === null || minDistance > maxDistance) {\r\n                    nextPoint = currentPoint;\r\n                    maxDistance = minDistance;\r\n                }\r\n            }\r\n            centers.push(nextPoint);\r\n        }\r\n\r\n        // find the least similar center\r\n        let maxDistance = null;\r\n        let leastSimilarIndex = null;\r\n        for (let i = 0; i < centers.length; i++) {\r\n            let distance = 0;\r\n            for (let j = 0; j < centers.length; j++) {\r\n                if (i === j) continue;\r\n                distance += _getDistance(centers[i], centers[j], distanceWeights);\r\n            }\r\n            if (maxDistance === null || distance > maxDistance) {\r\n                maxDistance = distance;\r\n                leastSimilarIndex = i;\r\n            }\r\n        }\r\n\r\n        // move centers to sortedCenters\r\n        let sortedCenters = [];\r\n        sortedCenters.push(centers[leastSimilarIndex]);\r\n        centers.splice(leastSimilarIndex, 1);\r\n        while (centers.length > 0) {\r\n            let minDistance = null;\r\n            let minIndex = null;\r\n            for (let i = 0; i < centers.length; i++) {\r\n                let distance = _getDistance(sortedCenters[0], centers[i], distanceWeights);\r\n                if (minDistance === null || distance < minDistance) {\r\n                    minDistance = distance;\r\n                    minIndex = i;\r\n                }\r\n            }\r\n            sortedCenters.push(centers[minIndex]);\r\n            centers.splice(minIndex, 1);\r\n        }\r\n\r\n        return sortedCenters;\r\n    }\r\n\r\n    instance = {\r\n        getNextQuality,\r\n        reset\r\n    };\r\n\r\n    _setup();\r\n    return instance;\r\n}\r\n\r\nLearningAbrController.__dashjs_factory_name = 'LearningAbrController';\r\nexport default FactoryMaker.getClassFactory(LearningAbrController);\r\n"]}