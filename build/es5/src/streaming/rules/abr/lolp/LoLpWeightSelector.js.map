{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpWeightSelector.js"],"names":["LoLpWeightSelector","config","targetLatency","bufferMin","segmentDuration","qoeEvaluator","instance","valueList","weightTypeCount","weightOptions","previousLatency","_setup","_resetInitialSettings","_getPermutations","findWeightVector","neurons","currentLatency","currentBuffer","currentRebuffer","currentThroughput","playbackRate","maxQoE","winnerWeights","winnerBitrate","deltaLatency","Math","abs","forEach","neuron","weightVector","weightsObj","throughput","latency","buffer","switch","downloadTime","bitrate","nextBuffer","getNextBuffer","rebuffer","max","wt","weightedRebuffer","weightedLatency","state","totalQoE","calculateSingleUseQoe","_checkConstraints","nextLatency","list","length","perm","map","val","generate","currLen","len","i","currPerm","shift","k","push","concat","getMinBuffer","getSegmentDuration","getNextBufferWithBitrate","bitrateToDownload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"LoLpWeightSelector.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * Authors:\r\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\r\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\r\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\r\n */\r\n\r\nimport FactoryMaker from '../../../../core/FactoryMaker';\r\n\r\nfunction LoLpWeightSelector(config) {\r\n    let targetLatency = config.targetLatency;\r\n    let bufferMin = config.bufferMin;\r\n    let segmentDuration = config.segmentDuration;\r\n    let qoeEvaluator = config.qoeEvaluator;\r\n    let instance,\r\n        valueList,\r\n        weightTypeCount,\r\n        weightOptions,\r\n        previousLatency;\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     */\r\n    function _setup() {\r\n        _resetInitialSettings();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @private\r\n     */\r\n    function _resetInitialSettings() {\r\n        valueList = [0.2, 0.4, 0.6, 0.8, 1];\r\n        weightTypeCount = 4;\r\n        weightOptions = _getPermutations(valueList, weightTypeCount);\r\n        previousLatency = 0;\r\n    }\r\n\r\n    /**\r\n     * Next, at each segment boundary, ABR to input current neurons and target state (only used in Method II) to find the desired weight vector\r\n     * @param {array} neurons\r\n     * @param {number} currentLatency\r\n     * @param {number} currentBuffer\r\n     * @param {number} currentRebuffer\r\n     * @param {number} currentThroughput\r\n     * @param {number} playbackRate\r\n     * @return {null}\r\n     * @private\r\n     */\r\n    function findWeightVector(neurons, currentLatency, currentBuffer, currentRebuffer, currentThroughput, playbackRate) {\r\n        let maxQoE = null;\r\n        let winnerWeights = null;\r\n        let winnerBitrate = null;\r\n        let deltaLatency = Math.abs(currentLatency - previousLatency);\r\n\r\n        // For each neuron, m\r\n        neurons.forEach((neuron) => {\r\n\r\n            // For each possible weight vector, z\r\n            // E.g. For [ throughput, latency, buffer, playbackRate, QoE ]\r\n            //      Possible weightVector = [ 0.2, 0.4, 0.2, 0, 0.2 ]\r\n            weightOptions.forEach((weightVector) => {\r\n\r\n                // Apply weightVector to neuron, compute utility and determine winnerWeights\r\n                // Method I: Utility based on QoE given current state\r\n\r\n                let weightsObj = {\r\n                    throughput: weightVector[0],\r\n                    latency: weightVector[1],\r\n                    buffer: weightVector[2],\r\n                    switch: weightVector[3]\r\n                };\r\n\r\n                let downloadTime = (neuron.bitrate * segmentDuration) / currentThroughput;\r\n                let nextBuffer = getNextBuffer(currentBuffer, downloadTime);\r\n                let rebuffer = Math.max(0.00001, (downloadTime - nextBuffer));\r\n                let wt;\r\n                if (weightsObj.buffer === 0) {\r\n                    wt = 10;\r\n                } else {\r\n                    wt = (1 / weightsObj.buffer);\r\n                }\r\n                let weightedRebuffer = wt * rebuffer;\r\n\r\n                if (weightsObj.latency === 0) {\r\n                    wt = 10;\r\n                } else {\r\n                    wt = (1 / weightsObj.latency); // inverse the weight because wt and latency should have positive relationship, i.e., higher latency = higher wt\r\n                }\r\n                let weightedLatency = wt * neuron.state.latency;\r\n\r\n                let totalQoE = qoeEvaluator.calculateSingleUseQoe(neuron.bitrate, weightedRebuffer, weightedLatency, playbackRate);\r\n                if ((maxQoE === null || totalQoE > maxQoE) && _checkConstraints(currentLatency, nextBuffer, deltaLatency)) {\r\n                    maxQoE = totalQoE;\r\n                    winnerWeights = weightVector;\r\n                    winnerBitrate = neuron.bitrate;\r\n                }\r\n            });\r\n        });\r\n\r\n        // winnerWeights was found, check if constraints are satisfied\r\n        if (winnerWeights === null && winnerBitrate === null) {\r\n            winnerWeights = -1;\r\n        }\r\n\r\n        previousLatency = currentLatency;\r\n        return winnerWeights;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} nextLatency\r\n     * @param {number} nextBuffer\r\n     * @param {number} deltaLatency\r\n     * @return {boolean}\r\n     * @private\r\n     */\r\n    function _checkConstraints(nextLatency, nextBuffer, deltaLatency) {\r\n        // A1\r\n        // disabled till we find a better way of estimating latency\r\n        // fails for all with current value\r\n        if (nextLatency > targetLatency + deltaLatency) {\r\n            return false;\r\n        }\r\n\r\n        return nextBuffer >= bufferMin;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {array} list\r\n     * @param {number} length\r\n     * @return {*}\r\n     * @private\r\n     */\r\n    function _getPermutations(list, length) {\r\n        // Copy initial values as arrays\r\n        let perm = list.map(function (val) {\r\n            return [val];\r\n        });\r\n        // Our permutation generator\r\n        let generate = function (perm, length, currLen) {\r\n            // Reached desired length\r\n            if (currLen === length) {\r\n                return perm;\r\n            }\r\n            // For each existing permutation\r\n            let len = perm.length;\r\n            for (let i = 0; i < len; i++) {\r\n                let currPerm = perm.shift();\r\n                // Create new permutation\r\n                for (let k = 0; k < list.length; k++) {\r\n                    perm.push(currPerm.concat(list[k]));\r\n                }\r\n            }\r\n            // Recurse\r\n            return generate(perm, length, currLen + 1);\r\n        };\r\n        // Start with size 1 because of initial values\r\n        return generate(perm, length, 1);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @return {number}\r\n     */\r\n    function getMinBuffer() {\r\n        return bufferMin;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @return {number}\r\n     */\r\n    function getSegmentDuration() {\r\n        return segmentDuration;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} bitrateToDownload\r\n     * @param {number} currentBuffer\r\n     * @param {number} currentThroughput\r\n     * @return {number}\r\n     */\r\n    function getNextBufferWithBitrate(bitrateToDownload, currentBuffer, currentThroughput) {\r\n        let downloadTime = (bitrateToDownload * segmentDuration) / currentThroughput;\r\n        return getNextBuffer(currentBuffer, downloadTime);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param {number} currentBuffer\r\n     * @param {number} downloadTime\r\n     * @return {number}\r\n     */\r\n    function getNextBuffer(currentBuffer, downloadTime) {\r\n        const segmentDuration = getSegmentDuration();\r\n        let nextBuffer;\r\n        if (downloadTime > segmentDuration) {\r\n            nextBuffer = currentBuffer - segmentDuration;\r\n        } else {\r\n            nextBuffer = currentBuffer + segmentDuration - downloadTime;\r\n        }\r\n        return nextBuffer;\r\n    }\r\n\r\n    instance = {\r\n        getMinBuffer,\r\n        getSegmentDuration,\r\n        getNextBufferWithBitrate,\r\n        getNextBuffer,\r\n        findWeightVector\r\n    };\r\n\r\n    _setup();\r\n\r\n    return instance;\r\n}\r\n\r\nLoLpWeightSelector.__dashjs_factory_name = 'LoLpWeightSelector';\r\nexport default FactoryMaker.getClassFactory(LoLpWeightSelector);\r\n"]}