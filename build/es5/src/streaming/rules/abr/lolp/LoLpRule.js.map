{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpRule.js"],"names":["DWS_TARGET_LATENCY","DWS_BUFFER_MIN","LoLPRule","config","dashMetrics","context","logger","instance","learningController","qoeEvaluator","_setup","getInstance","getLogger","create","getMaxIndex","rulesContext","switchRequest","mediaType","getMediaInfo","type","abrController","getAbrController","streamInfo","getStreamInfo","currentQuality","getQualityFor","mediaInfo","bufferStateVO","getCurrentBufferState","scheduleController","getScheduleController","currentBufferLevel","getCurrentBufferLevel","isDynamic","manifestInfo","playbackController","getPlaybackController","latency","getCurrentLiveLatency","useLoLPABR","Constants","AUDIO","playbackRate","getPlaybackRate","throughputHistory","getThroughputHistory","throughput","getSafeAverageThroughput","debug","Math","round","isNaN","getAbandonmentStateFor","MetricsConstants","ABANDON_LOAD","bitrateList","segmentDuration","getRepresentationInfo","fragmentDuration","minBitrateKbps","bandwidth","maxBitrateKbps","length","i","b","currentBitrate","currentBitrateKbps","httpRequest","getCurrentHttpRequest","lastFragmentDownloadTime","tresponse","getTime","trequest","segmentRebufferTime","setupPerSegmentQoe","logSegmentMetrics","dynamicWeightsSelector","targetLatency","bufferMin","quality","getNextQuality","reason","priority","SwitchRequest","PRIORITY","STRONG","setTimeToLoadDelay","console","log","e","_resetInitialSettings","reset","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"LoLpRule.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * Authors:\r\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\r\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\r\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\r\n */\r\n\r\nimport Debug from '../../../../core/Debug';\r\nimport FactoryMaker from '../../../../core/FactoryMaker';\r\nimport LearningAbrController from './LearningAbrController';\r\nimport LoLpQoeEvaluator from './LoLpQoEEvaluator';\r\nimport SwitchRequest from '../../SwitchRequest';\r\nimport MetricsConstants from '../../../constants/MetricsConstants';\r\nimport LoLpWeightSelector from './LoLpWeightSelector';\r\nimport Constants from '../../../constants/Constants';\r\n\r\nconst DWS_TARGET_LATENCY = 1.5;\r\nconst DWS_BUFFER_MIN = 0.3;\r\n\r\nfunction LoLPRule(config) {\r\n\r\n    config = config || {};\r\n\r\n    let dashMetrics = config.dashMetrics;\r\n    let context = this.context;\r\n\r\n    let logger,\r\n        instance,\r\n        learningController,\r\n        qoeEvaluator;\r\n\r\n    function _setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        learningController = LearningAbrController(context).create();\r\n        qoeEvaluator = LoLpQoeEvaluator(context).create();\r\n    }\r\n\r\n    function getMaxIndex(rulesContext) {\r\n        try {\r\n            let switchRequest = SwitchRequest(context).create();\r\n            let mediaType = rulesContext.getMediaInfo().type;\r\n            let abrController = rulesContext.getAbrController();\r\n            const streamInfo = rulesContext.getStreamInfo();\r\n            let currentQuality = abrController.getQualityFor(mediaType, streamInfo);\r\n            const mediaInfo = rulesContext.getMediaInfo();\r\n            const bufferStateVO = dashMetrics.getCurrentBufferState(mediaType);\r\n            const scheduleController = rulesContext.getScheduleController();\r\n            const currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\r\n            const isDynamic = streamInfo && streamInfo.manifestInfo ? streamInfo.manifestInfo.isDynamic : null;\r\n            const playbackController = scheduleController.getPlaybackController();\r\n            let latency = playbackController.getCurrentLiveLatency();\r\n\r\n            if (!rulesContext.useLoLPABR() || (mediaType === Constants.AUDIO)) {\r\n                return switchRequest;\r\n            }\r\n\r\n            if (!latency) {\r\n                latency = 0;\r\n            }\r\n\r\n            const playbackRate = playbackController.getPlaybackRate();\r\n            const throughputHistory = abrController.getThroughputHistory();\r\n            const throughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\r\n            logger.debug(`Throughput ${Math.round(throughput)} kbps`);\r\n\r\n            if (isNaN(throughput) || !bufferStateVO) {\r\n                return switchRequest;\r\n            }\r\n\r\n            if (abrController.getAbandonmentStateFor(mediaType) === MetricsConstants.ABANDON_LOAD) {\r\n                return switchRequest;\r\n            }\r\n\r\n            // QoE parameters\r\n            let bitrateList = mediaInfo.bitrateList;  // [{bandwidth: 200000, width: 640, height: 360}, ...]\r\n            let segmentDuration = rulesContext.getRepresentationInfo().fragmentDuration;\r\n            let minBitrateKbps = bitrateList[0].bandwidth / 1000.0;                         // min bitrate level\r\n            let maxBitrateKbps = bitrateList[bitrateList.length - 1].bandwidth / 1000.0;    // max bitrate level\r\n            for (let i = 0; i < bitrateList.length; i++) {  // in case bitrateList is not sorted as expected\r\n                let b = bitrateList[i].bandwidth / 1000.0;\r\n                if (b > maxBitrateKbps)\r\n                    maxBitrateKbps = b;\r\n                else if (b < minBitrateKbps) {\r\n                    minBitrateKbps = b;\r\n                }\r\n            }\r\n\r\n            // Learning rule pre-calculations\r\n            let currentBitrate = bitrateList[currentQuality].bandwidth;\r\n            let currentBitrateKbps = currentBitrate / 1000.0;\r\n            let httpRequest = dashMetrics.getCurrentHttpRequest(mediaType, true);\r\n            let lastFragmentDownloadTime = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\r\n            let segmentRebufferTime = lastFragmentDownloadTime > segmentDuration ? lastFragmentDownloadTime - segmentDuration : 0;\r\n            qoeEvaluator.setupPerSegmentQoe(segmentDuration, maxBitrateKbps, minBitrateKbps);\r\n            qoeEvaluator.logSegmentMetrics(currentBitrateKbps, segmentRebufferTime, latency, playbackRate);\r\n\r\n            /*\r\n            * Dynamic Weights Selector (step 1/2: initialization)\r\n            */\r\n            let dynamicWeightsSelector = LoLpWeightSelector(context).create({\r\n                targetLatency: DWS_TARGET_LATENCY,\r\n                bufferMin: DWS_BUFFER_MIN,\r\n                segmentDuration,\r\n                qoeEvaluator\r\n            });\r\n\r\n            /*\r\n             * Select next quality\r\n             */\r\n            switchRequest.quality = learningController.getNextQuality(mediaInfo, throughput * 1000, latency, currentBufferLevel, playbackRate, currentQuality, dynamicWeightsSelector);\r\n            switchRequest.reason = { throughput: throughput, latency: latency };\r\n            switchRequest.priority = SwitchRequest.PRIORITY.STRONG;\r\n\r\n            scheduleController.setTimeToLoadDelay(0);\r\n\r\n            if (switchRequest.quality !== currentQuality) {\r\n                console.log('[TgcLearningRule][' + mediaType + '] requesting switch to index: ', switchRequest.quality, 'Average throughput', Math.round(throughput), 'kbps');\r\n            }\r\n\r\n            return switchRequest;\r\n        } catch (e) {\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset objects to their initial state\r\n     * @private\r\n     */\r\n    function _resetInitialSettings() {\r\n        learningController.reset();\r\n        qoeEvaluator.reset();\r\n    }\r\n\r\n    /**\r\n     * Reset the rule\r\n     */\r\n    function reset() {\r\n        _resetInitialSettings();\r\n    }\r\n\r\n    instance = {\r\n        getMaxIndex,\r\n        reset\r\n    };\r\n\r\n    _setup();\r\n\r\n    return instance;\r\n}\r\n\r\nLoLPRule.__dashjs_factory_name = 'LoLPRule';\r\nexport default FactoryMaker.getClassFactory(LoLPRule);\r\n"]}