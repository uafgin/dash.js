{"version":3,"sources":["../../../../src/streaming/ManifestUpdater.js"],"names":["ManifestUpdater","context","eventBus","getInstance","urlUtils","instance","logger","refreshDelay","refreshTimer","isPaused","isStopped","isUpdating","manifestLoader","manifestModel","adapter","errHandler","settings","setup","getLogger","setConfig","config","initialize","resetInitialSettings","on","Events","STREAMS_COMPOSED","onStreamsComposed","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_PAUSED","onPlaybackPaused","INTERNAL_MANIFEST_LOADED","onManifestLoaded","setManifest","manifest","update","NaN","stopManifestRefreshTimer","reset","off","clearTimeout","startManifestRefreshTimer","delay","isNaN","debug","setTimeout","onRefreshTimer","refreshManifest","ignorePatch","getValue","url","patchLocation","getPatchLocation","location","getLocation","isRelative","resolve","load","loadedTime","Date","getIsPatch","patch","isPatchValid","patchSuccessful","publishTime","getPublishTime","applyPatchToManifest","updatedPublishTime","getTime","type","DashConstants","DYNAMIC","STATIC","trigger","DYNAMIC_TO_STATIC","setValue","date","latencyOfLastUpdate","getManifestUpdatePeriod","MANIFEST_UPDATED","info","get","streaming","manifestUpdateRetryInterval","e","error","code","Errors","MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE","scheduleWhilePaused","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"ManifestUpdater.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport EventBus from '../core/EventBus';\r\nimport Events from '../core/events/Events';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport Debug from '../core/Debug';\r\nimport Errors from '../core/errors/Errors';\r\nimport DashConstants from '../dash/constants/DashConstants';\r\nimport URLUtils from './utils/URLUtils';\r\n\r\nfunction ManifestUpdater() {\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const urlUtils = URLUtils(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        refreshDelay,\r\n        refreshTimer,\r\n        isPaused,\r\n        isStopped,\r\n        isUpdating,\r\n        manifestLoader,\r\n        manifestModel,\r\n        adapter,\r\n        errHandler,\r\n        settings;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.manifestModel) {\r\n            manifestModel = config.manifestModel;\r\n        }\r\n        if (config.adapter) {\r\n            adapter = config.adapter;\r\n        }\r\n        if (config.manifestLoader) {\r\n            manifestLoader = config.manifestLoader;\r\n        }\r\n        if (config.errHandler) {\r\n            errHandler = config.errHandler;\r\n        }\r\n        if (config.settings) {\r\n            settings = config.settings;\r\n        }\r\n    }\r\n\r\n    function initialize() {\r\n        resetInitialSettings();\r\n\r\n        eventBus.on(Events.STREAMS_COMPOSED, onStreamsComposed, this);\r\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\r\n        eventBus.on(Events.PLAYBACK_PAUSED, onPlaybackPaused, this);\r\n        eventBus.on(Events.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\r\n    }\r\n\r\n    function setManifest(manifest) {\r\n        update(manifest);\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        refreshDelay = NaN;\r\n        isUpdating = false;\r\n        isPaused = true;\r\n        isStopped = false;\r\n        stopManifestRefreshTimer();\r\n    }\r\n\r\n    function reset() {\r\n\r\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\r\n        eventBus.off(Events.PLAYBACK_PAUSED, onPlaybackPaused, this);\r\n        eventBus.off(Events.STREAMS_COMPOSED, onStreamsComposed, this);\r\n        eventBus.off(Events.INTERNAL_MANIFEST_LOADED, onManifestLoaded, this);\r\n\r\n        resetInitialSettings();\r\n    }\r\n\r\n    function stopManifestRefreshTimer() {\r\n        if (refreshTimer !== null) {\r\n            clearTimeout(refreshTimer);\r\n            refreshTimer = null;\r\n        }\r\n    }\r\n\r\n    function startManifestRefreshTimer(delay) {\r\n        stopManifestRefreshTimer();\r\n\r\n        if (isStopped) {\r\n            return;\r\n        }\r\n\r\n        if (isNaN(delay) && !isNaN(refreshDelay)) {\r\n            delay = refreshDelay * 1000;\r\n        }\r\n\r\n        if (!isNaN(delay)) {\r\n            logger.debug('Refresh manifest in ' + delay + ' milliseconds.');\r\n            refreshTimer = setTimeout(onRefreshTimer, delay);\r\n        }\r\n    }\r\n\r\n    function refreshManifest(ignorePatch = false) {\r\n        isUpdating = true;\r\n        const manifest = manifestModel.getValue();\r\n\r\n        // default to the original url in the manifest\r\n        let url = manifest.url;\r\n\r\n        // Check for PatchLocation and Location alternatives\r\n        const patchLocation = adapter.getPatchLocation(manifest);\r\n        const location = adapter.getLocation(manifest);\r\n        if (patchLocation && !ignorePatch) {\r\n            url = patchLocation;\r\n        } else if (location) {\r\n            url = location;\r\n        }\r\n\r\n        // if one of the alternatives was relative, convert to absolute\r\n        if (urlUtils.isRelative(url)) {\r\n            url = urlUtils.resolve(url, manifest.url);\r\n        }\r\n\r\n        manifestLoader.load(url);\r\n    }\r\n\r\n    function update(manifest) {\r\n        if (!manifest) {\r\n            // successful update with no content implies existing manifest remains valid\r\n            manifest = manifestModel.getValue();\r\n\r\n            // override load time to avoid invalid latency tracking and ensure update cadence\r\n            manifest.loadedTime = new Date();\r\n        } else if (adapter.getIsPatch(manifest)) {\r\n            // with patches the in-memory manifest is our base\r\n            let patch = manifest;\r\n            manifest = manifestModel.getValue();\r\n\r\n            // check for patch validity\r\n            let isPatchValid = adapter.isPatchValid(manifest, patch);\r\n            let patchSuccessful = isPatchValid;\r\n\r\n            if (isPatchValid) {\r\n                // grab publish time before update\r\n                let publishTime = adapter.getPublishTime(manifest);\r\n\r\n                // apply validated patch to manifest\r\n                patchSuccessful = adapter.applyPatchToManifest(manifest, patch);\r\n\r\n                // get the updated publish time\r\n                let updatedPublishTime = adapter.getPublishTime(manifest);\r\n\r\n                // ensure the patch properly updated the in-memory publish time\r\n                patchSuccessful = publishTime.getTime() != updatedPublishTime.getTime();\r\n            }\r\n\r\n            // if the patch failed to apply, force a full manifest refresh\r\n            if (!patchSuccessful) {\r\n                logger.debug('Patch provided is invalid, performing full manifest refresh');\r\n                refreshManifest(true);\r\n                return;\r\n            }\r\n\r\n            // override load time to avoid invalid latency tracking and ensure update cadence\r\n            manifest.loadedTime = new Date();\r\n        }\r\n\r\n        // See DASH-IF IOP v4.3 section 4.6.4 \"Transition Phase between Live and On-Demand\"\r\n        // Stop manifest update, ignore static manifest and signal end of dynamic stream to detect end of stream\r\n        if (manifestModel.getValue() && manifestModel.getValue().type === DashConstants.DYNAMIC && manifest.type === DashConstants.STATIC) {\r\n            eventBus.trigger(Events.DYNAMIC_TO_STATIC);\r\n            isUpdating = false;\r\n            isStopped = true;\r\n            return;\r\n        }\r\n\r\n        manifestModel.setValue(manifest);\r\n\r\n        const date = new Date();\r\n        const latencyOfLastUpdate = (date.getTime() - manifest.loadedTime.getTime()) / 1000;\r\n        refreshDelay = adapter.getManifestUpdatePeriod(manifest, latencyOfLastUpdate);\r\n        // setTimeout uses a 32 bit number to store the delay. Any number greater than it\r\n        // will cause event associated with setTimeout to trigger immediately\r\n        if (refreshDelay * 1000 > 0x7FFFFFFF) {\r\n            refreshDelay = 0x7FFFFFFF / 1000;\r\n        }\r\n        eventBus.trigger(Events.MANIFEST_UPDATED, { manifest: manifest });\r\n        logger.info('Manifest has been refreshed at ' + date + '[' + date.getTime() / 1000 + '] ');\r\n\r\n        if (!isPaused) {\r\n            startManifestRefreshTimer();\r\n        }\r\n    }\r\n\r\n    function onRefreshTimer() {\r\n        if (isPaused) {\r\n            return;\r\n        }\r\n        if (isUpdating) {\r\n            startManifestRefreshTimer(settings.get().streaming.manifestUpdateRetryInterval);\r\n            return;\r\n        }\r\n        refreshManifest();\r\n    }\r\n\r\n    function onManifestLoaded(e) {\r\n        if (!e.error) {\r\n            update(e.manifest);\r\n        } else if (e.error.code === Errors.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE) {\r\n            errHandler.error(e.error);\r\n        }\r\n    }\r\n\r\n    function onPlaybackStarted (/*e*/) {\r\n        isPaused = false;\r\n        startManifestRefreshTimer();\r\n    }\r\n\r\n    function onPlaybackPaused(/*e*/) {\r\n        isPaused = !settings.get().streaming.scheduleWhilePaused;\r\n\r\n        if (isPaused) {\r\n            stopManifestRefreshTimer();\r\n        }\r\n    }\r\n\r\n    function onStreamsComposed(/*e*/) {\r\n        // When streams are ready we can consider manifest update completed. Resolve the update promise.\r\n        isUpdating = false;\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        setManifest: setManifest,\r\n        refreshManifest: refreshManifest,\r\n        setConfig: setConfig,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\nManifestUpdater.__dashjs_factory_name = 'ManifestUpdater';\r\nexport default FactoryMaker.getClassFactory(ManifestUpdater);\r\n"]}