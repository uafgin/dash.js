{"version":3,"sources":["../../../../../src/streaming/utils/BoxParser.js"],"names":["BoxParser","logger","instance","context","setup","getInstance","getLogger","parse","data","fileStart","undefined","parsedFile","ISOBoxer","parseBuffer","dashIsoFile","create","setData","findLastTopIsoBoxCompleted","types","buffer","offset","byteLength","IsoBoxSearchInfo","ArrayBuffer","Uint8Array","boxInfo","lastCompletedOffset","boxSize","parseUint32","boxType","parseIsoBoxType","indexOf","getSamplesInfo","ab","sampleList","lastSequenceNumber","NaN","totalDuration","numSequences","isoFile","moofBoxes","getBoxes","mfhdBoxes","sampleDuration","sampleCompositionTimeOffset","sampleCount","sampleSize","sampleDts","sample","i","j","k","l","m","n","dataOffset","length","sequence_number","subsIndex","nextSubsSample","moofBox","trafBoxes","getChildBoxes","trafBox","tfhdBox","getChildBox","tfdtBox","baseMediaDecodeTime","trunBoxes","subsBoxes","trunBox","sample_count","base_data_offset","data_offset","samples","sample_duration","default_sample_duration","sample_size","default_sample_size","sample_composition_time_offset","sampleData","subsBox","entry_count","entries","sample_delta","subSizes","entry","subsample_count","push","subsamples","subsample_size","getMediaTimescaleFromMoov","mdhdBox","getBox","timescale","String","fromCharCode","findInitRange","initRange","start","end","ftyp","moov","debug","isComplete","size","parsePayload","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"BoxParser.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport Debug from '../../core/Debug';\r\nimport IsoFile from './IsoFile';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport ISOBoxer from 'codem-isoboxer';\r\n\r\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\r\n\r\nfunction BoxParser(/*config*/) {\r\n\r\n    let logger,\r\n        instance;\r\n    let context = this.context;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n    }\r\n\r\n    /**\r\n     * @param {ArrayBuffer} data\r\n     * @returns {IsoFile|null}\r\n     * @memberof BoxParser#\r\n     */\r\n    function parse(data) {\r\n        if (!data) return null;\r\n\r\n        if (data.fileStart === undefined) {\r\n            data.fileStart = 0;\r\n        }\r\n\r\n        let parsedFile = ISOBoxer.parseBuffer(data);\r\n        let dashIsoFile = IsoFile(context).create();\r\n\r\n        dashIsoFile.setData(parsedFile);\r\n\r\n        return dashIsoFile;\r\n    }\r\n\r\n    /**\r\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\r\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\r\n     * @param {string[]} types\r\n     * @param {ArrayBuffer|uint8Array} buffer\r\n     * @param {number} offset\r\n     * @returns {IsoBoxSearchInfo}\r\n     * @memberof BoxParser#\r\n     */\r\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        // 8 = size (uint32) + type (4 characters)\r\n        if (!buffer || offset + 8 >= buffer.byteLength) {\r\n            return new IsoBoxSearchInfo(0, false);\r\n        }\r\n\r\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\r\n        let boxInfo;\r\n        let lastCompletedOffset = 0;\r\n        while (offset < data.byteLength) {\r\n            const boxSize = parseUint32(data, offset);\r\n            const boxType = parseIsoBoxType(data, offset + 4);\r\n\r\n            if (boxSize === 0) {\r\n                break;\r\n            }\r\n\r\n            if (offset + boxSize <= data.byteLength) {\r\n                if (types.indexOf(boxType) >= 0) {\r\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\r\n                } else {\r\n                    lastCompletedOffset = offset + boxSize;\r\n                }\r\n            }\r\n\r\n            offset += boxSize;\r\n        }\r\n\r\n        if (!boxInfo) {\r\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\r\n        }\r\n\r\n        return boxInfo;\r\n    }\r\n\r\n    function getSamplesInfo(ab) {\r\n        if (!ab || ab.byteLength === 0) {\r\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\r\n        }\r\n        let isoFile = parse(ab);\r\n        // zero or more moofs\r\n        let moofBoxes = isoFile.getBoxes('moof');\r\n        // exactly one mfhd per moof\r\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\r\n\r\n        let sampleDuration,\r\n            sampleCompositionTimeOffset,\r\n            sampleCount,\r\n            sampleSize,\r\n            sampleDts,\r\n            sampleList,\r\n            sample,\r\n            i, j, k, l, m, n,\r\n            dataOffset,\r\n            lastSequenceNumber,\r\n            numSequences,\r\n            totalDuration;\r\n\r\n        numSequences = isoFile.getBoxes('moof').length;\r\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\r\n        sampleCount = 0;\r\n\r\n        sampleList = [];\r\n        let subsIndex = -1;\r\n        let nextSubsSample = -1;\r\n        for (l = 0; l < moofBoxes.length; l++) {\r\n            let moofBox = moofBoxes[l];\r\n            // zero or more trafs per moof\r\n            let trafBoxes = moofBox.getChildBoxes('traf');\r\n            for (j = 0; j < trafBoxes.length; j++) {\r\n                let trafBox = trafBoxes[j];\r\n                // exactly one tfhd per traf\r\n                let tfhdBox = trafBox.getChildBox('tfhd');\r\n                // zero or one tfdt per traf\r\n                let tfdtBox = trafBox.getChildBox('tfdt');\r\n                sampleDts = tfdtBox.baseMediaDecodeTime;\r\n                // zero or more truns per traf\r\n                let trunBoxes = trafBox.getChildBoxes('trun');\r\n                // zero or more subs per traf\r\n                let subsBoxes = trafBox.getChildBoxes('subs');\r\n                for (k = 0; k < trunBoxes.length; k++) {\r\n                    let trunBox = trunBoxes[k];\r\n                    sampleCount = trunBox.sample_count;\r\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\r\n\r\n                    for (i = 0; i < sampleCount; i++) {\r\n                        sample = trunBox.samples[i];\r\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\r\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\r\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\r\n                        let sampleData = {\r\n                            'dts': sampleDts,\r\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\r\n                            'duration': sampleDuration,\r\n                            'offset': moofBox.offset + dataOffset,\r\n                            'size': sampleSize,\r\n                            'subSizes': [sampleSize]\r\n                        };\r\n                        if (subsBoxes) {\r\n                            for (m = 0; m < subsBoxes.length; m++) {\r\n                                let subsBox = subsBoxes[m];\r\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\r\n                                    subsIndex++;\r\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\r\n                                }\r\n                                if (i == nextSubsSample) {\r\n                                    sampleData.subSizes = [];\r\n                                    let entry = subsBox.entries[subsIndex];\r\n                                    for (n = 0; n < entry.subsample_count; n++) {\r\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        sampleList.push(sampleData);\r\n                        dataOffset += sampleSize;\r\n                        sampleDts += sampleDuration;\r\n                    }\r\n                }\r\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\r\n            }\r\n        }\r\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\r\n    }\r\n\r\n    function getMediaTimescaleFromMoov(ab) {\r\n        let isoFile = parse(ab);\r\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\r\n\r\n        return mdhdBox ? mdhdBox.timescale : NaN;\r\n    }\r\n\r\n    function parseUint32(data, offset) {\r\n        return data[offset + 3] >>> 0 |\r\n            (data[offset + 2] << 8) >>> 0 |\r\n            (data[offset + 1] << 16) >>> 0 |\r\n            (data[offset] << 24) >>> 0;\r\n    }\r\n\r\n    function parseIsoBoxType(data, offset) {\r\n        return String.fromCharCode(data[offset++]) +\r\n            String.fromCharCode(data[offset++]) +\r\n            String.fromCharCode(data[offset++]) +\r\n            String.fromCharCode(data[offset]);\r\n    }\r\n\r\n    function findInitRange(data) {\r\n        let initRange = null;\r\n        let start,\r\n            end;\r\n\r\n        const isoFile = parse(data);\r\n\r\n        if (!isoFile) {\r\n            return initRange;\r\n        }\r\n\r\n        const ftyp = isoFile.getBox('ftyp');\r\n        const moov = isoFile.getBox('moov');\r\n\r\n        logger.debug('Searching for initialization.');\r\n\r\n        if (moov && moov.isComplete) {\r\n            start = ftyp ? ftyp.offset : moov.offset;\r\n            end = moov.offset + moov.size - 1;\r\n            initRange = start + '-' + end;\r\n\r\n            logger.debug('Found the initialization.  Range: ' + initRange);\r\n        }\r\n\r\n        return initRange;\r\n    }\r\n\r\n    /**\r\n     * Real-time parsing (whenever data is loaded in the buffer payload) of the payload to capture the moof of a chunk\r\n     * @param {array} types\r\n     * @param {ArrayBuffer} buffer\r\n     * @param {number} offset\r\n     * @return {IsoBoxSearchInfo}\r\n     */\r\n    function parsePayload(types, buffer, offset) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        if (!buffer || offset + 8 >= buffer.byteLength) {\r\n            return new IsoBoxSearchInfo(0, false);\r\n        }\r\n\r\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\r\n        let boxInfo;\r\n        let lastCompletedOffset = 0;\r\n        while (offset < data.byteLength) {\r\n            const boxSize = parseUint32(data, offset);\r\n            const boxType = parseIsoBoxType(data, offset + 4);\r\n\r\n            if (boxSize === 0) {\r\n                break;\r\n            }\r\n\r\n            if (offset + boxSize <= data.byteLength) {\r\n                if (types.indexOf(boxType) >= 0) {\r\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize, boxType);\r\n                } else {\r\n                    lastCompletedOffset = offset + boxSize;\r\n                }\r\n            }\r\n\r\n            offset += boxSize;\r\n        }\r\n\r\n        if (!boxInfo) {\r\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\r\n        }\r\n\r\n        return boxInfo;\r\n    }\r\n\r\n    instance = {\r\n        parse: parse,\r\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\r\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\r\n        getSamplesInfo: getSamplesInfo,\r\n        findInitRange: findInitRange,\r\n        parsePayload: parsePayload\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\nBoxParser.__dashjs_factory_name = 'BoxParser';\r\nexport default FactoryMaker.getSingletonFactory(BoxParser);\r\n"]}