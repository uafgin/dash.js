{"version":3,"sources":["../../../../../src/streaming/utils/EBMLParser.js"],"names":["EBMLParser","config","instance","data","DataView","pos","getPos","setPos","value","consumeTag","tag","test","found","bytesConsumed","p1","p2","undefined","getUint32","getUint16","getUint8","required","Error","consumeTagAndSize","getMatroskaCodedNum","parseTag","size","parse","skipOverElement","headerSize","retainMSB","bytesUsed","mask","maxBytes","extraBytes","num","ch","i","getMatroskaFloat","outFloat","getFloat32","getFloat64","getMatroskaUint","val","moreData","byteLength","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"EBMLParser.js","sourcesContent":["import FactoryMaker from '../../core/FactoryMaker';\r\n\r\n/**\r\n * Creates an instance of an EBMLParser class which implements a large subset\r\n * of the functionality required to parse Matroska EBML\r\n *\r\n * @param {Object} config object with data member which is the buffer to parse\r\n * @ignore\r\n */\r\nfunction EBMLParser(config) {\r\n\r\n    config = config || {};\r\n    let instance;\r\n\r\n    let data = new DataView(config.data);\r\n    let pos = 0;\r\n\r\n    function getPos() {\r\n        return pos;\r\n    }\r\n\r\n    function setPos(value) {\r\n        pos = value;\r\n    }\r\n\r\n    /**\r\n     * Consumes an EBML tag from the data stream.\r\n     *\r\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\r\n     * {boolean} required flag.\r\n     * @param {boolean} test whether or not the function should throw if a required\r\n     * tag is not found\r\n     * @return {boolean} whether or not the tag was found\r\n     * @throws will throw an exception if a required tag is not found and test\r\n     * param is false or undefined, or if the stream is malformed.\r\n     * @memberof EBMLParser\r\n     */\r\n    function consumeTag(tag, test) {\r\n        let found = true;\r\n        let bytesConsumed = 0;\r\n        let p1,\r\n            p2;\r\n\r\n        if (test === undefined) {\r\n            test = false;\r\n        }\r\n\r\n        if (tag.tag > 0xFFFFFF) {\r\n            if (data.getUint32(pos) !== tag.tag) {\r\n                found = false;\r\n            }\r\n            bytesConsumed = 4;\r\n        } else if (tag.tag > 0xFFFF) {\r\n            // 3 bytes\r\n            p1 = data.getUint16(pos);\r\n            p2 = data.getUint8(pos + 2);\r\n\r\n            // shift p1 over a byte and add p2\r\n            if (p1 * 256 + p2 !== tag.tag) {\r\n                found = false;\r\n            }\r\n            bytesConsumed = 3;\r\n        } else if (tag.tag > 0xFF) {\r\n            if (data.getUint16(pos) !== tag.tag) {\r\n                found = false;\r\n            }\r\n            bytesConsumed = 2;\r\n        } else {\r\n            if (data.getUint8(pos) !== tag.tag) {\r\n                found = false;\r\n            }\r\n            bytesConsumed = 1;\r\n        }\r\n\r\n        if (!found && tag.required && !test) {\r\n            throw new Error('required tag not found');\r\n        }\r\n\r\n        if (found) {\r\n            pos += bytesConsumed;\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\r\n     * function will also remove the size field which follows the tag from the\r\n     * data stream.\r\n     *\r\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag and\r\n     * {boolean} required flag.\r\n     * @param {boolean} test whether or not the function should throw if a required\r\n     * tag is not found\r\n     * @return {boolean} whether or not the tag was found\r\n     * @throws will throw an exception if a required tag is not found and test\r\n     * param is false or undefined, or if the stream is malformedata.\r\n     * @memberof EBMLParser\r\n     */\r\n    function consumeTagAndSize(tag, test) {\r\n        let found = consumeTag(tag, test);\r\n\r\n        if (found) {\r\n            getMatroskaCodedNum();\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\r\n     * function will also remove the size field which follows the tag from the\r\n     * data stream.  It will use the value of the size field to parse a binary\r\n     * field, using a parser defined in the tag itself\r\n     *\r\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag,\r\n     * {boolean} required flag, and a parse function which takes a size parameter\r\n     * @return {boolean} whether or not the tag was found\r\n     * @throws will throw an exception if a required tag is not found,\r\n     * or if the stream is malformed\r\n     * @memberof EBMLParser\r\n     */\r\n    function parseTag(tag) {\r\n        let size;\r\n\r\n        consumeTag(tag);\r\n        size = getMatroskaCodedNum();\r\n        return instance[tag.parse](size);\r\n    }\r\n\r\n    /**\r\n     * Consumes an EBML tag from the data stream.   If the tag is found then this\r\n     * function will also remove the size field which follows the tag from the\r\n     * data stream.  It will use the value of the size field to skip over the\r\n     * entire section of EBML encapsulated by the tag.\r\n     *\r\n     * @param {Object} tag to parse, A tag is an object with at least a {number} tag, and\r\n     * {boolean} required flag\r\n     * @param {boolean} test a flag to indicate if an exception should be thrown\r\n     * if a required tag is not found\r\n     * @return {boolean} whether or not the tag was found\r\n     * @throws will throw an exception if a required tag is not found and test is\r\n     * false or undefined or if the stream is malformed\r\n     * @memberof EBMLParser\r\n     */\r\n    function skipOverElement(tag, test) {\r\n        let found = consumeTag(tag, test);\r\n        let headerSize;\r\n\r\n        if (found) {\r\n            headerSize = getMatroskaCodedNum();\r\n            pos += headerSize;\r\n        }\r\n\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Returns and consumes a number encoded according to the Matroska EBML\r\n     * specification from the bitstream.\r\n     *\r\n     * @param {boolean} retainMSB whether or not to retain the Most Significant Bit (the\r\n     * first 1). this is usually true when reading Tag IDs.\r\n     * @return {number} the decoded number\r\n     * @throws will throw an exception if the bit stream is malformed or there is\r\n     * not enough data\r\n     * @memberof EBMLParser\r\n     */\r\n    function getMatroskaCodedNum(retainMSB) {\r\n        let bytesUsed = 1;\r\n        let mask = 0x80;\r\n        let maxBytes = 8;\r\n        let extraBytes = -1;\r\n        let num = 0;\r\n        let ch = data.getUint8(pos);\r\n        let i = 0;\r\n\r\n        for (i = 0; i < maxBytes; i += 1) {\r\n            if ((ch & mask) === mask) {\r\n                num = (retainMSB === undefined) ? ch & ~mask : ch;\r\n                extraBytes = i;\r\n                break;\r\n            }\r\n            mask >>= 1;\r\n        }\r\n\r\n        for (i = 0; i < extraBytes; i += 1, bytesUsed += 1) {\r\n            num = (num << 8) | (0xff & data.getUint8(pos + bytesUsed));\r\n        }\r\n\r\n        pos += bytesUsed;\r\n\r\n        return num;\r\n    }\r\n\r\n    /**\r\n     * Returns and consumes a float from the bitstream.\r\n     *\r\n     * @param {number} size 4 or 8 byte floats are supported\r\n     * @return {number} the decoded number\r\n     * @throws will throw an exception if the bit stream is malformed or there is\r\n     * not enough data\r\n     * @memberof EBMLParser\r\n     */\r\n    function getMatroskaFloat(size) {\r\n        let outFloat;\r\n\r\n        switch (size) {\r\n        case 4:\r\n            outFloat = data.getFloat32(pos);\r\n            pos += 4;\r\n            break;\r\n        case 8:\r\n            outFloat = data.getFloat64(pos);\r\n            pos += 8;\r\n            break;\r\n        }\r\n        return outFloat;\r\n    }\r\n\r\n    /**\r\n     * Consumes and returns an unsigned int from the bitstream.\r\n     *\r\n     * @param {number} size 1 to 8 bytes\r\n     * @return {number} the decoded number\r\n     * @throws will throw an exception if the bit stream is malformed or there is\r\n     * not enough data\r\n     * @memberof EBMLParser\r\n     */\r\n    function getMatroskaUint(size) {\r\n        let val = 0;\r\n\r\n        for (let i = 0; i < size; i += 1) {\r\n            val <<= 8;\r\n            val |= data.getUint8(pos + i) & 0xff;\r\n        }\r\n\r\n        pos += size;\r\n        return val;\r\n    }\r\n\r\n    /**\r\n     * Tests whether there is more data in the bitstream for parsing\r\n     *\r\n     * @return {boolean} whether there is more data to parse\r\n     * @memberof EBMLParser\r\n     */\r\n    function moreData() {\r\n        return pos < data.byteLength;\r\n    }\r\n\r\n    instance = {\r\n        getPos: getPos,\r\n        setPos: setPos,\r\n        consumeTag: consumeTag,\r\n        consumeTagAndSize: consumeTagAndSize,\r\n        parseTag: parseTag,\r\n        skipOverElement: skipOverElement,\r\n        getMatroskaCodedNum: getMatroskaCodedNum,\r\n        getMatroskaFloat: getMatroskaFloat,\r\n        getMatroskaUint: getMatroskaUint,\r\n        moreData: moreData\r\n    };\r\n\r\n    return instance;\r\n}\r\n\r\nEBMLParser.__dashjs_factory_name = 'EBMLParser';\r\nexport default FactoryMaker.getClassFactory(EBMLParser);"]}