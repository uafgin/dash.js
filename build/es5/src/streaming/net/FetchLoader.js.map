{"version":3,"sources":["../../../../../src/streaming/net/FetchLoader.js"],"names":["FetchLoader","cfg","context","requestModifier","boxParser","settings","getInstance","instance","load","httpRequest","requestStartTime","Date","request","headers","Headers","range","append","requestStartDate","modifyRequestHeader","setRequestHeader","header","value","abortController","window","AbortController","signal","onabort","reqOptions","method","credentials","withCredentials","undefined","fetch","url","then","response","status","statusText","responseURL","ok","onerror","responseHeaders","keys","key","get","body","arrayBuffer","buffer","event","loaded","byteLength","total","stream","progress","onload","onend","totalBytes","parseInt","bytesReceived","signaledFirstByte","remaining","Uint8Array","offset","reader","getReader","downloadedData","startTimeData","endTimeData","lastChunkWasFinished","calculationMode","streaming","abr","fetchThroughputCalculationMode","processResult","done","isNaN","lengthComputable","time","calculateDownloadedTime","length","concatTypedArray","push","ts","now","bytes","Constants","ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING","boxesInfo","findLastTopIsoBoxCompleted","found","performance","end","lastCompletedOffset","size","data","subarray","noTrace","read","catch","e","result","set","abort","cancel","_calculateDownloadedTimeByMoofParsing","ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA","_calculateDownloadedTimeByBytesReceived","datum","datumE","filter","i","dataE","segDownloadTime","chunkDownladTime","avgTimeDistance","forEach","index","next","distance","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"mappings":"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","file":"FetchLoader.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Settings from '../../core/Settings';\r\nimport Constants from '../constants/Constants';\r\n\r\n/**\r\n * @module FetchLoader\r\n * @ignore\r\n * @description Manages download of resources via HTTP using fetch.\r\n * @param {Object} cfg - dependencies from parent\r\n */\r\nfunction FetchLoader(cfg) {\r\n\r\n    cfg = cfg || {};\r\n    const context = this.context;\r\n    const requestModifier = cfg.requestModifier;\r\n    const boxParser = cfg.boxParser;\r\n    const settings = Settings(context).getInstance();\r\n    let instance;\r\n\r\n    function load(httpRequest) {\r\n\r\n        // Variables will be used in the callback functions\r\n        const requestStartTime = new Date();\r\n        const request = httpRequest.request;\r\n\r\n        const headers = new Headers(); /*jshint ignore:line*/\r\n        if (request.range) {\r\n            headers.append('Range', 'bytes=' + request.range);\r\n        }\r\n\r\n        if (!request.requestStartDate) {\r\n            request.requestStartDate = requestStartTime;\r\n        }\r\n\r\n        if (requestModifier) {\r\n            // modifyRequestHeader expects a XMLHttpRequest object so,\r\n            // to keep backward compatibility, we should expose a setRequestHeader method\r\n            // TODO: Remove RequestModifier dependency on XMLHttpRequest object and define\r\n            // a more generic way to intercept/modify requests\r\n            requestModifier.modifyRequestHeader({\r\n                setRequestHeader: function (header, value) {\r\n                    headers.append(header, value);\r\n                }\r\n            });\r\n        }\r\n\r\n        let abortController;\r\n        if (typeof window.AbortController === 'function') {\r\n            abortController = new AbortController(); /*jshint ignore:line*/\r\n            httpRequest.abortController = abortController;\r\n            abortController.signal.onabort = httpRequest.onabort;\r\n        }\r\n\r\n        const reqOptions = {\r\n            method: httpRequest.method,\r\n            headers: headers,\r\n            credentials: httpRequest.withCredentials ? 'include' : undefined,\r\n            signal: abortController ? abortController.signal : undefined\r\n        };\r\n\r\n        fetch(httpRequest.url, reqOptions).then(function (response) {\r\n            if (!httpRequest.response) {\r\n                httpRequest.response = {};\r\n            }\r\n            httpRequest.response.status = response.status;\r\n            httpRequest.response.statusText = response.statusText;\r\n            httpRequest.response.responseURL = response.url;\r\n\r\n            if (!response.ok) {\r\n                httpRequest.onerror();\r\n            }\r\n\r\n            let responseHeaders = '';\r\n            for (const key of response.headers.keys()) {\r\n                responseHeaders += key + ': ' + response.headers.get(key) + '\\r\\n';\r\n            }\r\n            httpRequest.response.responseHeaders = responseHeaders;\r\n\r\n            if (!response.body) {\r\n                // Fetch returning a ReadableStream response body is not currently supported by all browsers.\r\n                // Browser compatibility: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\r\n                // If it is not supported, returning the whole segment when it's ready (as xhr)\r\n                return response.arrayBuffer().then(function (buffer) {\r\n                    httpRequest.response.response = buffer;\r\n                    const event = {\r\n                        loaded: buffer.byteLength,\r\n                        total: buffer.byteLength,\r\n                        stream: false\r\n                    };\r\n                    httpRequest.progress(event);\r\n                    httpRequest.onload();\r\n                    httpRequest.onend();\r\n                    return;\r\n                });\r\n            }\r\n\r\n            const totalBytes = parseInt(response.headers.get('Content-Length'), 10);\r\n            let bytesReceived = 0;\r\n            let signaledFirstByte = false;\r\n            let remaining = new Uint8Array();\r\n            let offset = 0;\r\n\r\n            httpRequest.reader = response.body.getReader();\r\n            let downloadedData = [];\r\n            let startTimeData = [];\r\n            let endTimeData = [];\r\n            let lastChunkWasFinished = true;\r\n            const calculationMode = settings.get().streaming.abr.fetchThroughputCalculationMode;\r\n\r\n            const processResult = function ({ value, done }) { // Bug fix Parse whenever data is coming [value] better than 1ms looking that increase CPU\r\n                if (done) {\r\n                    if (remaining) {\r\n                        // If there is pending data, call progress so network metrics\r\n                        // are correctly generated\r\n                        // Same structure as https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/\r\n                        httpRequest.progress({\r\n                            loaded: bytesReceived,\r\n                            total: isNaN(totalBytes) ? bytesReceived : totalBytes,\r\n                            lengthComputable: true,\r\n                            time: calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived),\r\n                            stream: true\r\n                        });\r\n\r\n                        httpRequest.response.response = remaining.buffer;\r\n                    }\r\n                    httpRequest.onload();\r\n                    httpRequest.onend();\r\n                    return;\r\n                }\r\n\r\n                if (value && value.length > 0) {\r\n                    remaining = concatTypedArray(remaining, value);\r\n                    bytesReceived += value.length;\r\n\r\n                    downloadedData.push({\r\n                        ts: Date.now(),\r\n                        bytes: value.length\r\n                    });\r\n\r\n                    if (calculationMode === Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING && lastChunkWasFinished) {\r\n                        // Parse the payload and capture the the 'moof' box\r\n                        const boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moof'], remaining, offset);\r\n                        if (boxesInfo.found) {\r\n                            // Store the beginning time of each chunk download in array StartTimeData\r\n                            lastChunkWasFinished = false;\r\n                            startTimeData.push({\r\n                                ts: performance.now(), /* jshint ignore:line */\r\n                                bytes: value.length\r\n                            });\r\n                        }\r\n                    }\r\n\r\n                    const boxesInfo = boxParser.findLastTopIsoBoxCompleted(['moov', 'mdat'], remaining, offset);\r\n                    if (boxesInfo.found) {\r\n                        const end = boxesInfo.lastCompletedOffset + boxesInfo.size;\r\n\r\n                        // Store the end time of each chunk download  with its size in array EndTimeData\r\n                        if (calculationMode === Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING) {\r\n                            lastChunkWasFinished = true;\r\n                            endTimeData.push({\r\n                                ts: performance.now(), /* jshint ignore:line */\r\n                                bytes: remaining.length\r\n                            });\r\n                        }\r\n\r\n                        // If we are going to pass full buffer, avoid copying it and pass\r\n                        // complete buffer. Otherwise clone the part of the buffer that is completed\r\n                        // and adjust remaining buffer. A clone is needed because ArrayBuffer of a typed-array\r\n                        // keeps a reference to the original data\r\n                        let data;\r\n                        if (end === remaining.length) {\r\n                            data = remaining;\r\n                            remaining = new Uint8Array();\r\n                        } else {\r\n                            data = new Uint8Array(remaining.subarray(0, end));\r\n                            remaining = remaining.subarray(end);\r\n                        }\r\n                        // Announce progress but don't track traces. Throughput measures are quite unstable\r\n                        // when they are based in small amount of data\r\n                        httpRequest.progress({\r\n                            data: data.buffer,\r\n                            lengthComputable: false,\r\n                            noTrace: true\r\n                        });\r\n\r\n                        offset = 0;\r\n                    } else {\r\n                        offset = boxesInfo.lastCompletedOffset;\r\n                        // Call progress so it generates traces that will be later used to know when the first byte\r\n                        // were received\r\n                        if (!signaledFirstByte) {\r\n                            httpRequest.progress({\r\n                                lengthComputable: false,\r\n                                noTrace: true\r\n                            });\r\n                            signaledFirstByte = true;\r\n                        }\r\n                    }\r\n                }\r\n                read(httpRequest, processResult);\r\n            };\r\n            read(httpRequest, processResult);\r\n        })\r\n            .catch(function (e) {\r\n                if (httpRequest.onerror) {\r\n                    httpRequest.onerror(e);\r\n                }\r\n            });\r\n    }\r\n\r\n    function read(httpRequest, processResult) {\r\n        httpRequest.reader.read()\r\n            .then(processResult)\r\n            .catch(function (e) {\r\n                if (httpRequest.onerror && httpRequest.response.status === 200) {\r\n                    // Error, but response code is 200, trigger error\r\n                    httpRequest.onerror(e);\r\n                }\r\n            });\r\n    }\r\n\r\n    function concatTypedArray(remaining, data) {\r\n        if (remaining.length === 0) {\r\n            return data;\r\n        }\r\n        const result = new Uint8Array(remaining.length + data.length);\r\n        result.set(remaining);\r\n        result.set(data, remaining.length);\r\n        return result;\r\n    }\r\n\r\n    function abort(request) {\r\n        if (request.abortController) {\r\n            // For firefox and edge\r\n            request.abortController.abort();\r\n        } else if (request.reader) {\r\n            // For Chrome\r\n            try {\r\n                request.reader.cancel();\r\n                request.onabort();\r\n            } catch (e) {\r\n                // throw exceptions (TypeError) when reader was previously closed,\r\n                // for example, because a network issue\r\n            }\r\n        }\r\n    }\r\n\r\n    // Compute the download time of a segment\r\n    function calculateDownloadedTime(calculationMode, startTimeData, endTimeData, downloadedData, bytesReceived) {\r\n        switch (calculationMode) {\r\n            case Constants.ABR_FETCH_THROUGHPUT_CALCULATION_MOOF_PARSING:\r\n                return _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData);\r\n            case Constants.ABR_FETCH_THROUGHPUT_CALCULATION_DOWNLOADED_DATA:\r\n                return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\r\n            default:\r\n                return _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived);\r\n        }\r\n    }\r\n\r\n    function _calculateDownloadedTimeByMoofParsing(startTimeData, endTimeData) {\r\n        try {\r\n            let datum, datumE;\r\n            // Filter the first and last chunks in a segment in both arrays [StartTimeData and EndTimeData]\r\n            datum = startTimeData.filter((data, i) => i > 0 && i < startTimeData.length - 1);\r\n            datumE = endTimeData.filter((dataE, i) => i > 0 && i < endTimeData.length - 1);\r\n            // Compute the download time of a segment based on the filtered data [last chunk end time - first chunk beginning time]\r\n            let segDownloadTime = 0;\r\n            if (datum.length > 1) {\r\n                for (let i = 0; i < datum.length; i++) {\r\n                    if (datum[i] && datumE[i]) {\r\n                        let chunkDownladTime = datumE[i].ts - datum[i].ts;\r\n                        segDownloadTime += chunkDownladTime;\r\n                    }\r\n                }\r\n\r\n                return segDownloadTime;\r\n            }\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function _calculateDownloadedTimeByBytesReceived(downloadedData, bytesReceived) {\r\n        try {\r\n            downloadedData = downloadedData.filter(data => data.bytes > ((bytesReceived / 4) / downloadedData.length));\r\n            if (downloadedData.length > 1) {\r\n                let time = 0;\r\n                const avgTimeDistance = (downloadedData[downloadedData.length - 1].ts - downloadedData[0].ts) / downloadedData.length;\r\n                downloadedData.forEach((data, index) => {\r\n                    // To be counted the data has to be over a threshold\r\n                    const next = downloadedData[index + 1];\r\n                    if (next) {\r\n                        const distance = next.ts - data.ts;\r\n                        time += distance < avgTimeDistance ? distance : 0;\r\n                    }\r\n                });\r\n                return time;\r\n            }\r\n            return null;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    instance = {\r\n        load: load,\r\n        abort: abort,\r\n        calculateDownloadedTime: calculateDownloadedTime\r\n    };\r\n\r\n    return instance;\r\n}\r\n\r\nFetchLoader.__dashjs_factory_name = 'FetchLoader';\r\n\r\nconst factory = FactoryMaker.getClassFactory(FetchLoader);\r\nexport default factory;\r\n\r\n"]}