{"version":3,"sources":["../../../../src/streaming/StreamProcessor.js"],"names":["StreamProcessor","config","context","eventBus","getInstance","streamInfo","type","errHandler","mimeType","timelineConverter","adapter","manifestModel","mediaPlayerModel","fragmentModel","abrController","playbackController","mediaController","textController","dashMetrics","settings","boxParser","instance","logger","isDynamic","mediaInfo","mediaInfoArr","bufferController","scheduleController","representationController","liveEdgeFinder","indexHandler","bufferingTime","bufferPruned","setup","getLogger","resetInitialSettings","on","Events","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","priority","EventBus","EVENT_PRIORITY_HIGH","QUALITY_CHANGE_REQUESTED","onQualityChanged","INIT_FRAGMENT_NEEDED","onInitFragmentNeeded","MEDIA_FRAGMENT_NEEDED","onMediaFragmentNeeded","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","BUFFER_LEVEL_UPDATED","onBufferLevelUpdated","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","SEEK_TARGET","onSeekTarget","initialize","mediaSource","hasVideoTrack","create","baseURLController","events","errors","Errors","debug","requestModifier","dashConstants","DashConstants","constants","Constants","urlUtils","manifestInfo","registerStreamType","createBufferControllerForType","getStreamId","id","getType","reset","errored","keepBuffers","unRegisterStreamType","off","isUpdating","e","error","setCurrentRepresentation","convertDataToRepresentationInfo","currentRepresentation","code","SEGMENTS_UPDATE_FAILED_ERROR_CODE","activeStreamId","getStreamController","getActiveStreamInfo","addDVRMetric","representationInfo","getRepresentationInfo","newQuality","pushPlayListTraceMetrics","Date","PlayListTrace","REPRESENTATION_SWITCH_STOP_REASON","createPlaylistTraceMetrics","getTime","getPlaybackRate","addBufferLevel","bufferLevel","getValue","doNotUpdateDVRWindowOnBufferUpdated","addBufferState","state","getBufferTarget","MetricsConstants","BUFFER_EMPTY","isSeeking","REBUFFERING_REASON","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","duration","from","range","calcSegmentAvailabilityRange","getCurrentRepresentation","addDVRInfo","getRepresentationController","setBuffer","buffer","getBufferController","getFragmentModel","updateStreamInfo","newStreamInfo","get","streaming","useAppendWindow","updateAppendWindow","getStreamInfo","selectMediaInfo","newMediaInfo","newRealAdaptation","getRealAdaptation","voRepresentations","getVoRepresentations","realAdaptation","getData","maxQuality","getTopQualityIndexFor","minIdx","getMinAllowedIndexFor","quality","averageThroughput","bitrate","FRAGMENTED_TEXT","getThroughputHistory","getAverageThroughput","getInitialBitrateFor","getQualityForBitrate","getQualityFor","undefined","setMimeType","updateData","addMediaInfo","selectNewMediaInfo","indexOf","push","getMediaInfoArr","getMediaInfo","getMediaSource","setMediaSource","dischargePreBuffer","getScheduleController","voRepresentation","getRepresentationForQuality","isBufferingCompleted","getIsBufferingCompleted","getBufferLevel","sender","getIsTextTrack","isTextEnabled","representationId","appendInitSegment","request","getInitRequest","processInitRequest","getIsPruningInProgress","findNextRequest","seekTarget","replacement","setSeekTarget","NaN","isNaN","startTime","delayLoadingTime","getTimeToLoadDelay","setTimeToLoadDelay","processMediaRequest","probeNextRequest","representation","getNextSegmentRequestIdempotent","requestToReplace","hasSeekTarget","currentTime","getNormalizedTime","time","bufferIsDivided","getRangeAt","playingRange","start","end","hasDiscontinuities","hasDiscontinuitiesAfter","removeExecutedRequestsAfterTime","getFragmentRequest","timeThreshold","ignoreIsFinished","useTime","keepIdx","action","FragmentRequest","ACTION_COMPLETE","isFragmentLoaded","chunk","bytes","eventStreamMedia","getEventsFor","eventStreamTrack","length","getRequests","FragmentModel","FRAGMENT_MODEL_EXECUTED","index","handleInbandEvents","trigger","INBAND_EVENTS","streamId","data","mediaInbandEvents","trackInbandEvents","eventStreams","inbandEvents","concat","i","ln","schemeIdUri","value","isoFile","parse","eventBoxes","getBoxes","sidx","getBox","mediaAnchorTime","earliest_presentation_time","timescale","mediaStartTime","fragmentMediaStartTime","Math","max","event","getEvent","createBuffer","previousBuffers","switchTrackAsked","controller","DashJSError","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","VIDEO","AUDIO","getLiveStartTime","liveStartTime","currentRepresentationInfo","liveEdge","getLiveEdge","findRequestForLiveEdge","lowLatencyEnabled","getLiveDelay","liveDelay","dvrWindowSize","DVRWindowSize","dvrWindowSafetyMargin","isFinite","setLiveDelay","setBufferingTime","resetIndexHandler","resetIndex","options","fragRequest","getSegmentRequestForTime","getNextSegmentRequest","finalisePlayList","reason","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"sEA8BA,gD,mDACA,8D,2DACA,8D,iEACA,qD,2DACA,gE,iEACA,iE,yEACA,oE,qEACA,sF,iFACA,sD,6DACA,kD,yDACA,wDACA,0C,iDACA,6C,6CACA,gD,uDACA,6C,6CACA,6C,uDACA,oC,2CACA,wD,+DACA,qD,iDACA,4C,mDACA,qD,+DACA,+C,mFAnDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqDA,QAASA,gBAAT,CAAyBC,MAAzB,CAAiC,CAE7BA,OAASA,QAAU,EAAnB,CACA,GAAIC,SAAU,KAAKA,OAAnB,CACA,GAAIC,UAAW,uBAASD,OAAT,EAAkBE,WAAlB,EAAf,CAEA,GAAIC,YAAaJ,OAAOI,UAAxB,CACA,GAAIC,MAAOL,OAAOK,IAAlB,CACA,GAAIC,YAAaN,OAAOM,UAAxB,CACA,GAAIC,UAAWP,OAAOO,QAAtB,CACA,GAAIC,mBAAoBR,OAAOQ,iBAA/B,CACA,GAAIC,SAAUT,OAAOS,OAArB,CACA,GAAIC,eAAgBV,OAAOU,aAA3B,CACA,GAAIC,kBAAmBX,OAAOW,gBAA9B,CACA,GAAIC,eAAgBZ,OAAOY,aAA3B,CACA,GAAIC,eAAgBb,OAAOa,aAA3B,CACA,GAAIC,oBAAqBd,OAAOc,kBAAhC,CACA,GAAIC,iBAAkBf,OAAOe,eAA7B,CACA,GAAIC,gBAAiBhB,OAAOgB,cAA5B,CACA,GAAIC,aAAcjB,OAAOiB,WAAzB,CACA,GAAIC,UAAWlB,OAAOkB,QAAtB,CACA,GAAIC,WAAYnB,OAAOmB,SAAvB,CAEA,GAAIC,gBAAJ,CACIC,aADJ,CAEIC,gBAFJ,CAGIC,gBAHJ,CAIIC,mBAJJ,CAKIC,uBALJ,CAMIC,yBANJ,CAOIC,+BAPJ,CAQIC,qBARJ,CASIC,mBATJ,CAUIC,oBAVJ,CAWIC,mBAXJ,CAaA,QAASC,MAAT,EAAiB,CACbX,OAAS,oBAAMpB,OAAN,EAAeE,WAAf,GAA6B8B,SAA7B,CAAuCb,QAAvC,CAAT,CACAc,uBAEAhC,SAASiC,EAAT,CAAYC,iBAAOC,qBAAnB,CAA0CC,qBAA1C,CAAiElB,QAAjE,CAA2E,CAAEmB,SAAUC,mBAASC,mBAArB,CAA3E,EAAwH;AACxHvC,SAASiC,EAAT,CAAYC,iBAAOM,wBAAnB,CAA6CC,gBAA7C,CAA+DvB,QAA/D,EACAlB,SAASiC,EAAT,CAAYC,iBAAOQ,oBAAnB,CAAyCC,oBAAzC,CAA+DzB,QAA/D,EACAlB,SAASiC,EAAT,CAAYC,iBAAOU,qBAAnB,CAA0CC,qBAA1C,CAAiE3B,QAAjE,EACAlB,SAASiC,EAAT,CAAYC,iBAAOY,qBAAnB,CAA0CC,qBAA1C,CAAiE7B,QAAjE,EACAlB,SAASiC,EAAT,CAAYC,iBAAOc,oBAAnB,CAAyCC,oBAAzC,CAA+D/B,QAA/D,EACAlB,SAASiC,EAAT,CAAYC,iBAAOgB,0BAAnB,CAA+CC,yBAA/C,CAA0EjC,QAA1E,EACAlB,SAASiC,EAAT,CAAYC,iBAAOkB,cAAnB,CAAmCC,eAAnC,CAAoDnC,QAApD,EACAlB,SAASiC,EAAT,CAAYC,iBAAOoB,WAAnB,CAAgCC,YAAhC,CAA8CrC,QAA9C,EACH,CAED,QAASsC,WAAT,CAAoBC,WAApB,CAAiCC,aAAjC,CAAgD,CAC5C/B,aAAe,0BAAY5B,OAAZ,EAAqB4D,MAArB,CAA4B,CACvCzD,WAAYA,UAD2B,CAEvCC,KAAMA,IAFiC,CAGvCG,kBAAmBA,iBAHoB,CAIvCS,YAAaA,WAJ0B,CAKvCN,iBAAkBA,gBALqB,CAMvCmD,kBAAmB9D,OAAO8D,iBANa,CAOvCxD,WAAYA,UAP2B,CAQvCY,SAAUA,QAR6B,CASvCC,UAAWA,SAT4B,CAUvC4C,OAAQ3B,gBAV+B,CAWvClC,SAAUA,QAX6B,CAYvC8D,OAAQC,gBAZ+B,CAavCC,MAAO,oBAAMjE,OAAN,EAAeE,WAAf,EAbgC,CAcvCgE,gBAAiB,8BAAgBlE,OAAhB,EAAyBE,WAAzB,EAdsB,CAevCiE,cAAeC,uBAfwB,CAgBvCC,UAAWC,mBAhB4B,CAiBvCC,SAAU,uBAASvE,OAAT,EAAkBE,WAAlB,EAjB6B,CAA5B,CAAf,CAoBA;AACAmB,UAAYlB,WAAWqE,YAAX,CAAwBnD,SAApC,CACA,GAAIA,SAAJ,CAAe,CACXM,eAAiB,6BAAe3B,OAAf,EAAwB4D,MAAxB,CAA+B,CAC5CrD,kBAAmBA,iBADyB,CAA/B,CAAjB,CAGH,CAED;AACAqB,aAAa6B,UAAb,CAAwBpC,SAAxB,EACAT,cAAc6D,kBAAd,CAAiCrE,IAAjC,CAAuCe,QAAvC,EAEAO,yBAA2B,uCAAyB1B,OAAzB,EAAkC4D,MAAlC,CAAyC,CAChEzD,WAAYA,UADoD,CAEhEC,KAAMA,IAF0D,CAGhEQ,cAAeA,aAHiD,CAIhEI,YAAaA,WAJmD,CAKhEH,mBAAoBA,kBAL4C,CAMhEN,kBAAmBA,iBAN6C,CAOhE4D,cAAeC,uBAPiD,CAQhEN,OAAQ3B,gBARwD,CAShElC,SAAUA,QATsD,CAUhE8D,OAAQC,gBAVwD,CAAzC,CAA3B,CAaAxC,iBAAmBkD,8BAA8BtE,IAA9B,CAAnB,CACA,GAAIoB,gBAAJ,CAAsB,CAClBA,iBAAiBiC,UAAjB,CAA4BC,WAA5B,EACH,CAEDjC,mBAAqB,iCAAmBzB,OAAnB,EAA4B4D,MAA5B,CAAmC,CACpDzD,WAAYA,UADwC,CAEpDC,KAAMA,IAF8C,CAGpDE,SAAUA,QAH0C,CAIpDE,QAASA,OAJ2C,CAKpDQ,YAAaA,WALuC,CAMpDN,iBAAkBA,gBANkC,CAOpDC,cAAeA,aAPqC,CAQpDC,cAAeA,aARqC,CASpDC,mBAAoBA,kBATgC,CAUpDE,eAAgBA,cAVoC,CAWpDD,gBAAiBA,eAXmC,CAYpDU,iBAAkBA,gBAZkC,CAapDP,SAAUA,QAb0C,CAAnC,CAArB,CAgBAQ,mBAAmBgC,UAAnB,CAA8BE,aAA9B,EAEA9B,cAAgB,CAAhB,CACAC,aAAe,KAAf,CACH,CAED,QAAS6C,YAAT,EAAuB,CACnB,MAAOxE,YAAWyE,EAAlB,CACH,CAED,QAASC,QAAT,EAAmB,CACf,MAAOzE,KAAP,CACH,CAED,QAAS6B,qBAAT,EAAgC,CAC5BV,aAAe,EAAf,CACAD,UAAY,IAAZ,CACAO,cAAgB,CAAhB,CACH,CAED,QAASiD,MAAT,CAAeC,OAAf,CAAwBC,WAAxB,CAAqC,CACjC,GAAIpD,YAAJ,CAAkB,CACdA,aAAakD,KAAb,GACH,CAED,GAAItD,gBAAJ,CAAsB,CAClBA,iBAAiBsD,KAAjB,CAAuBC,OAAvB,CAAgCC,WAAhC,EACAxD,iBAAmB,IAAnB,CACH,CAED,GAAIC,kBAAJ,CAAwB,CACpBA,mBAAmBqD,KAAnB,GACArD,mBAAqB,IAArB,CACH,CAED,GAAIC,wBAAJ,CAA8B,CAC1BA,yBAAyBoD,KAAzB,GACApD,yBAA2B,IAA3B,CACH,CAED,GAAIC,cAAJ,CAAoB,CAChBA,eAAemD,KAAf,GACAnD,eAAiB,IAAjB,CACH,CAED,GAAIf,eAAiB,CAACoE,WAAtB,CAAmC,CAC/BpE,cAAcqE,oBAAd,CAAmC7E,IAAnC,EACH,CAEDH,SAASiF,GAAT,CAAa/C,iBAAOC,qBAApB,CAA2CC,qBAA3C,CAAkElB,QAAlE,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOM,wBAApB,CAA8CC,gBAA9C,CAAgEvB,QAAhE,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOQ,oBAApB,CAA0CC,oBAA1C,CAAgEzB,QAAhE,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOU,qBAApB,CAA2CC,qBAA3C,CAAkE3B,QAAlE,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOY,qBAApB,CAA2CC,qBAA3C,CAAkE7B,QAAlE,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOc,oBAApB,CAA0CC,oBAA1C,CAAgE/B,QAAhE,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOgB,0BAApB,CAAgDC,yBAAhD,CAA2EjC,QAA3E,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOkB,cAApB,CAAoCC,eAApC,CAAqDnC,QAArD,EACAlB,SAASiF,GAAT,CAAa/C,iBAAOoB,WAApB,CAAiCC,YAAjC,CAA+CrC,QAA/C,EAEAc,uBACA7B,KAAO,IAAP,CACAD,WAAa,IAAb,CACH,CAED,QAASgF,WAAT,EAAsB,CAClB,MAAOzD,0BAA2BA,yBAAyByD,UAAzB,EAA3B,CAAmE,KAA1E,CACH,CAGD,QAAS9C,sBAAT,CAA+B+C,CAA/B,CAAkC,CAC9B,GAAI,CAACA,EAAEC,KAAP,CAAc,CACV;AACA5D,mBAAmB6D,wBAAnB,CAA4C9E,QAAQ+E,+BAAR,CAAwCH,EAAEI,qBAA1C,CAA5C,EACH,CACD,GAAI,CAACJ,EAAEC,KAAH,EAAYD,EAAEC,KAAF,CAAQI,IAAR,GAAiBzB,iBAAO0B,iCAAxC,CAA2E,CACvE;AACA,GAAMC,gBAAiB9E,mBAAmB+E,mBAAnB,GAAyCC,mBAAzC,GAA+DjB,EAAtF,CACA,GAAIe,iBAAmBxF,WAAWyE,EAAlC,CAAsC,CAClCkB,eACH,CACJ,CACJ,CAED,QAASpD,iBAAT,CAA0B0C,CAA1B,CAA6B,CACzB,GAAIW,oBAAqBC,sBAAsBZ,EAAEa,UAAxB,CAAzB,CACAxE,mBAAmB6D,wBAAnB,CAA4CS,kBAA5C,EACA/E,YAAYkF,wBAAZ,CAAqC,GAAIC,KAAJ,EAArC,CAAiDC,wBAAcC,iCAA/D,EACArF,YAAYsF,0BAAZ,CAAuCP,mBAAmBnB,EAA1D,CAA8D/D,mBAAmB0F,OAAnB,GAA+B,IAA7F,CAAmG1F,mBAAmB2F,eAAnB,EAAnG,EACH,CAED,QAAStD,qBAAT,CAA8BkC,CAA9B,CAAiC,CAC7BpE,YAAYyF,cAAZ,CAA2BrG,IAA3B,CAAiC,GAAI+F,KAAJ,EAAjC,CAA6Cf,EAAEsB,WAAF,CAAgB,IAA7D,EACA,GAAMf,gBAAiB9E,mBAAmB+E,mBAAnB,GAAyCC,mBAAzC,GAA+DjB,EAAtF,CACA,GAAI,CAACnE,cAAckG,QAAd,GAAyBC,mCAA1B,EAAiEzG,WAAWyE,EAAX,GAAkBe,cAAvF,CAAuG,CACnGG,eACH,CACJ,CAED,QAAS1C,0BAAT,CAAmCgC,CAAnC,CAAsC,CAClCpE,YAAY6F,cAAZ,CAA2BzG,IAA3B,CAAiCgF,EAAE0B,KAAnC,CAA0CrF,mBAAmBsF,eAAnB,EAA1C,EACA,GAAI3B,EAAE0B,KAAF,GAAYE,2BAAiBC,YAA7B,EAA6C,CAACpG,mBAAmBqG,SAAnB,EAAlD,CAAkF,CAC9E;AACAlG,YAAYkF,wBAAZ,CAAqC,GAAIC,KAAJ,EAArC,CAAiDC,wBAAce,kBAA/D,EACH,CACJ,CAED,QAAS7D,gBAAT,CAAyB8B,CAAzB,CAA4B,CACxB;AACAzE,cAAcyG,qCAAd,CACI5F,iBAAiB6F,SAAjB,GAA6BC,kBAA7B,EADJ,CAEInH,WAAWoH,QAFf,EAIA;AACA,GAAInC,EAAEoC,IAAF,CAAS3G,mBAAmB0F,OAAnB,EAAb,CAA2C,CACvC1E,cAAgBuD,EAAEoC,IAAlB,CACA1F,aAAe,IAAf,CACH,CACJ,CAED,QAASgE,aAAT,EAAwB,CACpB,GAAMtB,cAAerE,WAAWqE,YAAhC,CACA,GAAMnD,WAAYmD,aAAanD,SAA/B,CACA,GAAMoG,OAAQlH,kBAAkBmH,4BAAlB,CAA+ChG,yBAAyBiG,wBAAzB,EAA/C,CAAoGtG,SAApG,CAAd,CACAL,YAAY4G,UAAZ,CAAuB/C,SAAvB,CAAkChE,mBAAmB0F,OAAnB,EAAlC,CAAgE/B,YAAhE,CAA8EiD,KAA9E,EACH,CAED,QAASI,4BAAT,EAAuC,CACnC,MAAOnG,yBAAP,CACH,CAED,QAAS2F,UAAT,EAAqB,CACjB,MAAO7F,kBAAmBA,iBAAiB6F,SAAjB,EAAnB,CAAkD,IAAzD,CACH,CAED,QAASS,UAAT,CAAmBC,MAAnB,CAA2B,CACvBvG,iBAAiBsG,SAAjB,CAA2BC,MAA3B,EACH,CAED,QAASC,oBAAT,EAA+B,CAC3B,MAAOxG,iBAAP,CACH,CAED,QAASyG,iBAAT,EAA4B,CACxB,MAAOtH,cAAP,CACH,CAED,QAASuH,iBAAT,CAA0BC,aAA1B,CAAyC,CACrChI,WAAagI,aAAb,CACA,GAAIlH,SAASmH,GAAT,GAAeC,SAAf,CAAyBC,eAA7B,CAA8C,CAC1C9G,iBAAiB+G,kBAAjB,GACH,CACJ,CAED,QAASC,cAAT,EAAyB,CACrB,MAAOrI,WAAP,CACH,CAED,QAASsI,gBAAT,CAAyBC,YAAzB,CAAuC,CACnC,GAAIA,eAAiBpH,SAAjB,GAA+B,CAACoH,YAAD,EAAiB,CAACpH,SAAlB,EAAgCoH,aAAatI,IAAb,GAAsBkB,UAAUlB,IAA/F,CAAJ,CAA2G,CACvGkB,UAAYoH,YAAZ,CACH,CAED,GAAMC,mBAAoBnI,QAAQoI,iBAAR,CAA0BzI,UAA1B,CAAsCmB,SAAtC,CAA1B,CACA,GAAMuH,mBAAoBrI,QAAQsI,oBAAR,CAA6BxH,SAA7B,CAA1B,CAEA,GAAII,wBAAJ,CAA8B,CAC1B,GAAMqH,gBAAiBrH,yBAAyBsH,OAAzB,EAAvB,CACA,GAAMC,YAAarI,cAAcsI,qBAAd,CAAoC9I,IAApC,CAA0CD,WAAWyE,EAArD,CAAnB,CACA,GAAMuE,QAASvI,cAAcwI,qBAAd,CAAoChJ,IAApC,CAAf,CAEA,GAAIiJ,eAAJ,CACIC,wBADJ,CAEA,GAAIC,SAAU,IAAd,CAEA,GAAI,CAACR,iBAAmB,IAAnB,EAA4BA,eAAenE,EAAf,EAAqB+D,kBAAkB/D,EAApE,GAA4ExE,OAASkE,oBAAUkF,eAAnG,CAAoH,CAChHF,kBAAoB1I,cAAc6I,oBAAd,GAAqCC,oBAArC,CAA0DtJ,IAA1D,CAApB,CACAmJ,QAAUD,mBAAqB1I,cAAc+I,oBAAd,CAAmCvJ,IAAnC,CAA/B,CACAiJ,QAAUzI,cAAcgJ,oBAAd,CAAmCtI,SAAnC,CAA8CiI,OAA9C,CAAV,CACH,CAJD,IAIO,CACHF,QAAUzI,cAAciJ,aAAd,CAA4BzJ,IAA5B,CAAV,CACH,CAED,GAAI+I,SAAWW,SAAX,EAAwBT,QAAUF,MAAtC,CAA8C,CAC1CE,QAAUF,MAAV,CACH,CACD,GAAIE,QAAUJ,UAAd,CAA0B,CACtBI,QAAUJ,UAAV,CACH,CACDrH,aAAamI,WAAb,CAAyBzI,UAAYA,UAAUhB,QAAtB,CAAiC,IAA1D,EACAoB,yBAAyBsI,UAAzB,CAAoCrB,iBAApC,CAAuDE,iBAAvD,CAA0EzI,IAA1E,CAAgFiJ,OAAhF,EACH,CACJ,CAED,QAASY,aAAT,CAAsBvB,YAAtB,CAAoCwB,kBAApC,CAAwD,CACpD,GAAI3I,aAAa4I,OAAb,CAAqBzB,YAArB,IAAuC,CAAC,CAA5C,CAA+C,CAC3CnH,aAAa6I,IAAb,CAAkB1B,YAAlB,EACH,CAED,GAAIwB,kBAAJ,CAAwB,CACpB,KAAKzB,eAAL,CAAqBC,YAArB,EACH,CACJ,CAED,QAAS2B,gBAAT,EAA2B,CACvB,MAAO9I,aAAP,CACH,CAED,QAAS+I,aAAT,EAAwB,CACpB,MAAOhJ,UAAP,CACH,CAED,QAASiJ,eAAT,EAA0B,CACtB,MAAO/I,kBAAiB+I,cAAjB,EAAP,CACH,CAED,QAASC,eAAT,CAAwB9G,WAAxB,CAAqC,CACjClC,iBAAiBgJ,cAAjB,CAAgC9G,WAAhC,CAA6C2G,iBAA7C,EACH,CAED,QAASI,mBAAT,EAA8B,CAC1BjJ,iBAAiBiJ,kBAAjB,GACH,CAED,QAASC,sBAAT,EAAiC,CAC7B,MAAOjJ,mBAAP,CACH,CAED;;;;OAKA,QAASuE,sBAAT,CAA+BqD,OAA/B,CAAwC,CACpC,GAAIsB,wBAAJ,CAEA,GAAItB,UAAYS,SAAhB,CAA2B,CACvB,kCAAaT,OAAb,EACAsB,iBAAmBjJ,yBAA2BA,yBAAyBkJ,2BAAzB,CAAqDvB,OAArD,CAA3B,CAA2F,IAA9G,CACH,CAHD,IAGO,CACHsB,iBAAmBjJ,yBAA2BA,yBAAyBiG,wBAAzB,EAA3B,CAAiF,IAApG,CACH,CAED,MAAOnH,SAAQ+E,+BAAR,CAAwCoF,gBAAxC,CAAP,CACH,CAED,QAASE,qBAAT,EAAgC,CAC5B,MAAOrJ,kBAAmBA,iBAAiBsJ,uBAAjB,EAAnB,CAAgE,KAAvE,CACH,CAED,QAASC,eAAT,EAA0B,CACtB,MAAOvJ,kBAAmBA,iBAAiBuJ,cAAjB,EAAnB,CAAuD,CAA9D,CACH,CAED,QAASnI,qBAAT,CAA8BwC,CAA9B,CAAiC,CAC7B;AACA,GAAI,CAACA,EAAE4F,MAAP,CAAe,OAEf,GAAIxK,QAAQyK,cAAR,CAAuB3K,QAAvB,GAAoC,CAACS,eAAemK,aAAf,EAAzC,CAAyE,OAEzE,GAAI1J,kBAAoB4D,EAAE+F,gBAA1B,CAA4C,CACxC,GAAI,CAAC3J,iBAAiB4J,iBAAjB,CAAmChG,EAAE+F,gBAArC,CAAL,CAA6D,CACzD;AACA,GAAME,SAAUzJ,aAAeA,aAAa0J,cAAb,CAA4BhB,cAA5B,CAA4C5I,yBAAyBiG,wBAAzB,EAA5C,CAAf,CAAkH,IAAlI,CACAlG,mBAAmB8J,kBAAnB,CAAsCF,OAAtC,EACH,CACJ,CACJ,CAED,QAASvI,sBAAT,CAA+BsC,CAA/B,CAAkC,CAC9B,GAAIiG,eAAJ,CAEA;AACA,GAAI,CAAC7J,iBAAiBgK,sBAAjB,EAAL,CAAgD,CAC5CH,QAAUI,gBAAgBrG,EAAEsG,UAAlB,CAA8BtG,EAAEuG,WAAhC,CAAV,CACA,GAAIN,OAAJ,CAAa,CACT5J,mBAAmBmK,aAAnB,CAAiCC,GAAjC,EACA,GAAI,CAACzG,EAAEuG,WAAP,CAAoB,CAChB,GAAI,CAACG,MAAMT,QAAQU,SAAR,CAAoBV,QAAQ9D,QAAlC,CAAL,CAAkD,CAC9C1F,cAAgBwJ,QAAQU,SAAR,CAAoBV,QAAQ9D,QAA5C,CACH,CACD8D,QAAQW,gBAAR,CAA2B,GAAI7F,KAAJ,GAAWI,OAAX,GAAuB9E,mBAAmBwK,kBAAnB,EAAlD,CACAxK,mBAAmByK,kBAAnB,CAAsC,CAAtC,EACH,CACJ,CACJ,CAEDzK,mBAAmB0K,mBAAnB,CAAuCd,OAAvC,EACH,CAED;;;OAIA,QAASe,iBAAT,EAA4B,CACxB,GAAMrG,oBAAqBC,uBAA3B,CAEA,GAAMqG,gBAAiB3K,0BAA4BqE,kBAA5B,CACnBrE,yBAAyBkJ,2BAAzB,CAAqD7E,mBAAmBsD,OAAxE,CADmB,CACgE,IADvF,CAGA,GAAIgC,SAAUzJ,aAAa0K,+BAAb,CACVhC,cADU,CAEV+B,cAFU,CAAd,CAKA,MAAOhB,QAAP,CACH,CAED,QAASI,gBAAT,CAAyBC,UAAzB,CAAqCa,gBAArC,CAAuD,CACnD,GAAMxG,oBAAqBC,uBAA3B,CACA,GAAMwG,eAAgB,CAACV,MAAMJ,UAAN,CAAvB,CACA,GAAMe,aAAc5L,mBAAmB6L,iBAAnB,EAApB,CACA,GAAIC,MAAOH,cAAgBd,UAAhB,CAA6B7J,aAAxC,CACA,GAAI+K,iBAAkB,KAAtB,CACA,GAAIvB,eAAJ,CAEA,GAAIS,MAAMa,IAAN,GAAgB9H,YAAcP,oBAAUkF,eAAxB,EAA2C,CAACzI,eAAemK,aAAf,EAAhE,CAAiG,CAC7F,MAAO,KAAP,CACH,CACD;;aAGA,GAAI1J,gBAAJ,CAAsB,CAClB,GAAIiG,OAAQjG,iBAAiBqL,UAAjB,CAA4BF,IAA5B,CAAZ,CACA,GAAMG,cAAetL,iBAAiBqL,UAAjB,CAA4BJ,WAA5B,CAArB,CACA,GAAI,CAAChF,QAAU,IAAV,EAAkBqF,eAAiB,IAApC,GAA6C,CAACN,aAAlD,CAAiE,CAC7D,GAAI,CAAC/E,KAAD,EAAWqF,cAAgBA,aAAaC,KAAb,EAAsBtF,MAAMsF,KAA5C,EAAqDD,aAAaE,GAAb,EAAoBvF,MAAMuF,GAA9F,CAAoG,CAChG,GAAMC,oBAAqBzL,iBAAiB6F,SAAjB,GAA6B6F,uBAA7B,CAAqDT,WAArD,CAA3B,CACA,GAAIQ,oBAAsBpI,YAAcP,oBAAUkF,eAAlD,CAAmE,CAC/D7I,cAAcwM,+BAAd,CAA8CL,aAAaE,GAA3D,EACAJ,gBAAkB,IAAlB,CACH,CACJ,CACJ,CACJ,CAED,GAAIL,gBAAJ,CAAsB,CAClBI,KAAOJ,iBAAiBR,SAAjB,CAA8BQ,iBAAiBhF,QAAjB,CAA4B,CAAjE,CACA8D,QAAU+B,mBAAmBrH,kBAAnB,CAAuC4G,IAAvC,CAA6C,CACnDU,cAAe,CADoC,CAEnDC,iBAAkB,IAFiC,CAA7C,CAAV,CAIH,CAND,IAMO,CACH;AACA,GAAMC,SAAUf,eAAiB1K,YAAjB,EAAiC8K,eAAjD,CACAvB,QAAU+B,mBAAmBrH,kBAAnB,CACNwH,QAAUZ,IAAV,CAAiB7C,SADX,CACsB,CACxB0D,QAAS,CAACD,OADc,CADtB,CAAV,CAIAzL,aAAe,KAAf,CAEA;AACA,MAAOuJ,SAAWA,QAAQoC,MAAR,GAAmBC,0BAAgBC,eAA9C,EAAiEhN,cAAciN,gBAAd,CAA+BvC,OAA/B,CAAxE,CAAiH,CAC7G;AACAA,QAAU+B,mBAAmBrH,kBAAnB,CAAV,CACH,CACJ,CAED,MAAOsF,QAAP,CACH,CAED,QAASrI,sBAAT,CAA+BoC,CAA/B,CAAkC,CAC9B,GAAMyI,OAAQzI,EAAEyI,KAAhB,CAEA,GAAMC,OAAQD,MAAMC,KAApB,CACA,GAAMzE,SAAUwE,MAAMxE,OAAtB,CACA,GAAM7D,uBAAwBQ,sBAAsBqD,OAAtB,CAA9B,CAEA,GAAMsB,kBAAmBjJ,0BAA4B8D,qBAA5B,CAAoD9D,yBAAyBkJ,2BAAzB,CAAqDpF,sBAAsB6D,OAA3E,CAApD,CAA0I,IAAnK,CACA,GAAM0E,kBAAmBvN,QAAQwN,YAAR,CAAqBxI,sBAAsBlE,SAA3C,CAAzB,CACA,GAAM2M,kBAAmBzN,QAAQwN,YAAR,CAAqBxI,qBAArB,CAA4CmF,gBAA5C,CAAzB,CAEA,GAAIoD,kBAAoBA,iBAAiBG,MAAjB,CAA0B,CAA9C,EAAmDD,kBAAoBA,iBAAiBC,MAAjB,CAA0B,CAArG,CAAwG,CACpG,GAAM7C,SAAU1K,cAAcwN,WAAd,CAA0B,CACtCrH,MAAOsH,wBAAcC,uBADiB,CAEtChF,QAASA,OAF6B,CAGtCiF,MAAOT,MAAMS,KAHyB,CAA1B,EAIb,CAJa,CAAhB,CAMA,GAAMxK,QAASyK,mBAAmBT,KAAnB,CAA0BzC,OAA1B,CAAmC0C,gBAAnC,CAAqDE,gBAArD,CAAf,CACAhO,SAASuO,OAAT,CAAiBrM,iBAAOsM,aAAxB,CACI,CAAE3K,OAAQA,MAAV,CADJ,CAEI,CAAE4K,SAAUvO,WAAWyE,EAAvB,CAFJ,EAIH,CACJ,CAED,QAAS2J,mBAAT,CAA4BI,IAA5B,CAAkCtD,OAAlC,CAA2CuD,iBAA3C,CAA8DC,iBAA9D,CAAiF,CAC7E,GAAI,CACA,GAAMC,cAAe,EAArB,CACA,GAAMhL,QAAS,EAAf,CAEA,oKACA,GAAMiL,cAAeH,kBAAkBI,MAAlB,CAAyBH,iBAAzB,CAArB,CACA,IAAK,GAAII,GAAI,CAAR,CAAWC,GAAKH,aAAab,MAAlC,CAA0Ce,EAAIC,EAA9C,CAAkDD,GAAlD,CAAuD,CACnDH,aAAaC,aAAaE,CAAb,EAAgBE,WAAhB,CAA8B,GAA9B,CAAoCJ,aAAaE,CAAb,EAAgBG,KAAjE,EAA0EL,aAAaE,CAAb,CAA1E,CACH,CAED,GAAMI,SAAU,wBAAUrP,OAAV,EAAmBE,WAAnB,GAAiCoP,KAAjC,CAAuCX,IAAvC,CAAhB,CACA,GAAMY,YAAaF,QAAQG,QAAR,CAAiB,MAAjB,CAAnB,CAEA,GAAI,CAACD,UAAD,EAAeA,WAAWrB,MAAX,GAAsB,CAAzC,CAA4C,CACxC,MAAOpK,OAAP,CACH,CAED,GAAM2L,MAAOJ,QAAQK,MAAR,CAAe,MAAf,CAAb,CACA,GAAMC,iBAAkBF,MAAQ,CAAC3D,MAAM2D,KAAKG,0BAAX,CAAT,EAAmD,CAAC9D,MAAM2D,KAAKI,SAAX,CAApD,CAA4EJ,KAAKG,0BAAL,CAAkCH,KAAKI,SAAnH,CAA+HxE,SAAW,CAACS,MAAMT,QAAQyE,cAAd,CAAZ,CAA4CzE,QAAQyE,cAApD,CAAqE,CAA5N,CACA,GAAMC,wBAAyBC,KAAKC,GAAL,CAASN,eAAT,CAA0B,CAA1B,CAA/B,CACA,GAAMhF,kBAAmBjJ,yBAAyBiG,wBAAzB,EAAzB,CAEA,IAAK,GAAIsH,IAAI,CAAR,CAAWC,IAAKK,WAAWrB,MAAhC,CAAwCe,GAAIC,GAA5C,CAAgDD,IAAhD,CAAqD,CACjD,GAAMiB,OAAQ1P,QAAQ2P,QAAR,CAAiBZ,WAAWN,EAAX,CAAjB,CAAgCH,YAAhC,CAA8CiB,sBAA9C,CAAsEpF,gBAAtE,CAAd,CAEA,GAAIuF,KAAJ,CAAW,CACPpM,OAAOsG,IAAP,CAAY8F,KAAZ,EACH,CACJ,CAED,MAAOpM,OAAP,CACH,CAAC,MAAOsB,CAAP,CAAU,CACR,MAAO,EAAP,CACH,CACJ,CAED,QAASgL,aAAT,CAAsBC,eAAtB,CAAuC,CACnC,MAAQhJ,cAAe7F,gBAAf,CAAkCA,iBAAiB4O,YAAjB,CAA8B7O,YAA9B,CAA4C8O,eAA5C,CAAlC,CAAiG,IAAzG,CACH,CAED,QAASC,iBAAT,EAA4B,CACxB7O,mBAAmB6O,gBAAnB,GACH,CAED,QAAS5L,8BAAT,CAAuCtE,IAAvC,CAA6C,CACzC,GAAImQ,YAAa,IAAjB,CAEA,GAAI,CAACnQ,IAAL,CAAW,CACPC,WAAWgF,KAAX,CAAiB,GAAImL,sBAAJ,CAAgBxM,iBAAOyM,iCAAvB,CAA0DzM,iBAAO0M,oCAAP,CAA8C,sBAAxG,CAAjB,EACA,MAAO,KAAP,CACH,CAED,GAAItQ,OAASkE,oBAAUqM,KAAnB,EAA4BvQ,OAASkE,oBAAUsM,KAAnD,CAA0D,CACtDL,WAAa,+BAAiBvQ,OAAjB,EAA0B4D,MAA1B,CAAiC,CAC1CzD,WAAYA,UAD8B,CAE1CC,KAAMA,IAFoC,CAG1CM,iBAAkBA,gBAHwB,CAI1CD,cAAeA,aAJ2B,CAK1CE,cAAeA,aAL2B,CAM1CN,WAAYA,UAN8B,CAO1CS,gBAAiBA,eAPyB,CAQ1CY,yBAA0BA,wBARgB,CAS1ClB,QAASA,OATiC,CAU1CO,eAAgBA,cAV0B,CAW1CH,cAAeA,aAX2B,CAY1CC,mBAAoBA,kBAZsB,CAa1CI,SAAUA,QAbgC,CAAjC,CAAb,CAeH,CAhBD,IAgBO,CACHsP,WAAa,mCAAqBvQ,OAArB,EAA8B4D,MAA9B,CAAqC,CAC9CzD,WAAYA,UADkC,CAE9CC,KAAMA,IAFwC,CAG9CE,SAAUA,QAHoC,CAI9CI,iBAAkBA,gBAJ4B,CAK9CD,cAAeA,aAL+B,CAM9CE,cAAeA,aAN+B,CAO9CN,WAAYA,UAPkC,CAQ9CS,gBAAiBA,eAR6B,CAS9CY,yBAA0BA,wBAToB,CAU9ClB,QAASA,OAVqC,CAW9CO,eAAgBA,cAX8B,CAY9CH,cAAeA,aAZ+B,CAa9CC,mBAAoBA,kBAb0B,CAc9CI,SAAUA,QAdoC,CAArC,CAAb,CAgBH,CAED,MAAOsP,WAAP,CACH,CAGD,QAASM,iBAAT,EAA4B,CACxB,GAAI,CAACxP,SAAL,CAAgB,MAAOwK,IAAP,CAChB,GAAI,CAAClK,cAAL,CAAqB,MAAOkK,IAAP,CAErB,GAAIiF,eAAgBjF,GAApB,CACA,GAAMkF,2BAA4B/K,uBAAlC,CACA,GAAMgL,UAAWrP,eAAesP,WAAf,CAA2BF,yBAA3B,CAAjB,CAEA,GAAIjF,MAAMkF,QAAN,CAAJ,CAAqB,CACjB,MAAOnF,IAAP,CACH,CAED,GAAMR,SAAU6F,uBAAuBF,QAAvB,CAAiCD,yBAAjC,CAAhB,CAEA,GAAI1F,OAAJ,CAAa,CACT;AACA;AACA,GAAIpK,SAASmH,GAAT,GAAeC,SAAf,CAAyB8I,iBAA7B,CAAgD,CAC5CL,cAAgBzF,QAAQ9D,QAAR,CAAmB7G,iBAAiB0Q,YAAjB,EAAnB,CAAqD/F,QAAQU,SAA7D,CAAyEV,QAAQU,SAAR,CAAoBV,QAAQ9D,QAA5B,CAAuC7G,iBAAiB0Q,YAAjB,EAAhI,CACH,CAFD,IAEO,CACHN,cAAgBzF,QAAQU,SAAxB,CACH,CACJ,CAED,MAAO+E,cAAP,CACH,CAED,QAASI,uBAAT,CAAgCF,QAAhC,CAA0CD,yBAA1C,CAAqE,CACjE,GAAI,CACA,GAAI1F,SAAU,IAAd,CACA,GAAIgG,WAAYxQ,mBAAmBuQ,YAAnB,EAAhB,CACA,GAAME,eAAgB,CAACxF,MAAM3L,WAAWqE,YAAX,CAAwB+M,aAA9B,CAAD,CAAgDpR,WAAWqE,YAAX,CAAwB+M,aAAxE,CAAwFF,SAA9G,CACA,GAAMG,uBAAwB,IAAMF,aAApC,CACA,GAAIvF,iBAAJ,CAEA;AACA,GAAI,CAAC0F,SAASH,aAAT,CAAD,EAA4BlE,mBAAmB2D,yBAAnB,CAA8CC,SAAWM,aAAX,CAA2BE,qBAAzE,CAAgG,CAC5HlE,iBAAkB,IAD0G,CAAhG,CAAhC,CAEI,CAEA;AACA,MAAO,CAACjC,OAAD,EAAYgG,WAAaC,aAAhC,CAA+C,CAC3CvF,UAAYiF,SAAWK,SAAvB,CACAhG,QAAU+B,mBAAmB2D,yBAAnB,CAA8ChF,SAA9C,CAAyD,CAC/DuB,iBAAkB,IAD6C,CAAzD,CAAV,CAGA,GAAI,CAACjC,OAAL,CAAc,CACVgG,WAAa,CAAb,CAAgB;AACnB,CACJ,CACJ,CAED,GAAIhG,OAAJ,CAAa,CACTxK,mBAAmB6Q,YAAnB,CAAgCL,SAAhC,CAA2C,IAA3C,EACH,CACDjQ,OAAO6C,KAAP,CAAa,cAAgB+M,QAAhB,CAA2B,gBAA3B,CAA8CK,SAA9C,CAA0D,iBAA1D,CAA8EtF,SAA3F,EACA,MAAOV,QAAP,CACH,CAAC,MAAOjG,CAAP,CAAU,CACR,MAAO,KAAP,CACH,CACJ,CAED,QAAS5B,aAAT,CAAsB4B,CAAtB,CAAyB,CACrBvD,cAAgBuD,EAAEuH,IAAlB,CACAlL,mBAAmBmK,aAAnB,CAAiCxG,EAAEuH,IAAnC,EACH,CAED,QAASgF,iBAAT,CAA0BvC,KAA1B,CAAiC,CAC7BvN,cAAgBuN,KAAhB,CACH,CAED,QAASwC,kBAAT,EAA6B,CACzB,GAAIhQ,YAAJ,CAAkB,CACdA,aAAaiQ,UAAb,GACH,CACJ,CAED,QAASvG,eAAT,CAAwBjC,OAAxB,CAAiC,CAC7B,kCAAaA,OAAb,EACA,GAAMgD,gBAAiB3K,yBAA2BA,yBAAyBkJ,2BAAzB,CAAqDvB,OAArD,CAA3B,CAA2F,IAAlH,CACA,MAAOzH,cAAeA,aAAa0J,cAAb,CAA4BhB,cAA5B,CAA4C+B,cAA5C,CAAf,CAA6E,IAApF,CACH,CAED,QAASe,mBAAT,CAA4BrH,kBAA5B,CAAgD4G,IAAhD,CAAsDmF,OAAtD,CAA+D,CAC3D,GAAIC,aAAc,IAAlB,CAEA,GAAInQ,YAAJ,CAAkB,CACd,GAAMyK,gBAAiB3K,0BAA4BqE,kBAA5B,CAAiDrE,yBAAyBkJ,2BAAzB,CAAqD7E,mBAAmBsD,OAAxE,CAAjD,CAAoI,IAA3J,CAEA;AACA;AACA,GAAIsD,OAAS7C,SAAT,EAAsBgI,UAAYhI,SAAtC,CAAiD,CAC7CiI,YAAcnQ,aAAaoQ,wBAAb,CAAsC1H,cAAtC,CAAsD+B,cAAtD,CAAsEM,IAAtE,CAA4EmF,OAA5E,CAAd,CACH,CAFD,IAEO,CACHC,YAAcnQ,aAAaqQ,qBAAb,CAAmC3H,cAAnC,CAAmD+B,cAAnD,CAAd,CACH,CACJ,CAED,MAAO0F,YAAP,CACH,CAED,QAASG,iBAAT,CAA0BvF,IAA1B,CAAgCwF,MAAhC,CAAwC,CACpCnR,YAAYkF,wBAAZ,CAAqCyG,IAArC,CAA2CwF,MAA3C,EACH,CAEDhR,SAAW,CACPsC,WAAYA,UADL,CAEPkB,YAAaA,WAFN,CAGPE,QAASA,OAHF,CAIPM,WAAYA,UAJL,CAKP6C,oBAAqBA,mBALd,CAMPC,iBAAkBA,gBANX,CAOPyC,sBAAuBA,qBAPhB,CAQP7C,4BAA6BA,2BARtB,CASP7B,sBAAuBA,qBAThB,CAUP+E,eAAgBA,cAVT,CAWPF,qBAAsBA,oBAXf,CAYPuF,aAAcA,YAZP,CAaPlI,iBAAkBA,gBAbX,CAcPM,cAAeA,aAdR,CAePC,gBAAiBA,eAfV,CAgBPwB,aAAcA,YAhBP,CAiBP4G,iBAAkBA,gBAjBX,CAkBPP,iBAAkBA,gBAlBX,CAmBPjG,gBAAiBA,eAnBV,CAoBPC,aAAcA,YApBP,CAqBPC,eAAgBA,cArBT,CAsBPC,eAAgBA,cAtBT,CAuBPC,mBAAoBA,kBAvBb,CAwBPpD,UAAWA,SAxBJ,CAyBPS,UAAWA,SAzBJ,CA0BP6J,iBAAkBA,gBA1BX,CA2BPC,kBAAmBA,iBA3BZ,CA4BPtG,eAAgBA,cA5BT,CA6BP8B,mBAAoBA,kBA7Bb,CA8BP8E,iBAAkBA,gBA9BX,CA+BP9F,iBAAkBA,gBA/BX,CAgCPtH,MAAOA,KAhCA,CAAX,CAmCA/C,QAEA,MAAOZ,SAAP,CACH,CAEDrB,gBAAgBsS,qBAAhB,CAAwC,iBAAxC,C,gBACeC,uBAAaC,eAAb,CAA6BxS,eAA7B,C","file":"StreamProcessor.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from './constants/Constants';\r\nimport DashConstants from '../dash/constants/DashConstants';\r\nimport MetricsConstants from './constants/MetricsConstants';\r\nimport FragmentModel from './models/FragmentModel';\r\nimport BufferController from './controllers/BufferController';\r\nimport TextBufferController from './text/TextBufferController';\r\nimport ScheduleController from './controllers/ScheduleController';\r\nimport RepresentationController from '../dash/controllers/RepresentationController';\r\nimport LiveEdgeFinder from './utils/LiveEdgeFinder';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport {checkInteger} from './utils/SupervisorTools';\r\nimport EventBus from '../core/EventBus';\r\nimport Events from '../core/events/Events';\r\nimport DashHandler from '../dash/DashHandler';\r\nimport Errors from '../core/errors/Errors';\r\nimport DashJSError from './vo/DashJSError';\r\nimport Debug from '../core/Debug';\r\nimport RequestModifier from './utils/RequestModifier';\r\nimport URLUtils from '../streaming/utils/URLUtils';\r\nimport BoxParser from './utils/BoxParser';\r\nimport FragmentRequest from './vo/FragmentRequest';\r\nimport {PlayListTrace} from './vo/metrics/PlayList';\r\n\r\nfunction StreamProcessor(config) {\r\n\r\n    config = config || {};\r\n    let context = this.context;\r\n    let eventBus = EventBus(context).getInstance();\r\n\r\n    let streamInfo = config.streamInfo;\r\n    let type = config.type;\r\n    let errHandler = config.errHandler;\r\n    let mimeType = config.mimeType;\r\n    let timelineConverter = config.timelineConverter;\r\n    let adapter = config.adapter;\r\n    let manifestModel = config.manifestModel;\r\n    let mediaPlayerModel = config.mediaPlayerModel;\r\n    let fragmentModel = config.fragmentModel;\r\n    let abrController = config.abrController;\r\n    let playbackController = config.playbackController;\r\n    let mediaController = config.mediaController;\r\n    let textController = config.textController;\r\n    let dashMetrics = config.dashMetrics;\r\n    let settings = config.settings;\r\n    let boxParser = config.boxParser;\r\n\r\n    let instance,\r\n        logger,\r\n        isDynamic,\r\n        mediaInfo,\r\n        mediaInfoArr,\r\n        bufferController,\r\n        scheduleController,\r\n        representationController,\r\n        liveEdgeFinder,\r\n        indexHandler,\r\n        bufferingTime,\r\n        bufferPruned;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance, { priority: EventBus.EVENT_PRIORITY_HIGH }); // High priority to be notified before Stream\r\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\r\n        eventBus.on(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\r\n        eventBus.on(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\r\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\r\n        eventBus.on(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\r\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\r\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, instance);\r\n        eventBus.on(Events.SEEK_TARGET, onSeekTarget, instance);\r\n    }\r\n\r\n    function initialize(mediaSource, hasVideoTrack) {\r\n        indexHandler = DashHandler(context).create({\r\n            streamInfo: streamInfo,\r\n            type: type,\r\n            timelineConverter: timelineConverter,\r\n            dashMetrics: dashMetrics,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            baseURLController: config.baseURLController,\r\n            errHandler: errHandler,\r\n            settings: settings,\r\n            boxParser: boxParser,\r\n            events: Events,\r\n            eventBus: eventBus,\r\n            errors: Errors,\r\n            debug: Debug(context).getInstance(),\r\n            requestModifier: RequestModifier(context).getInstance(),\r\n            dashConstants: DashConstants,\r\n            constants: Constants,\r\n            urlUtils: URLUtils(context).getInstance()\r\n        });\r\n\r\n        // Create live edge finder for dynamic streams\r\n        isDynamic = streamInfo.manifestInfo.isDynamic;\r\n        if (isDynamic) {\r\n            liveEdgeFinder = LiveEdgeFinder(context).create({\r\n                timelineConverter: timelineConverter\r\n            });\r\n        }\r\n\r\n        // Create/initialize controllers\r\n        indexHandler.initialize(isDynamic);\r\n        abrController.registerStreamType(type, instance);\r\n\r\n        representationController = RepresentationController(context).create({\r\n            streamInfo: streamInfo,\r\n            type: type,\r\n            abrController: abrController,\r\n            dashMetrics: dashMetrics,\r\n            playbackController: playbackController,\r\n            timelineConverter: timelineConverter,\r\n            dashConstants: DashConstants,\r\n            events: Events,\r\n            eventBus: eventBus,\r\n            errors: Errors\r\n        });\r\n\r\n        bufferController = createBufferControllerForType(type);\r\n        if (bufferController) {\r\n            bufferController.initialize(mediaSource);\r\n        }\r\n\r\n        scheduleController = ScheduleController(context).create({\r\n            streamInfo: streamInfo,\r\n            type: type,\r\n            mimeType: mimeType,\r\n            adapter: adapter,\r\n            dashMetrics: dashMetrics,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            fragmentModel: fragmentModel,\r\n            abrController: abrController,\r\n            playbackController: playbackController,\r\n            textController: textController,\r\n            mediaController: mediaController,\r\n            bufferController: bufferController,\r\n            settings: settings\r\n        });\r\n\r\n        scheduleController.initialize(hasVideoTrack);\r\n\r\n        bufferingTime = 0;\r\n        bufferPruned = false;\r\n    }\r\n\r\n    function getStreamId() {\r\n        return streamInfo.id;\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        mediaInfoArr = [];\r\n        mediaInfo = null;\r\n        bufferingTime = 0;\r\n    }\r\n\r\n    function reset(errored, keepBuffers) {\r\n        if (indexHandler) {\r\n            indexHandler.reset();\r\n        }\r\n\r\n        if (bufferController) {\r\n            bufferController.reset(errored, keepBuffers);\r\n            bufferController = null;\r\n        }\r\n\r\n        if (scheduleController) {\r\n            scheduleController.reset();\r\n            scheduleController = null;\r\n        }\r\n\r\n        if (representationController) {\r\n            representationController.reset();\r\n            representationController = null;\r\n        }\r\n\r\n        if (liveEdgeFinder) {\r\n            liveEdgeFinder.reset();\r\n            liveEdgeFinder = null;\r\n        }\r\n\r\n        if (abrController && !keepBuffers) {\r\n            abrController.unRegisterStreamType(type);\r\n        }\r\n\r\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, instance);\r\n        eventBus.off(Events.INIT_FRAGMENT_NEEDED, onInitFragmentNeeded, instance);\r\n        eventBus.off(Events.MEDIA_FRAGMENT_NEEDED, onMediaFragmentNeeded, instance);\r\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\r\n        eventBus.off(Events.BUFFER_LEVEL_UPDATED, onBufferLevelUpdated, instance);\r\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, instance);\r\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, instance);\r\n        eventBus.off(Events.SEEK_TARGET, onSeekTarget, instance);\r\n\r\n        resetInitialSettings();\r\n        type = null;\r\n        streamInfo = null;\r\n    }\r\n\r\n    function isUpdating() {\r\n        return representationController ? representationController.isUpdating() : false;\r\n    }\r\n\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        if (!e.error) {\r\n            // Update representation if no error\r\n            scheduleController.setCurrentRepresentation(adapter.convertDataToRepresentationInfo(e.currentRepresentation));\r\n        }\r\n        if (!e.error || e.error.code === Errors.SEGMENTS_UPDATE_FAILED_ERROR_CODE) {\r\n            // Update has been postponed, update nevertheless DVR info\r\n            const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\r\n            if (activeStreamId === streamInfo.id) {\r\n                addDVRMetric();\r\n            }\r\n        }\r\n    }\r\n\r\n    function onQualityChanged(e) {\r\n        let representationInfo = getRepresentationInfo(e.newQuality);\r\n        scheduleController.setCurrentRepresentation(representationInfo);\r\n        dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\r\n        dashMetrics.createPlaylistTraceMetrics(representationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\r\n    }\r\n\r\n    function onBufferLevelUpdated(e) {\r\n        dashMetrics.addBufferLevel(type, new Date(), e.bufferLevel * 1000);\r\n        const activeStreamId = playbackController.getStreamController().getActiveStreamInfo().id;\r\n        if (!manifestModel.getValue().doNotUpdateDVRWindowOnBufferUpdated && streamInfo.id === activeStreamId) {\r\n            addDVRMetric();\r\n        }\r\n    }\r\n\r\n    function onBufferLevelStateChanged(e) {\r\n        dashMetrics.addBufferState(type, e.state, scheduleController.getBufferTarget());\r\n        if (e.state === MetricsConstants.BUFFER_EMPTY && !playbackController.isSeeking()) {\r\n            // logger.info('Buffer is empty! Stalling!');\r\n            dashMetrics.pushPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\r\n        }\r\n    }\r\n\r\n    function onBufferCleared(e) {\r\n        // Remove executed requests not buffered anymore\r\n        fragmentModel.syncExecutedRequestsWithBufferedRange(\r\n            bufferController.getBuffer().getAllBufferRanges(),\r\n            streamInfo.duration);\r\n\r\n        // If buffer removed ahead current time (QuotaExceededError or automatic buffer pruning) then adjust current index handler time\r\n        if (e.from > playbackController.getTime()) {\r\n            bufferingTime = e.from;\r\n            bufferPruned = true;\r\n        }\r\n    }\r\n\r\n    function addDVRMetric() {\r\n        const manifestInfo = streamInfo.manifestInfo;\r\n        const isDynamic = manifestInfo.isDynamic;\r\n        const range = timelineConverter.calcSegmentAvailabilityRange(representationController.getCurrentRepresentation(), isDynamic);\r\n        dashMetrics.addDVRInfo(getType(), playbackController.getTime(), manifestInfo, range);\r\n    }\r\n\r\n    function getRepresentationController() {\r\n        return representationController;\r\n    }\r\n\r\n    function getBuffer() {\r\n        return bufferController ? bufferController.getBuffer() : null;\r\n    }\r\n\r\n    function setBuffer(buffer) {\r\n        bufferController.setBuffer(buffer);\r\n    }\r\n\r\n    function getBufferController() {\r\n        return bufferController;\r\n    }\r\n\r\n    function getFragmentModel() {\r\n        return fragmentModel;\r\n    }\r\n\r\n    function updateStreamInfo(newStreamInfo) {\r\n        streamInfo = newStreamInfo;\r\n        if (settings.get().streaming.useAppendWindow) {\r\n            bufferController.updateAppendWindow();\r\n        }\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function selectMediaInfo(newMediaInfo) {\r\n        if (newMediaInfo !== mediaInfo && (!newMediaInfo || !mediaInfo || (newMediaInfo.type === mediaInfo.type))) {\r\n            mediaInfo = newMediaInfo;\r\n        }\r\n\r\n        const newRealAdaptation = adapter.getRealAdaptation(streamInfo, mediaInfo);\r\n        const voRepresentations = adapter.getVoRepresentations(mediaInfo);\r\n\r\n        if (representationController) {\r\n            const realAdaptation = representationController.getData();\r\n            const maxQuality = abrController.getTopQualityIndexFor(type, streamInfo.id);\r\n            const minIdx = abrController.getMinAllowedIndexFor(type);\r\n\r\n            let quality,\r\n                averageThroughput;\r\n            let bitrate = null;\r\n\r\n            if ((realAdaptation === null || (realAdaptation.id != newRealAdaptation.id)) && type !== Constants.FRAGMENTED_TEXT) {\r\n                averageThroughput = abrController.getThroughputHistory().getAverageThroughput(type);\r\n                bitrate = averageThroughput || abrController.getInitialBitrateFor(type);\r\n                quality = abrController.getQualityForBitrate(mediaInfo, bitrate);\r\n            } else {\r\n                quality = abrController.getQualityFor(type);\r\n            }\r\n\r\n            if (minIdx !== undefined && quality < minIdx) {\r\n                quality = minIdx;\r\n            }\r\n            if (quality > maxQuality) {\r\n                quality = maxQuality;\r\n            }\r\n            indexHandler.setMimeType(mediaInfo ? mediaInfo.mimeType : null);\r\n            representationController.updateData(newRealAdaptation, voRepresentations, type, quality);\r\n        }\r\n    }\r\n\r\n    function addMediaInfo(newMediaInfo, selectNewMediaInfo) {\r\n        if (mediaInfoArr.indexOf(newMediaInfo) === -1) {\r\n            mediaInfoArr.push(newMediaInfo);\r\n        }\r\n\r\n        if (selectNewMediaInfo) {\r\n            this.selectMediaInfo(newMediaInfo);\r\n        }\r\n    }\r\n\r\n    function getMediaInfoArr() {\r\n        return mediaInfoArr;\r\n    }\r\n\r\n    function getMediaInfo() {\r\n        return mediaInfo;\r\n    }\r\n\r\n    function getMediaSource() {\r\n        return bufferController.getMediaSource();\r\n    }\r\n\r\n    function setMediaSource(mediaSource) {\r\n        bufferController.setMediaSource(mediaSource, getMediaInfoArr());\r\n    }\r\n\r\n    function dischargePreBuffer() {\r\n        bufferController.dischargePreBuffer();\r\n    }\r\n\r\n    function getScheduleController() {\r\n        return scheduleController;\r\n    }\r\n\r\n    /**\r\n     * Get a specific voRepresentation. If quality parameter is defined, this function will return the voRepresentation for this quality.\r\n     * Otherwise, this function will return the current voRepresentation used by the representationController.\r\n     * @param {number} quality - quality index of the voRepresentaion expected.\r\n     */\r\n    function getRepresentationInfo(quality) {\r\n        let voRepresentation;\r\n\r\n        if (quality !== undefined) {\r\n            checkInteger(quality);\r\n            voRepresentation = representationController ? representationController.getRepresentationForQuality(quality) : null;\r\n        } else {\r\n            voRepresentation = representationController ? representationController.getCurrentRepresentation() : null;\r\n        }\r\n\r\n        return adapter.convertDataToRepresentationInfo(voRepresentation);\r\n    }\r\n\r\n    function isBufferingCompleted() {\r\n        return bufferController ? bufferController.getIsBufferingCompleted() : false;\r\n    }\r\n\r\n    function getBufferLevel() {\r\n        return bufferController ? bufferController.getBufferLevel() : 0;\r\n    }\r\n\r\n    function onInitFragmentNeeded(e) {\r\n        // Event propagation may have been stopped (see MssHandler)\r\n        if (!e.sender) return;\r\n\r\n        if (adapter.getIsTextTrack(mimeType) && !textController.isTextEnabled()) return;\r\n\r\n        if (bufferController && e.representationId) {\r\n            if (!bufferController.appendInitSegment(e.representationId)) {\r\n                // Init segment not in cache, send new request\r\n                const request = indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representationController.getCurrentRepresentation()) : null;\r\n                scheduleController.processInitRequest(request);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onMediaFragmentNeeded(e) {\r\n        let request;\r\n\r\n        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\r\n        if (!bufferController.getIsPruningInProgress()) {\r\n            request = findNextRequest(e.seekTarget, e.replacement);\r\n            if (request) {\r\n                scheduleController.setSeekTarget(NaN);\r\n                if (!e.replacement) {\r\n                    if (!isNaN(request.startTime + request.duration)) {\r\n                        bufferingTime = request.startTime + request.duration;\r\n                    }\r\n                    request.delayLoadingTime = new Date().getTime() + scheduleController.getTimeToLoadDelay();\r\n                    scheduleController.setTimeToLoadDelay(0);\r\n                }\r\n            }\r\n        }\r\n\r\n        scheduleController.processMediaRequest(request);\r\n    }\r\n\r\n    /**\r\n     * Probe the next request. This is used in the CMCD model to get information about the upcoming request. Note: No actual request is performed here.\r\n     * @return {FragmentRequest|null}\r\n     */\r\n    function probeNextRequest() {\r\n        const representationInfo = getRepresentationInfo();\r\n\r\n        const representation = representationController && representationInfo ?\r\n            representationController.getRepresentationForQuality(representationInfo.quality) : null;\r\n\r\n        let request = indexHandler.getNextSegmentRequestIdempotent(\r\n            getMediaInfo(),\r\n            representation\r\n        );\r\n\r\n        return request;\r\n    }\r\n\r\n    function findNextRequest(seekTarget, requestToReplace) {\r\n        const representationInfo = getRepresentationInfo();\r\n        const hasSeekTarget = !isNaN(seekTarget);\r\n        const currentTime = playbackController.getNormalizedTime();\r\n        let time = hasSeekTarget ? seekTarget : bufferingTime;\r\n        let bufferIsDivided = false;\r\n        let request;\r\n\r\n        if (isNaN(time) || (getType() === Constants.FRAGMENTED_TEXT && !textController.isTextEnabled())) {\r\n            return null;\r\n        }\r\n        /**\r\n         * This is critical for IE/Safari/EDGE\r\n         * */\r\n        if (bufferController) {\r\n            let range = bufferController.getRangeAt(time);\r\n            const playingRange = bufferController.getRangeAt(currentTime);\r\n            if ((range !== null || playingRange !== null) && !hasSeekTarget) {\r\n                if (!range || (playingRange && playingRange.start != range.start && playingRange.end != range.end)) {\r\n                    const hasDiscontinuities = bufferController.getBuffer().hasDiscontinuitiesAfter(currentTime);\r\n                    if (hasDiscontinuities && getType() !== Constants.FRAGMENTED_TEXT) {\r\n                        fragmentModel.removeExecutedRequestsAfterTime(playingRange.end);\r\n                        bufferIsDivided = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (requestToReplace) {\r\n            time = requestToReplace.startTime + (requestToReplace.duration / 2);\r\n            request = getFragmentRequest(representationInfo, time, {\r\n                timeThreshold: 0,\r\n                ignoreIsFinished: true\r\n            });\r\n        } else {\r\n            // Use time just whenever is strictly needed\r\n            const useTime = hasSeekTarget || bufferPruned || bufferIsDivided;\r\n            request = getFragmentRequest(representationInfo,\r\n                useTime ? time : undefined, {\r\n                    keepIdx: !useTime\r\n                });\r\n            bufferPruned = false;\r\n\r\n            // Then, check if this request was downloaded or not\r\n            while (request && request.action !== FragmentRequest.ACTION_COMPLETE && fragmentModel.isFragmentLoaded(request)) {\r\n                // loop until we found not loaded fragment, or no fragment\r\n                request = getFragmentRequest(representationInfo);\r\n            }\r\n        }\r\n\r\n        return request;\r\n    }\r\n\r\n    function onMediaFragmentLoaded(e) {\r\n        const chunk = e.chunk;\r\n\r\n        const bytes = chunk.bytes;\r\n        const quality = chunk.quality;\r\n        const currentRepresentation = getRepresentationInfo(quality);\r\n\r\n        const voRepresentation = representationController && currentRepresentation ? representationController.getRepresentationForQuality(currentRepresentation.quality) : null;\r\n        const eventStreamMedia = adapter.getEventsFor(currentRepresentation.mediaInfo);\r\n        const eventStreamTrack = adapter.getEventsFor(currentRepresentation, voRepresentation);\r\n\r\n        if (eventStreamMedia && eventStreamMedia.length > 0 || eventStreamTrack && eventStreamTrack.length > 0) {\r\n            const request = fragmentModel.getRequests({\r\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\r\n                quality: quality,\r\n                index: chunk.index\r\n            })[0];\r\n\r\n            const events = handleInbandEvents(bytes, request, eventStreamMedia, eventStreamTrack);\r\n            eventBus.trigger(Events.INBAND_EVENTS,\r\n                { events: events },\r\n                { streamId: streamInfo.id }\r\n            );\r\n        }\r\n    }\r\n\r\n    function handleInbandEvents(data, request, mediaInbandEvents, trackInbandEvents) {\r\n        try {\r\n            const eventStreams = {};\r\n            const events = [];\r\n\r\n            /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\r\n            const inbandEvents = mediaInbandEvents.concat(trackInbandEvents);\r\n            for (let i = 0, ln = inbandEvents.length; i < ln; i++) {\r\n                eventStreams[inbandEvents[i].schemeIdUri + '/' + inbandEvents[i].value] = inbandEvents[i];\r\n            }\r\n\r\n            const isoFile = BoxParser(context).getInstance().parse(data);\r\n            const eventBoxes = isoFile.getBoxes('emsg');\r\n\r\n            if (!eventBoxes || eventBoxes.length === 0) {\r\n                return events;\r\n            }\r\n\r\n            const sidx = isoFile.getBox('sidx');\r\n            const mediaAnchorTime = sidx && !isNaN(sidx.earliest_presentation_time) && !isNaN(sidx.timescale) ? sidx.earliest_presentation_time / sidx.timescale : request && !isNaN(request.mediaStartTime) ? request.mediaStartTime : 0;\r\n            const fragmentMediaStartTime = Math.max(mediaAnchorTime, 0);\r\n            const voRepresentation = representationController.getCurrentRepresentation();\r\n\r\n            for (let i = 0, ln = eventBoxes.length; i < ln; i++) {\r\n                const event = adapter.getEvent(eventBoxes[i], eventStreams, fragmentMediaStartTime, voRepresentation);\r\n\r\n                if (event) {\r\n                    events.push(event);\r\n                }\r\n            }\r\n\r\n            return events;\r\n        } catch (e) {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    function createBuffer(previousBuffers) {\r\n        return (getBuffer() || bufferController ? bufferController.createBuffer(mediaInfoArr, previousBuffers) : null);\r\n    }\r\n\r\n    function switchTrackAsked() {\r\n        scheduleController.switchTrackAsked();\r\n    }\r\n\r\n    function createBufferControllerForType(type) {\r\n        let controller = null;\r\n\r\n        if (!type) {\r\n            errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + 'not properly defined'));\r\n            return null;\r\n        }\r\n\r\n        if (type === Constants.VIDEO || type === Constants.AUDIO) {\r\n            controller = BufferController(context).create({\r\n                streamInfo: streamInfo,\r\n                type: type,\r\n                mediaPlayerModel: mediaPlayerModel,\r\n                manifestModel: manifestModel,\r\n                fragmentModel: fragmentModel,\r\n                errHandler: errHandler,\r\n                mediaController: mediaController,\r\n                representationController: representationController,\r\n                adapter: adapter,\r\n                textController: textController,\r\n                abrController: abrController,\r\n                playbackController: playbackController,\r\n                settings: settings\r\n            });\r\n        } else {\r\n            controller = TextBufferController(context).create({\r\n                streamInfo: streamInfo,\r\n                type: type,\r\n                mimeType: mimeType,\r\n                mediaPlayerModel: mediaPlayerModel,\r\n                manifestModel: manifestModel,\r\n                fragmentModel: fragmentModel,\r\n                errHandler: errHandler,\r\n                mediaController: mediaController,\r\n                representationController: representationController,\r\n                adapter: adapter,\r\n                textController: textController,\r\n                abrController: abrController,\r\n                playbackController: playbackController,\r\n                settings: settings\r\n            });\r\n        }\r\n\r\n        return controller;\r\n    }\r\n\r\n\r\n    function getLiveStartTime() {\r\n        if (!isDynamic) return NaN;\r\n        if (!liveEdgeFinder) return NaN;\r\n\r\n        let liveStartTime = NaN;\r\n        const currentRepresentationInfo = getRepresentationInfo();\r\n        const liveEdge = liveEdgeFinder.getLiveEdge(currentRepresentationInfo);\r\n\r\n        if (isNaN(liveEdge)) {\r\n            return NaN;\r\n        }\r\n\r\n        const request = findRequestForLiveEdge(liveEdge, currentRepresentationInfo);\r\n\r\n        if (request) {\r\n            // When low latency mode is selected but browser doesn't support fetch\r\n            // start at the beginning of the segment to avoid consuming the whole buffer\r\n            if (settings.get().streaming.lowLatencyEnabled) {\r\n                liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\r\n            } else {\r\n                liveStartTime = request.startTime;\r\n            }\r\n        }\r\n\r\n        return liveStartTime;\r\n    }\r\n\r\n    function findRequestForLiveEdge(liveEdge, currentRepresentationInfo) {\r\n        try {\r\n            let request = null;\r\n            let liveDelay = playbackController.getLiveDelay();\r\n            const dvrWindowSize = !isNaN(streamInfo.manifestInfo.DVRWindowSize) ? streamInfo.manifestInfo.DVRWindowSize : liveDelay;\r\n            const dvrWindowSafetyMargin = 0.1 * dvrWindowSize;\r\n            let startTime;\r\n\r\n            // Make sure that we have at least a valid request for the end of the DVR window, otherwise we might try forever\r\n            if (!isFinite(dvrWindowSize) || getFragmentRequest(currentRepresentationInfo, liveEdge - dvrWindowSize + dvrWindowSafetyMargin, {\r\n                ignoreIsFinished: true\r\n            })) {\r\n\r\n                // Try to find a request as close as possible to the targeted live edge\r\n                while (!request && liveDelay <= dvrWindowSize) {\r\n                    startTime = liveEdge - liveDelay;\r\n                    request = getFragmentRequest(currentRepresentationInfo, startTime, {\r\n                        ignoreIsFinished: true\r\n                    });\r\n                    if (!request) {\r\n                        liveDelay += 1; // Increase by one second for each iteration\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (request) {\r\n                playbackController.setLiveDelay(liveDelay, true);\r\n            }\r\n            logger.debug('live edge: ' + liveEdge + ', live delay: ' + liveDelay + ', live target: ' + startTime);\r\n            return request;\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function onSeekTarget(e) {\r\n        bufferingTime = e.time;\r\n        scheduleController.setSeekTarget(e.time);\r\n    }\r\n\r\n    function setBufferingTime(value) {\r\n        bufferingTime = value;\r\n    }\r\n\r\n    function resetIndexHandler() {\r\n        if (indexHandler) {\r\n            indexHandler.resetIndex();\r\n        }\r\n    }\r\n\r\n    function getInitRequest(quality) {\r\n        checkInteger(quality);\r\n        const representation = representationController ? representationController.getRepresentationForQuality(quality) : null;\r\n        return indexHandler ? indexHandler.getInitRequest(getMediaInfo(), representation) : null;\r\n    }\r\n\r\n    function getFragmentRequest(representationInfo, time, options) {\r\n        let fragRequest = null;\r\n\r\n        if (indexHandler) {\r\n            const representation = representationController && representationInfo ? representationController.getRepresentationForQuality(representationInfo.quality) : null;\r\n\r\n            // if time and options are undefined, it means the next segment is requested\r\n            // otherwise, the segment at this specific time is requested.\r\n            if (time !== undefined && options !== undefined) {\r\n                fragRequest = indexHandler.getSegmentRequestForTime(getMediaInfo(), representation, time, options);\r\n            } else {\r\n                fragRequest = indexHandler.getNextSegmentRequest(getMediaInfo(), representation);\r\n            }\r\n        }\r\n\r\n        return fragRequest;\r\n    }\r\n\r\n    function finalisePlayList(time, reason) {\r\n        dashMetrics.pushPlayListTraceMetrics(time, reason);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getStreamId: getStreamId,\r\n        getType: getType,\r\n        isUpdating: isUpdating,\r\n        getBufferController: getBufferController,\r\n        getFragmentModel: getFragmentModel,\r\n        getScheduleController: getScheduleController,\r\n        getRepresentationController: getRepresentationController,\r\n        getRepresentationInfo: getRepresentationInfo,\r\n        getBufferLevel: getBufferLevel,\r\n        isBufferingCompleted: isBufferingCompleted,\r\n        createBuffer: createBuffer,\r\n        updateStreamInfo: updateStreamInfo,\r\n        getStreamInfo: getStreamInfo,\r\n        selectMediaInfo: selectMediaInfo,\r\n        addMediaInfo: addMediaInfo,\r\n        getLiveStartTime: getLiveStartTime,\r\n        switchTrackAsked: switchTrackAsked,\r\n        getMediaInfoArr: getMediaInfoArr,\r\n        getMediaInfo: getMediaInfo,\r\n        getMediaSource: getMediaSource,\r\n        setMediaSource: setMediaSource,\r\n        dischargePreBuffer: dischargePreBuffer,\r\n        getBuffer: getBuffer,\r\n        setBuffer: setBuffer,\r\n        setBufferingTime: setBufferingTime,\r\n        resetIndexHandler: resetIndexHandler,\r\n        getInitRequest: getInitRequest,\r\n        getFragmentRequest: getFragmentRequest,\r\n        finalisePlayList: finalisePlayList,\r\n        probeNextRequest: probeNextRequest,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nStreamProcessor.__dashjs_factory_name = 'StreamProcessor';\r\nexport default FactoryMaker.getClassFactory(StreamProcessor);\r\n"]}