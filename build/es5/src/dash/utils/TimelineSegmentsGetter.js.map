{"version":3,"sources":["../../../../../src/dash/utils/TimelineSegmentsGetter.js"],"names":["TimelineSegmentsGetter","config","isDynamic","timelineConverter","instance","checkConfig","hasOwnProperty","Error","Constants","MISSING_CONFIG_ERROR","iterateSegments","representation","iterFunc","base","adaptation","period","mpd","manifest","Period_asArray","index","AdaptationSet_asArray","Representation_asArray","SegmentTemplate","SegmentList","timeline","SegmentTimeline","list","SegmentURL_asArray","time","scaledTime","availabilityIdx","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","fTimescale","timescale","S_asArray","breakIterator","length","r","t","availabilityEnd","segmentAvailabilityRange","end","calcSegmentAvailabilityRange","calcMediaTimeFromPresentationTime","segmentDuration","d","Math","ceil","availableSegmentsNumber","getSegmentByIndex","lastSegmentTime","segment","found","media","mediaRange","tManifest","getSegmentByTime","requestedTime","undefined","requiredMediaTime","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"mappings":"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","file":"TimelineSegmentsGetter.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Constants from '../../streaming/constants/Constants';\r\n\r\nimport { getTimeBasedSegment } from './SegmentsUtils';\r\n\r\nfunction TimelineSegmentsGetter(config, isDynamic) {\r\n\r\n    config = config || {};\r\n    const timelineConverter = config.timelineConverter;\r\n\r\n    let instance;\r\n\r\n    function checkConfig() {\r\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\r\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\r\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\r\n        }\r\n    }\r\n\r\n    function iterateSegments(representation, iterFunc) {\r\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\r\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\r\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\r\n                AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\r\n        const timeline = base.SegmentTimeline;\r\n        const list = base.SegmentURL_asArray;\r\n\r\n        let time = 0;\r\n        let scaledTime = 0;\r\n        let availabilityIdx = -1;\r\n\r\n        let fragments,\r\n            frag,\r\n            i,\r\n            len,\r\n            j,\r\n            repeat,\r\n            repeatEndTime,\r\n            nextFrag,\r\n            fTimescale;\r\n\r\n        fTimescale = representation.timescale;\r\n        fragments = timeline.S_asArray;\r\n\r\n        let breakIterator = false;\r\n\r\n        for (i = 0, len = fragments.length; i < len && !breakIterator; i++) {\r\n            frag = fragments[i];\r\n            repeat = 0;\r\n            if (frag.hasOwnProperty('r')) {\r\n                repeat = frag.r;\r\n            }\r\n\r\n            // For a repeated S element, t belongs only to the first segment\r\n            if (frag.hasOwnProperty('t')) {\r\n                time = frag.t;\r\n                scaledTime = time / fTimescale;\r\n            }\r\n\r\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\r\n            // next MPD update.\"\r\n            if (repeat < 0) {\r\n                nextFrag = fragments[i + 1];\r\n\r\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\r\n                    repeatEndTime = nextFrag.t / fTimescale;\r\n                } else {\r\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\r\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\r\n                    representation.segmentDuration = frag.d / fTimescale;\r\n                }\r\n\r\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\r\n            }\r\n\r\n            for (j = 0; j <= repeat && !breakIterator; j++) {\r\n                availabilityIdx++;\r\n\r\n                breakIterator = iterFunc(time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i);\r\n\r\n                if (breakIterator) {\r\n                    representation.segmentDuration = frag.d / fTimescale;\r\n\r\n                    // check if there is at least one more segment\r\n                    if (j < repeat - 1 || i < len - 1) {\r\n                        availabilityIdx++;\r\n                    }\r\n                }\r\n\r\n                time += frag.d;\r\n                scaledTime = time / fTimescale;\r\n            }\r\n        }\r\n\r\n        representation.availableSegmentsNumber = availabilityIdx;\r\n    }\r\n\r\n    function getSegmentByIndex(representation, index, lastSegmentTime) {\r\n        checkConfig();\r\n\r\n        if (!representation) {\r\n            return null;\r\n        }\r\n\r\n        let segment = null;\r\n        let found = false;\r\n\r\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\r\n            if (found || lastSegmentTime < 0) {\r\n                let media = base.media;\r\n                let mediaRange = frag.mediaRange;\r\n\r\n                if (list) {\r\n                    media = list[i].media || '';\r\n                    mediaRange = list[i].mediaRange;\r\n                }\r\n\r\n                segment = getTimeBasedSegment(\r\n                    timelineConverter,\r\n                    isDynamic,\r\n                    representation,\r\n                    time,\r\n                    frag.d,\r\n                    fTimescale,\r\n                    media,\r\n                    mediaRange,\r\n                    availabilityIdx,\r\n                    frag.tManifest);\r\n\r\n                return true;\r\n            } else if (scaledTime >= lastSegmentTime - frag.d * 0.5 / fTimescale) { // same logic, if deviation is\r\n                // 50% of segment duration, segment is found if scaledTime is greater than or equal to (startTime of previous segment - half of the previous segment duration)\r\n                found = true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return segment;\r\n    }\r\n\r\n    function getSegmentByTime(representation, requestedTime) {\r\n        checkConfig();\r\n\r\n        if (!representation) {\r\n            return null;\r\n        }\r\n\r\n        if (requestedTime === undefined) {\r\n            requestedTime = null;\r\n        }\r\n\r\n        let segment = null;\r\n        const requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\r\n\r\n        iterateSegments(representation, function (time, scaledTime, base, list, frag, fTimescale, availabilityIdx, i) {\r\n            // In some cases when requiredMediaTime = actual end time of the last segment\r\n            // it is possible that this time a bit exceeds the declared end time of the last segment.\r\n            // in this case we still need to include the last segment in the segment list.\r\n            if (requiredMediaTime < (scaledTime + (frag.d / fTimescale))) {\r\n                let media = base.media;\r\n                let mediaRange = frag.mediaRange;\r\n\r\n                if (list) {\r\n                    media = list[i].media || '';\r\n                    mediaRange = list[i].mediaRange;\r\n                }\r\n\r\n                segment = getTimeBasedSegment(\r\n                    timelineConverter,\r\n                    isDynamic,\r\n                    representation,\r\n                    time,\r\n                    frag.d,\r\n                    fTimescale,\r\n                    media,\r\n                    mediaRange,\r\n                    availabilityIdx,\r\n                    frag.tManifest);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        });\r\n\r\n        return segment;\r\n    }\r\n\r\n\r\n    instance = {\r\n        getSegmentByIndex: getSegmentByIndex,\r\n        getSegmentByTime: getSegmentByTime\r\n    };\r\n\r\n    return instance;\r\n}\r\n\r\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\r\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\r\nexport default factory;\r\n"]}