{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":["unescapeDollarsInTemplate","replaceIDForTemplate","replaceTokenForTemplate","getIndexBasedSegment","getTimeBasedSegment","zeroPadToLength","numStr","minStrLength","length","getNumberForSegment","segment","segmentIndex","representation","startNumber","url","split","join","value","indexOf","v","toString","token","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","formatTagLen","charAt","parseInt","substring","toUpperCase","getSegment","duration","presentationStartTime","mediaStartTime","availabilityStartTime","timelineConverter","presentationEndTime","isDynamic","index","seg","Segment","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","adaptation","period","mpd","wallStartTime","calcWallTimeForSegment","replacementNumber","availabilityIdx","isSegmentAvailable","periodEnd","getPeriodEnd","periodRelativeEnd","calcPeriodRelativeTimeFromMpdRelativeTime","segmentTime","segmentAvailabilityRange","end","segmentDuration","isNaN","parseFloat","start","toFixed","calcMediaTimeFromPresentationTime","calcAvailabilityStartTimeFromPresentationTime","time","fTimescale","range","tManifest","scaledTime","scaledDuration","Math","min","maxSegmentDuration","calcPresentationTimeFromMediaTime","manifest","loadedTime","replacementTime","media","mediaRange"],"mappings":"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","file":"SegmentsUtils.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport Segment from './../vo/Segment';\r\n\r\nfunction zeroPadToLength(numStr, minStrLength) {\r\n    while (numStr.length < minStrLength) {\r\n        numStr = '0' + numStr;\r\n    }\r\n    return numStr;\r\n}\r\n\r\nfunction getNumberForSegment(segment, segmentIndex) {\r\n    return segment.representation.startNumber + segmentIndex;\r\n}\r\n\r\nexport function unescapeDollarsInTemplate(url) {\r\n    return url ? url.split('$$').join('$') : url;\r\n}\r\n\r\nexport function replaceIDForTemplate(url, value) {\r\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) {\r\n        return url;\r\n    }\r\n    let v = value.toString();\r\n    return url.split('$RepresentationID$').join(v);\r\n}\r\n\r\nexport function replaceTokenForTemplate(url, token, value) {\r\n    const formatTag = '%0';\r\n\r\n    let startPos,\r\n        endPos,\r\n        formatTagPos,\r\n        specifier,\r\n        width,\r\n        paddedValue;\r\n\r\n    const tokenLen = token.length;\r\n    const formatTagLen = formatTag.length;\r\n\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // keep looping round until all instances of <token> have been\r\n    // replaced. once that has happened, startPos below will be -1\r\n    // and the completed url will be returned.\r\n    while (true) {\r\n\r\n        // check if there is a valid $<token>...$ identifier\r\n        // if not, return the url as is.\r\n        startPos = url.indexOf('$' + token);\r\n        if (startPos < 0) {\r\n            return url;\r\n        }\r\n\r\n        // the next '$' must be the end of the identifier\r\n        // if there isn't one, return the url as is.\r\n        endPos = url.indexOf('$', startPos + tokenLen);\r\n        if (endPos < 0) {\r\n            return url;\r\n        }\r\n\r\n        // now see if there is an additional format tag suffixed to\r\n        // the identifier within the enclosing '$' characters\r\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\r\n        if (formatTagPos > startPos && formatTagPos < endPos) {\r\n\r\n            specifier = url.charAt(endPos - 1);\r\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\r\n\r\n            // support the minimum specifiers required by IEEE 1003.1\r\n            // (d, i , o, u, x, and X) for completeness\r\n            switch (specifier) {\r\n                // treat all int types as uint,\r\n                // hence deliberate fallthrough\r\n                case 'd':\r\n                case 'i':\r\n                case 'u':\r\n                    paddedValue = zeroPadToLength(value.toString(), width);\r\n                    break;\r\n                case 'x':\r\n                    paddedValue = zeroPadToLength(value.toString(16), width);\r\n                    break;\r\n                case 'X':\r\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\r\n                    break;\r\n                case 'o':\r\n                    paddedValue = zeroPadToLength(value.toString(8), width);\r\n                    break;\r\n                default:\r\n                    return url;\r\n            }\r\n        } else {\r\n            paddedValue = value;\r\n        }\r\n\r\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\r\n    }\r\n}\r\n\r\nfunction getSegment(representation, duration, presentationStartTime, mediaStartTime, availabilityStartTime,\r\n                    timelineConverter, presentationEndTime, isDynamic, index) {\r\n    let seg = new Segment();\r\n\r\n    seg.representation = representation;\r\n    seg.duration = duration;\r\n    seg.presentationStartTime = presentationStartTime;\r\n    seg.mediaStartTime = mediaStartTime;\r\n    seg.availabilityStartTime = availabilityStartTime;\r\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\r\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\r\n    seg.replacementNumber = getNumberForSegment(seg, index);\r\n    seg.availabilityIdx = index;\r\n\r\n    return seg;\r\n}\r\n\r\nfunction isSegmentAvailable(timelineConverter, representation, segment, isDynamic) {\r\n    const periodEnd = timelineConverter.getPeriodEnd(representation, isDynamic);\r\n    const periodRelativeEnd = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, periodEnd);\r\n\r\n    const segmentTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, segment.presentationStartTime);\r\n    if (segmentTime >= periodRelativeEnd) {\r\n        if (isDynamic) {\r\n            // segment is not available in current period, but it may be segment available in another period that current one (in DVR window)\r\n            // if not (time > segmentAvailabilityRange.end), then return false\r\n            if (representation.segmentAvailabilityRange && segment.presentationStartTime >= representation.segmentAvailabilityRange.end) {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\r\n    let duration,\r\n        presentationStartTime,\r\n        presentationEndTime;\r\n\r\n    duration = representation.segmentDuration;\r\n\r\n    /*\r\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\r\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\r\n     * in the same way as for the last Media Segment in the Representation.\r\n     */\r\n    if (isNaN(duration)) {\r\n        duration = representation.adaptation.period.duration;\r\n    }\r\n\r\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\r\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\r\n\r\n    const segment = getSegment(representation, duration, presentationStartTime,\r\n        timelineConverter.calcMediaTimeFromPresentationTime(presentationStartTime, representation),\r\n        timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic),\r\n        timelineConverter, presentationEndTime, isDynamic, index);\r\n\r\n    if (!isSegmentAvailable(timelineConverter, representation, segment, isDynamic)) {\r\n        return null;\r\n    }\r\n\r\n    return segment;\r\n}\r\n\r\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\r\n    const scaledTime = time / fTimescale;\r\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\r\n\r\n    let presentationStartTime,\r\n        presentationEndTime,\r\n        seg;\r\n\r\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\r\n    presentationEndTime = presentationStartTime + scaledDuration;\r\n\r\n    seg = getSegment(representation, scaledDuration, presentationStartTime,\r\n        scaledTime,\r\n        representation.adaptation.period.mpd.manifest.loadedTime,\r\n        timelineConverter, presentationEndTime, isDynamic, index);\r\n\r\n    if (!isSegmentAvailable(timelineConverter, representation, seg, isDynamic)) {\r\n        return null;\r\n    }\r\n\r\n    seg.replacementTime = tManifest ? tManifest : time;\r\n\r\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\r\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\r\n    seg.media = url;\r\n    seg.mediaRange = range;\r\n\r\n    return seg;\r\n}\r\n"]}