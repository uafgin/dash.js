{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["TimelineConverter","context","eventBus","getInstance","settings","instance","dashManifestModel","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","setup","reset","initialize","resetInitialSettings","on","Events","UPDATE_TIME_SYNC_OFFSET","_onUpdateTimeSyncOffset","getClientTimeOffset","setClientTimeOffset","value","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","segmentInfoType","DashConstants","SEGMENT_TIMELINE","get","streaming","calcSegmentAvailabilityRangeFromTimeline","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","manifest","Period_asArray","index","AdaptationSet_asArray","getRepresentationFor","timeline","SegmentTemplate","SegmentTimeline","timescale","S_asArray","repeat","i","len","t","hasOwnProperty","r","getPeriodEnd","min","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","off","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport DashConstants from '../constants/DashConstants';\r\nimport DashManifestModel from '../models/DashManifestModel';\r\nimport Settings from '../../core/Settings';\r\n\r\nfunction TimelineConverter() {\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const settings = Settings(context).getInstance();\r\n\r\n    let instance,\r\n        dashManifestModel,\r\n        clientServerTimeShift,\r\n        isClientServerTimeSyncCompleted,\r\n        expectedLiveEdge;\r\n\r\n    function setup() {\r\n        dashManifestModel = DashManifestModel(context).getInstance();\r\n        reset();\r\n    }\r\n\r\n    function initialize() {\r\n        resetInitialSettings();\r\n        eventBus.on(Events.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\r\n    }\r\n\r\n    function getClientTimeOffset() {\r\n        return clientServerTimeShift;\r\n    }\r\n\r\n    function setClientTimeOffset(value) {\r\n        clientServerTimeShift = value;\r\n    }\r\n\r\n    function getExpectedLiveEdge() {\r\n        return expectedLiveEdge;\r\n    }\r\n\r\n    function setExpectedLiveEdge(value) {\r\n        expectedLiveEdge = value;\r\n    }\r\n\r\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\r\n        let availabilityTime = NaN;\r\n\r\n        if (calculateEnd) {\r\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\r\n            // to be available for a Media Presentation with type 'dynamic'.\r\n            // When not present, the value is infinite.\r\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\r\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\r\n            } else {\r\n                availabilityTime = mpd.availabilityEndTime;\r\n            }\r\n        } else {\r\n            if (isDynamic) {\r\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\r\n            } else {\r\n                // in static mpd, all segments are available at the same time\r\n                availabilityTime = mpd.availabilityStartTime;\r\n            }\r\n        }\r\n\r\n        return availabilityTime;\r\n    }\r\n\r\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\r\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\r\n    }\r\n\r\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\r\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\r\n    }\r\n\r\n    function calcPresentationTimeFromWallTime(wallTime, period) {\r\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\r\n    }\r\n\r\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\r\n        const periodStart = representation.adaptation.period.start;\r\n        const presentationOffset = representation.presentationTimeOffset;\r\n\r\n        return mediaTime + (periodStart - presentationOffset);\r\n    }\r\n\r\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\r\n        const periodStart = representation.adaptation.period.start;\r\n        const presentationOffset = representation.presentationTimeOffset;\r\n\r\n        return presentationTime - periodStart + presentationOffset;\r\n    }\r\n\r\n    function calcWallTimeForSegment(segment, isDynamic) {\r\n        let suggestedPresentationDelay,\r\n            displayStartTime,\r\n            wallTime;\r\n\r\n        if (isDynamic) {\r\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\r\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\r\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\r\n        }\r\n\r\n        return wallTime;\r\n    }\r\n\r\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\r\n        // Static Range Finder\r\n        const voPeriod = voRepresentation.adaptation.period;\r\n        const range = {start: voPeriod.start, end: voPeriod.start + voPeriod.duration};\r\n        if (!isDynamic) return range;\r\n\r\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\r\n            return voRepresentation.segmentAvailabilityRange;\r\n        }\r\n\r\n        // Dynamic Range Finder\r\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\r\n\r\n        // Specific use case of SegmentTimeline without timeShiftBufferDepth\r\n        if (voRepresentation.segmentInfoType === DashConstants.SEGMENT_TIMELINE && settings.get().streaming.calcSegmentAvailabilityRangeFromTimeline) {\r\n            return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\r\n        }\r\n\r\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\r\n        const periodEnd = voPeriod.start + voPeriod.duration;\r\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\r\n\r\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\r\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\r\n\r\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\r\n\r\n        return range;\r\n    }\r\n\r\n    function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\r\n        const adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\r\n        const representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\r\n        const timeline = representation.SegmentTemplate.SegmentTimeline;\r\n        const timescale = representation.SegmentTemplate.timescale;\r\n        const segments = timeline.S_asArray;\r\n        const range = {start: 0, end: 0};\r\n        let d = 0;\r\n        let segment,\r\n            repeat,\r\n            i,\r\n            len;\r\n\r\n        range.start = calcPresentationTimeFromMediaTime(segments[0].t / timescale, voRepresentation);\r\n\r\n        for (i = 0, len = segments.length; i < len; i++) {\r\n            segment = segments[i];\r\n            repeat = 0;\r\n            if (segment.hasOwnProperty('r')) {\r\n                repeat = segment.r;\r\n            }\r\n            d += (segment.d / timescale) * (1 + repeat);\r\n        }\r\n\r\n        range.end = range.start + d;\r\n\r\n        return range;\r\n    }\r\n\r\n    function getPeriodEnd(voRepresentation, isDynamic) {\r\n        // Static Range Finder\r\n        const voPeriod = voRepresentation.adaptation.period;\r\n        if (!isDynamic) {\r\n            return voPeriod.start + voPeriod.duration;\r\n        }\r\n\r\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\r\n            return voRepresentation.segmentAvailabilityRange;\r\n        }\r\n\r\n        // Dynamic Range Finder\r\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\r\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\r\n        const periodEnd = voPeriod.start + voPeriod.duration;\r\n\r\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\r\n        voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\r\n\r\n        return Math.min(now - endOffset, periodEnd);\r\n    }\r\n\r\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\r\n        const periodStartTime = representation.adaptation.period.start;\r\n        return mpdRelativeTime - periodStartTime;\r\n    }\r\n\r\n    /*\r\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\r\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\r\n    * FYI StreamController's onManifestUpdated entry point to timeSync\r\n    * */\r\n    function _onUpdateTimeSyncOffset(e) {\r\n        if (e.offset !== undefined) {\r\n            setClientTimeOffset(e.offset / 1000);\r\n            isClientServerTimeSyncCompleted = true;\r\n        }\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        clientServerTimeShift = 0;\r\n        isClientServerTimeSyncCompleted = false;\r\n        expectedLiveEdge = NaN;\r\n    }\r\n\r\n    function reset() {\r\n        eventBus.off(Events.UPDATE_TIME_SYNC_OFFSET, _onUpdateTimeSyncOffset, this);\r\n        resetInitialSettings();\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getClientTimeOffset: getClientTimeOffset,\r\n        setClientTimeOffset: setClientTimeOffset,\r\n        getExpectedLiveEdge: getExpectedLiveEdge,\r\n        setExpectedLiveEdge: setExpectedLiveEdge,\r\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\r\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\r\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\r\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\r\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\r\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\r\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\r\n        getPeriodEnd: getPeriodEnd,\r\n        calcWallTimeForSegment: calcWallTimeForSegment,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\r\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);\r\n"]}