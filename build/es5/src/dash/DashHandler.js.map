{"version":3,"sources":["../../../../src/dash/DashHandler.js"],"names":["DashHandler","config","context","eventBus","events","debug","dashConstants","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","isDynamicManifest","dynamicStreamCompleted","selectedMimeType","segmentsController","setup","getLogger","resetInitialSettings","create","on","INITIALIZATION_LOADED","onInitializationLoaded","SEGMENTS_LOADED","onSegmentsLoaded","REPRESENTATION_UPDATE_STARTED","onRepresentationUpdateStarted","DYNAMIC_TO_STATIC","onDynamicToStatic","initialize","isDynamic","getStreamId","id","getType","getStreamInfo","setCurrentIndex","value","getCurrentIndex","resetIndex","reset","off","setRequestUrl","request","destination","representation","baseURL","resolve","path","url","serviceLocation","isRelative","generateInitRequest","mediaInfo","mediaType","FragmentRequest","period","adaptation","presentationStartTime","start","HTTPRequest","INIT_SEGMENT_TYPE","range","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","duration","quality","index","representationId","initialization","bandwidth","getInitRequest","setMimeType","newMimeType","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","e","processRepresentation","voRepresentation","hasInitialization","hasSegments","trigger","REPRESENTATION_UPDATE_COMPLETED","streamId","update","getRequestForSegment","segment","undefined","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","media","replacementNumber","replacementTime","MEDIA_SEGMENT_TYPE","mediaRange","startTime","mediaStartTime","timescale","wallStartTime","availabilityIdx","adaptationIndex","isMediaFinished","isFinished","availableSegmentsNumber","time","parseFloat","toFixed","endTime","getSegmentRequestForTime","options","segmentInfoType","idx","keepIdx","ignoreIsFinished","getSegmentByTime","finished","action","ACTION_COMPLETE","SEGMENT_TIMELINE","getNextSegmentRequestIdempotent","indexToRequest","getSegmentByIndex","getNextSegmentRequest","isEndlessMedia","isFinite","segments","error","fragments","count","i","len","s","seg","length","push","segmentAvailabilityRange","end","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"DashHandler.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\r\nimport {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport {\r\n    replaceIDForTemplate,\r\n    unescapeDollarsInTemplate,\r\n    replaceTokenForTemplate,\r\n    getTimeBasedSegment\r\n} from './utils/SegmentsUtils';\r\n\r\nimport SegmentsController from './controllers/SegmentsController';\r\n\r\nfunction DashHandler(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n\r\n    const eventBus = config.eventBus;\r\n    const events = config.events;\r\n    const debug = config.debug;\r\n    const dashConstants = config.dashConstants;\r\n    const urlUtils = config.urlUtils;\r\n    const type = config.type;\r\n    const streamInfo = config.streamInfo;\r\n\r\n    const timelineConverter = config.timelineConverter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const baseURLController = config.baseURLController;\r\n\r\n    let instance,\r\n        logger,\r\n        segmentIndex,\r\n        lastSegment,\r\n        requestedTime,\r\n        isDynamicManifest,\r\n        dynamicStreamCompleted,\r\n        selectedMimeType,\r\n        segmentsController;\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        segmentsController = SegmentsController(context).create(config);\r\n\r\n        eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\r\n        eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\r\n        eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\r\n        eventBus.on(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\r\n    }\r\n\r\n    function initialize(isDynamic) {\r\n        isDynamicManifest = isDynamic;\r\n        dynamicStreamCompleted = false;\r\n        segmentsController.initialize(isDynamic);\r\n    }\r\n\r\n    function getStreamId() {\r\n        return streamInfo.id;\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function setCurrentIndex(value) {\r\n        segmentIndex = value;\r\n    }\r\n\r\n    function getCurrentIndex() {\r\n        return segmentIndex;\r\n    }\r\n\r\n    function resetIndex() {\r\n        segmentIndex = -1;\r\n        lastSegment = null;\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        resetIndex();\r\n        requestedTime = null;\r\n        segmentsController = null;\r\n        selectedMimeType = null;\r\n    }\r\n\r\n    function reset() {\r\n        resetInitialSettings();\r\n\r\n        eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\r\n        eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\r\n        eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\r\n        eventBus.off(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\r\n    }\r\n\r\n    function setRequestUrl(request, destination, representation) {\r\n        const baseURL = baseURLController.resolve(representation.path);\r\n        let url,\r\n            serviceLocation;\r\n\r\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\r\n            url = destination;\r\n        } else {\r\n            url = baseURL.url;\r\n            serviceLocation = baseURL.serviceLocation;\r\n\r\n            if (destination) {\r\n                url = urlUtils.resolve(destination, url);\r\n            }\r\n        }\r\n\r\n        if (urlUtils.isRelative(url)) {\r\n            return false;\r\n        }\r\n\r\n        request.url = url;\r\n        request.serviceLocation = serviceLocation;\r\n\r\n        return true;\r\n    }\r\n\r\n    function generateInitRequest(mediaInfo, representation, mediaType) {\r\n        const request = new FragmentRequest();\r\n        const period = representation.adaptation.period;\r\n        const presentationStartTime = period.start;\r\n\r\n        request.mediaType = mediaType;\r\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\r\n        request.range = representation.range;\r\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\r\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\r\n        request.quality = representation.index;\r\n        request.mediaInfo = mediaInfo;\r\n        request.representationId = representation.id;\r\n\r\n        if (setRequestUrl(request, representation.initialization, representation)) {\r\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\r\n            return request;\r\n        }\r\n    }\r\n\r\n    function getInitRequest(mediaInfo, representation) {\r\n        if (!representation) return null;\r\n        const request = generateInitRequest(mediaInfo, representation, getType());\r\n        return request;\r\n    }\r\n\r\n    function setMimeType(newMimeType) {\r\n        selectedMimeType = newMimeType;\r\n    }\r\n\r\n    function setExpectedLiveEdge(liveEdge) {\r\n        timelineConverter.setExpectedLiveEdge(liveEdge);\r\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\r\n    }\r\n\r\n    function onRepresentationUpdateStarted(e) {\r\n        processRepresentation(e.representation);\r\n    }\r\n\r\n    function processRepresentation(voRepresentation) {\r\n        const hasInitialization = voRepresentation.hasInitialization();\r\n        const hasSegments = voRepresentation.hasSegments();\r\n\r\n        // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\r\n        // otherwise, it means that a request has to be made to get initialization and/or segments informations\r\n        if (hasInitialization && hasSegments) {\r\n            eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\r\n                { representation: voRepresentation },\r\n                { streamId: streamInfo.id, mediaType: type }\r\n            );\r\n        } else {\r\n            segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\r\n        }\r\n    }\r\n\r\n    function getRequestForSegment(mediaInfo, segment) {\r\n        if (segment === null || segment === undefined) {\r\n            return null;\r\n        }\r\n\r\n        const request = new FragmentRequest();\r\n        const representation = segment.representation;\r\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\r\n        let url = segment.media;\r\n\r\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\r\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\r\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\r\n        url = replaceIDForTemplate(url, representation.id);\r\n        url = unescapeDollarsInTemplate(url);\r\n\r\n        request.mediaType = getType();\r\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\r\n        request.range = segment.mediaRange;\r\n        request.startTime = segment.presentationStartTime;\r\n        request.mediaStartTime = segment.mediaStartTime;\r\n        request.duration = segment.duration;\r\n        request.timescale = representation.timescale;\r\n        request.availabilityStartTime = segment.availabilityStartTime;\r\n        request.availabilityEndTime = segment.availabilityEndTime;\r\n        request.wallStartTime = segment.wallStartTime;\r\n        request.quality = representation.index;\r\n        request.index = segment.availabilityIdx;\r\n        request.mediaInfo = mediaInfo;\r\n        request.adaptationIndex = representation.adaptation.index;\r\n        request.representationId = representation.id;\r\n\r\n        if (setRequestUrl(request, url, representation)) {\r\n            return request;\r\n        }\r\n    }\r\n\r\n    function isMediaFinished(representation) {\r\n        let isFinished = false;\r\n\r\n        if (!representation) return isFinished;\r\n\r\n        if (!isDynamicManifest) {\r\n            if (segmentIndex >= representation.availableSegmentsNumber) {\r\n                isFinished = true;\r\n            }\r\n        } else {\r\n            if (dynamicStreamCompleted) {\r\n                isFinished = true;\r\n            } else if (lastSegment) {\r\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\r\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\r\n                const duration = representation.adaptation.period.duration;\r\n\r\n                isFinished = endTime >= duration;\r\n            }\r\n        }\r\n        return isFinished;\r\n    }\r\n\r\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\r\n        let request = null;\r\n\r\n        if (!representation || !representation.segmentInfoType) {\r\n            return request;\r\n        }\r\n\r\n        const idx = segmentIndex;\r\n        const keepIdx = options ? options.keepIdx : false;\r\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\r\n\r\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\r\n            requestedTime = time;\r\n            logger.debug('Getting the request for time : ' + time);\r\n        }\r\n\r\n        const segment = segmentsController.getSegmentByTime(representation, time);\r\n        if (segment) {\r\n            segmentIndex = segment.availabilityIdx;\r\n            lastSegment = segment;\r\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\r\n            request = getRequestForSegment(mediaInfo, segment);\r\n        } else {\r\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\r\n            if (finished) {\r\n                request = new FragmentRequest();\r\n                request.action = FragmentRequest.ACTION_COMPLETE;\r\n                request.index = segmentIndex - 1;\r\n                request.mediaType = type;\r\n                request.mediaInfo = mediaInfo;\r\n                logger.debug('Signal complete in getSegmentRequestForTime');\r\n            }\r\n        }\r\n\r\n        if (keepIdx && idx >= 0) {\r\n            segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\r\n        }\r\n\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * This function returns the next segment request without modifying any internal variables. Any class (e.g CMCD Model) that needs information about the upcoming request should use this method.\r\n     * @param {object} mediaInfo\r\n     * @param {object} representation\r\n     * @return {FragmentRequest|null}\r\n     */\r\n    function getNextSegmentRequestIdempotent(mediaInfo, representation) {\r\n        let request = null;\r\n        let indexToRequest = segmentIndex + 1;\r\n        const segment = segmentsController.getSegmentByIndex(\r\n            representation,\r\n            indexToRequest,\r\n            lastSegment ? lastSegment.mediaStartTime : -1\r\n        );\r\n        if (!segment) return null;\r\n        request = getRequestForSegment(mediaInfo, segment);\r\n        return request;\r\n    }\r\n\r\n    /**\r\n     * Main function to get the next segment request.\r\n     * @param {object} mediaInfo\r\n     * @param {object} representation\r\n     * @return {FragmentRequest|null}\r\n     */\r\n    function getNextSegmentRequest(mediaInfo, representation) {\r\n        let request = null;\r\n\r\n        if (!representation || !representation.segmentInfoType) {\r\n            return null;\r\n        }\r\n\r\n        requestedTime = null;\r\n\r\n        let indexToRequest = segmentIndex + 1;\r\n\r\n        logger.debug('Getting the next request at index: ' + indexToRequest);\r\n        // check that there is a segment in this index\r\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\r\n        if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\r\n            logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\r\n            return null;\r\n        } else {\r\n            if (segment) {\r\n                request = getRequestForSegment(mediaInfo, segment);\r\n                segmentIndex = segment.availabilityIdx;\r\n            } else {\r\n                if (isDynamicManifest) {\r\n                    segmentIndex = indexToRequest - 1;\r\n                } else {\r\n                    segmentIndex = indexToRequest;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (segment) {\r\n            lastSegment = segment;\r\n        } else {\r\n            const finished = isMediaFinished(representation, segment);\r\n            if (finished) {\r\n                request = new FragmentRequest();\r\n                request.action = FragmentRequest.ACTION_COMPLETE;\r\n                request.index = segmentIndex - 1;\r\n                request.mediaType = getType();\r\n                request.mediaInfo = mediaInfo;\r\n                logger.debug('Signal complete');\r\n            }\r\n        }\r\n\r\n        return request;\r\n    }\r\n\r\n    function isEndlessMedia(representation) {\r\n        return !isFinite(representation.adaptation.period.duration);\r\n    }\r\n\r\n    function onInitializationLoaded(e) {\r\n        const representation = e.representation;\r\n        if (!representation.segments) return;\r\n\r\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\r\n            { representation: representation },\r\n            { streamId: streamInfo.id, mediaType: type }\r\n        );\r\n    }\r\n\r\n    function onSegmentsLoaded(e) {\r\n        if (e.error) return;\r\n\r\n        const fragments = e.segments;\r\n        const representation = e.representation;\r\n        const segments = [];\r\n        let count = 0;\r\n\r\n        let i,\r\n            len,\r\n            s,\r\n            seg;\r\n\r\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\r\n            s = fragments[i];\r\n\r\n            seg = getTimeBasedSegment(\r\n                timelineConverter,\r\n                isDynamicManifest,\r\n                representation,\r\n                s.startTime,\r\n                s.duration,\r\n                s.timescale,\r\n                s.media,\r\n                s.mediaRange,\r\n                count);\r\n\r\n            if (seg) {\r\n                segments.push(seg);\r\n                seg = null;\r\n                count++;\r\n            }\r\n        }\r\n\r\n        if (segments.length > 0) {\r\n            representation.segmentAvailabilityRange = {\r\n                start: segments[0].presentationStartTime,\r\n                end: segments[segments.length - 1].presentationStartTime\r\n            };\r\n            representation.availableSegmentsNumber = segments.length;\r\n            representation.segments = segments;\r\n\r\n            if (isDynamicManifest) {\r\n                const lastSegment = segments[segments.length - 1];\r\n                const liveEdge = lastSegment.presentationStartTime - 8;\r\n                // the last segment is the Expected, not calculated, live edge.\r\n                setExpectedLiveEdge(liveEdge);\r\n            }\r\n        }\r\n\r\n        if (!representation.hasInitialization()) {\r\n            return;\r\n        }\r\n\r\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\r\n            { representation: representation },\r\n            { streamId: streamInfo.id, mediaType: type }\r\n        );\r\n    }\r\n\r\n    function onDynamicToStatic() {\r\n        logger.debug('Dynamic stream complete');\r\n        dynamicStreamCompleted = true;\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getStreamId: getStreamId,\r\n        getType: getType,\r\n        getStreamInfo: getStreamInfo,\r\n        getInitRequest: getInitRequest,\r\n        getRequestForSegment: getRequestForSegment,\r\n        getSegmentRequestForTime: getSegmentRequestForTime,\r\n        getNextSegmentRequest: getNextSegmentRequest,\r\n        setCurrentIndex: setCurrentIndex,\r\n        getCurrentIndex: getCurrentIndex,\r\n        isMediaFinished: isMediaFinished,\r\n        reset: reset,\r\n        resetIndex: resetIndex,\r\n        setMimeType: setMimeType,\r\n        getNextSegmentRequestIdempotent\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nDashHandler.__dashjs_factory_name = 'DashHandler';\r\nexport default FactoryMaker.getClassFactory(DashHandler);\r\n"]}