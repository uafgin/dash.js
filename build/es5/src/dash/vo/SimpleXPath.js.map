{"version":3,"sources":["../../../../../src/dash/vo/SimpleXPath.js"],"names":["SimpleXPath","selector","valid","path","split","filter","component","length","map","parsed","name","qualifierPoint","indexOf","substring","qualifier","equalityPoint","attribute","value","position","parseInt","findsAttribute","startsWith","root","isSiblingOperation","parent","leaf","level","children","push","attr","elm","target"],"mappings":"qtBAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA8BA;;;MAIMA,Y,YACF,qBAAYC,QAAZ,CAAsB,kDAClB;AACA,KAAKC,KAAL,CAAaD,SAAS,CAAT,GAAe,GAA5B,CAAiC;AAEjC;AACA;AACA,KAAKE,IAAL,CAAYF,SAASG,KAAT,CAAe,GAAf,EACPC,MADO,CACA,SAACC,SAAD,QAAeA,WAAUC,MAAV,GAAqB,CAApC,EADA,CACuC;AADvC,CAEPC,GAFO,CAEH,SAACF,SAAD,CAAe,CAChB,GAAIG,QAAS,CACTC,KAAMJ,SADG,CAAb,CAIA,GAAIK,gBAAiBL,UAAUM,OAAV,CAAkB,GAAlB,CAArB,CACA,GAAID,gBAAkB,CAAC,CAAvB,CAA0B,CACtBF,OAAOC,IAAP,CAAcJ,UAAUO,SAAV,CAAoB,CAApB,CAAuBF,cAAvB,CAAd,CAEA,GAAIG,WAAYR,UAAUO,SAAV,CAAoBF,eAAiB,CAArC,CAAwCL,UAAUC,MAAV,CAAmB,CAA3D,CAAhB,CAEA;AACA,MAAKL,KAAL,CAAa,MAAKA,KAAL,EAAcY,UAAUF,OAAV,CAAkB,GAAlB,GAA0B,CAAC,CAAtD,CAEA,GAAIG,eAAgBD,UAAUF,OAAV,CAAkB,GAAlB,CAApB,CACA,GAAIG,eAAiB,CAAC,CAAtB,CAAyB,CACrBN,OAAOO,SAAP,CAAmB,CACfN,KAAMI,UAAUD,SAAV,CAAoB,CAApB,CAAuBE,aAAvB,CADS,CAC8B;AAC7CE,MAAOH,UAAUD,SAAV,CAAoBE,cAAgB,CAApC,CAFQ,CAAnB,CAKA;AACA,GAAI,CAAC,IAAD,CAAO,GAAP,EAAYH,OAAZ,CAAoBH,OAAOO,SAAP,CAAiBC,KAAjB,CAAuB,CAAvB,CAApB,GAAkD,CAAC,CAAvD,CAA0D,CACtDR,OAAOO,SAAP,CAAiBC,KAAjB,CAAyBR,OAAOO,SAAP,CAAiBC,KAAjB,CAAuBJ,SAAvB,CAAiC,CAAjC,CAAoCJ,OAAOO,SAAP,CAAiBC,KAAjB,CAAuBV,MAAvB,CAAgC,CAApE,CAAzB,CACH,CACJ,CAVD,IAUO,CACH;AACA;AACAE,OAAOS,QAAP,CAAkBC,SAASL,SAAT,CAAoB,EAApB,EAA0B,CAA5C,CACH,CACJ,CAED,MAAOL,OAAP,CACH,CAnCO,CAAZ,CAoCH,C,iEAES,CACN,MAAO,MAAKP,KAAZ,CACH,C,mDAEc,CACX,MAAO,CAAC,KAAKkB,cAAL,EAAR,CACH,C,uDAEgB,CACb,MAAO,MAAKjB,IAAL,CAAU,KAAKA,IAAL,CAAUI,MAAV,CAAmB,CAA7B,EAAgCG,IAAhC,CAAqCW,UAArC,CAAgD,GAAhD,CAAP,CACH,C,kDAEYC,I,CAAMC,kB,CAAoB,CACnC,GAAIC,QAAS,IAAb,CACA,GAAIC,MAAOH,IAAX,CACA;AACA,GAAII,OAAQ,CAAZ,CACA,GAAIhB,MAAO,KAAX,CAEA,MAAQgB,MAAQ,KAAKvB,IAAL,CAAUI,MAAlB,EAA4BkB,OAAS,IAA7C,CAAmD,CAC/C;AACAD,OAASC,IAAT,CAEA;AACA,GAAInB,WAAY,KAAKH,IAAL,CAAUuB,KAAV,CAAhB,CACAhB,KAAOJ,UAAUI,IAAjB,CAEA;AACA,GAAIgB,QAAU,KAAKvB,IAAL,CAAUI,MAAV,CAAmB,CAA7B,EAAkC,CAACG,KAAKW,UAAL,CAAgB,GAAhB,CAAvC,CAA6D,CACzD,GAAIM,UAAWH,OAAOd,KAAO,UAAd,GAA6B,EAA5C,CACA,GAAIiB,SAASpB,MAAT,GAAoB,CAApB,EAAyBiB,OAAOd,IAAP,CAA7B,CAA2C,CACvCiB,SAASC,IAAT,CAAcJ,OAAOd,IAAP,CAAd,EACH,CAED,GAAIJ,UAAUY,QAAd,CAAwB,CACpBO,KAAOE,SAASrB,UAAUY,QAAnB,GAAgC,IAAvC,CACH,CAFD,IAEO,IAAIZ,UAAUU,SAAd,CAAyB,aAC5B,GAAIa,MAAOvB,UAAUU,SAArB,CACAS,KAAOE,SAAStB,MAAT,CAAgB,SAACyB,GAAD,QAASA,KAAID,KAAKnB,IAAT,GAAkBmB,KAAKZ,KAAhC,EAAhB,EAAuD,CAAvD,GAA6D,IAApE,CAF4B,KAG/B,CAHM,IAGA,CACH;AACAQ,KAAOE,SAAS,CAAT,GAAe,IAAtB,CACH,CACJ,CAEDD,QACH,CAED,GAAID,OAAS,IAAb,CAAmB,CACf;AACA,MAAO,KAAP,CACH,CAED;AACA,GAAIf,KAAKW,UAAL,CAAgB,GAAhB,CAAJ,CAA0B,CACtB,MAAO,CACHX,KAAMA,KAAKG,SAAL,CAAe,CAAf,CADH,CAEHY,KAAMA,IAFH,CAGHM,OAAQN,IAHL,CAAP,CAKH,CAED;AACA,MAAO,CACHf,KAAMA,IADH,CAEHe,KAAMA,IAFH,CAGHM,OAAQR,mBAAqBC,MAArB,CAA8BC,IAHnC,CAAP,CAKH,C,2CAGUzB,W","file":"SimpleXPath.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n/**\r\n * @class\r\n * @ignore\r\n */\r\nclass SimpleXPath {\r\n    constructor(selector) {\r\n        // establish validation of the path, to catch unsupported cases\r\n        this.valid = selector[0] == '/'; // first check, we only support absolute addressing\r\n\r\n        // establish parsed path, example:\r\n        // /MPD/Period[@id=\"foobar\"]/AdaptationSet[@id=\"2\"]/SegmentTemplate/SegmentTimeline\r\n        this.path = selector.split('/')\r\n            .filter((component) => component.length !== 0) // remove excess empty components\r\n            .map((component) => {\r\n                let parsed = {\r\n                    name: component\r\n                };\r\n\r\n                let qualifierPoint = component.indexOf('[');\r\n                if (qualifierPoint != -1) {\r\n                    parsed.name = component.substring(0, qualifierPoint);\r\n\r\n                    let qualifier = component.substring(qualifierPoint + 1, component.length - 1);\r\n\r\n                    // quick sanity check are there additional qualifiers making this invalid\r\n                    this.valid = this.valid && qualifier.indexOf('[') == -1;\r\n\r\n                    let equalityPoint = qualifier.indexOf('=');\r\n                    if (equalityPoint != -1) {\r\n                        parsed.attribute = {\r\n                            name: qualifier.substring(1, equalityPoint), // skip the @\r\n                            value: qualifier.substring(equalityPoint + 1)\r\n                        };\r\n\r\n                        // check for single and double quoted attribute values\r\n                        if (['\\'', '\"'].indexOf(parsed.attribute.value[0]) != -1) {\r\n                            parsed.attribute.value = parsed.attribute.value.substring(1, parsed.attribute.value.length - 1);\r\n                        }\r\n                    } else {\r\n                        // positional access in xpath is 1-based index\r\n                        // internal processes will assume 0-based so we normalize that here\r\n                        parsed.position = parseInt(qualifier, 10) - 1;\r\n                    }\r\n                }\r\n\r\n                return parsed;\r\n            });\r\n    }\r\n\r\n    isValid() {\r\n        return this.valid;\r\n    }\r\n\r\n    findsElement() {\r\n        return !this.findsAttribute();\r\n    }\r\n\r\n    findsAttribute() {\r\n        return this.path[this.path.length - 1].name.startsWith('@');\r\n    }\r\n\r\n    getMpdTarget(root, isSiblingOperation) {\r\n        let parent = null;\r\n        let leaf = root;\r\n        // assume root is MPD and we start at next level match\r\n        let level = 1;\r\n        let name = 'MPD';\r\n\r\n        while ( level < this.path.length && leaf !== null) {\r\n            // set parent to current\r\n            parent = leaf;\r\n\r\n            // select next leaf based on component\r\n            let component = this.path[level];\r\n            name = component.name;\r\n\r\n            // stop one early if this is the last element and an attribute\r\n            if (level !== this.path.length - 1 || !name.startsWith('@')) {\r\n                let children = parent[name + '_asArray'] || [];\r\n                if (children.length === 0 && parent[name]) {\r\n                    children.push(parent[name]);\r\n                }\r\n\r\n                if (component.position) {\r\n                    leaf = children[component.position] || null;\r\n                } else if (component.attribute) {\r\n                    let attr = component.attribute;\r\n                    leaf = children.filter((elm) => elm[attr.name] == attr.value)[0] || null;\r\n                } else {\r\n                    // default case, select first\r\n                    leaf = children[0] || null;\r\n                }\r\n            }\r\n\r\n            level++;\r\n        }\r\n\r\n        if (leaf === null) {\r\n            // given path not found in root\r\n            return null;\r\n        }\r\n\r\n        // attributes the target is the leaf node, the name is the attribute\r\n        if (name.startsWith('@')) {\r\n            return {\r\n                name: name.substring(1),\r\n                leaf: leaf,\r\n                target: leaf\r\n            };\r\n        }\r\n\r\n        // otherwise we target the parent for sibling operations and leaf for child operations\r\n        return {\r\n            name: name,\r\n            leaf: leaf,\r\n            target: isSiblingOperation ? parent : leaf\r\n        };\r\n    }\r\n}\r\n\r\nexport default SimpleXPath;\r\n"]}